commit 4c94ac70a13c54d2923e466501ab7e41b13ee353
Author: Ren√© Bertin <rjvbertin@gmail.com>
Date:   Wed May 29 13:45:30 2024 +0200

    lamarck/patch-restore-dpkg+rpm.diff

diff --git a/doc/port.1 b/doc/port.1
index 770bd0dfd..ceef785b4 100644
--- a/doc/port.1
+++ b/doc/port.1
@@ -1297,6 +1297,24 @@ Creates an Internet\-enabled disk image containing a macOS metapackage of
 \fIportname\fR
 and its dependencies\&.
 .RE
+.PP
+rpm
+.RS 4
+Creates an RPM binary package of
+\fIportname\fR, similar to a tgz \(lqarchive\(rq\&.
+.RE
+.PP
+srpm
+.RS 4
+Creates a SRPM source package of
+\fIportname\fR, similar to a xar \(lqportpkg\(rq\&.
+.RE
+.PP
+dpkg
+.RS 4
+Creates a DEB binary package of
+\fIportname\fR\&. Takes an optional "hackers' delight" option \fI--no-deps\fR to omit recording any dependencies in the package.
+.RE
 .SH "EXAMPLES"
 .sp
 The following demonstrates invoking port with the extract action on portdir \(lqtextproc/figlet\(rq and extract\&.suffix set to \(lq\&.tgz\(rq:
diff --git a/doc/port.1.txt b/doc/port.1.txt
index 03882c6c0..98eae80c1 100644
--- a/doc/port.1.txt
+++ b/doc/port.1.txt
@@ -670,6 +670,17 @@ mdmg::
     Creates an Internet-enabled disk image containing a macOS metapackage of
     'portname' and its dependencies.
 
+rpm::
+    Creates an RPM binary package of 'portname', similar to a tgz ``archive''.
+
+srpm::
+    Creates a SRPM source package of 'portname', similar to a xar ``portpkg''.
+
+dpkg::
+    Creates a DEB binary package of 'portname'. Takes an optional "hackers'
+    delight" option \fI--no-deps\fR to omit recording any dependencies in the
+    package.
+
 
 EXAMPLES
 --------
diff --git a/doc/prefix.mtree.in b/doc/prefix.mtree.in
index c30d0bbaf..eceefe2a5 100644
--- a/doc/prefix.mtree.in
+++ b/doc/prefix.mtree.in
@@ -236,6 +236,8 @@
         skel
         ..
     ..
+    src
+    ..
     var
         cache
         ..
diff --git a/portmgr/packaging/SETUP.chroot.sh b/portmgr/packaging/SETUP.chroot.sh
index f21d75f44..207e20801 100755
--- a/portmgr/packaging/SETUP.chroot.sh
+++ b/portmgr/packaging/SETUP.chroot.sh
@@ -31,6 +31,7 @@ mkdir -p /darwinports/distfiles
 mkdir -p /darwinports/logs
 mkdir -p /darwinports/pkgs
 mkdir -p /darwinports/mpkgs
+mkdir -p /darwinports/rpms
 
 cd $HOME/darwinports
 #tclsh base/src/portmgr/packageall.tcl
diff --git a/portmgr/packaging/buildall.sh b/portmgr/packaging/buildall.sh
index e4b065684..1193b5ddc 100755
--- a/portmgr/packaging/buildall.sh
+++ b/portmgr/packaging/buildall.sh
@@ -97,6 +97,9 @@ make clean
 echo "file:///darwinports/dports" > /opt/local/etc/ports/sources.conf
 echo "BatchMode yes" >> /etc/ssh_config
 EOF
+	if [ "$PKGTYPE" = "dpkg" ]; then
+	    echo "/opt/local/bin/port install dpkg" >> $dir/bootstrap.sh
+	fi
 	chmod 755 $dir/bootstrap.sh
 	echo "Bootstrapping darwinports in chroot"
 	/sbin/mount_devfs devfs ${dir}/dev
@@ -134,7 +137,7 @@ teardownchroot() {
 
 # main:  This is where we start the show.
 TGTPORTS=""
-PKGTYPE=mpkg
+PKGTYPE=rpmpackage
 
 if [ $# -lt 1 ]; then
 	echo "Usage: $0 chrootdir [-p pkgtype] [targetportsfile]"
@@ -204,6 +207,10 @@ for pkg in `cat $TGTPORTS`; do
 		echo $pkg >> outputdir/summary/portspackaged
 		if [ "$PKGTYPE" = "mpkg" ]; then
 		    mv $DIR/Package/*.mpkg outputdir/Packages/
+		elif [ "$PKGTYPE" = "rpmpackage" ]; then
+		    mv $DIR/Package/RPMS/${ARCH}/*.rpm outputdir/Packages/
+		elif [ "$PKGTYPE" = "dpkg" ]; then
+		    mv $DIR/Package/*.deb outputdir/Packages/
 		fi
 		type="succeeded"
 	fi
diff --git a/src/macports1.0/macports.tcl b/src/macports1.0/macports.tcl
index b61adc2e4..0564f45ba 100644
--- a/src/macports1.0/macports.tcl
+++ b/src/macports1.0/macports.tcl
@@ -4264,13 +4264,19 @@ proc macports::_target_needs_deps {target} {
         configure -
         build -
         test -
+        srpm -
         destroot -
         install -
         activate -
+        rpm -
+        dpkg -
         dmg -
         mdmg -
         pkg -
-        mpkg {return 1}
+        mpkg -
+        rpm -
+        dpkg -
+        srpm {return 1}
         default {return 0}
     }
 }
diff --git a/src/package1.0/Makefile.in b/src/package1.0/Makefile.in
index b784e4f2f..6fc43afa6 100644
--- a/src/package1.0/Makefile.in
+++ b/src/package1.0/Makefile.in
@@ -6,7 +6,7 @@ include ../../Mk/macports.autoconf.mk
 INSTALLDIR=	${TCL_PACKAGE_PATH}/package1.0
 
 SRCS=	package.tcl portdmg.tcl portmdmg.tcl portmpkg.tcl portpkg.tcl \
-	portunarchive.tcl \
+	portrpm.tcl portsrpm.tcl portdpkg.tcl portunarchive.tcl \
 	portarchivefetch.tcl
 
 all:: pkgIndex.tcl
diff --git a/src/package1.0/package.tcl b/src/package1.0/package.tcl
index 36d5dc7ea..9616d4c5f 100644
--- a/src/package1.0/package.tcl
+++ b/src/package1.0/package.tcl
@@ -32,9 +32,12 @@
 # standard package load
 package provide mp_package 1.0
 
+package require portrpm 1.0
+package require portsrpm 1.0
 package require portpkg 1.0
 package require portmpkg 1.0
 package require portdmg 1.0
 package require portmdmg 1.0
+package require portdpkg 1.0
 package require portarchivefetch 1.0
 package require portunarchive 1.0
diff --git a/src/package1.0/portdpkg.tcl b/src/package1.0/portdpkg.tcl
new file mode 100644
index 0000000000000000000000000000000000000000..7b87cefeee59fde84798b4d928f8eb2ffecf18c8
--- /dev/null
+++ b/src/package1.0/portdpkg.tcl
@@ -0,0 +1,239 @@
+# et:ts=4
+# portdpkg.tcl
+# $Id$
+#
+# Copyright (c) 2005, 2007, 2009, 2011 The MacPorts Project
+# Copyright (c) 2004 Landon Fuller <landonf@macports.org>
+# Copyright (c) 2002 - 2003 Apple Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. Neither the name of Apple Inc. nor the names of its contributors
+#    may be used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+
+package provide portdpkg 1.0
+package require portutil 1.0
+
+set org.macports.dpkg [target_new org.macports.dpkg portdpkg::main]
+target_runtype ${org.macports.dpkg} always
+target_provides ${org.macports.dpkg} dpkg
+target_requires ${org.macports.dpkg} archivefetch unarchive destroot
+
+namespace eval portdpkg {
+}
+
+# Options
+options dpkg.asroot \
+        package.destpath
+
+# Set up defaults
+default dpkg.asroot yes
+
+set_ui_prefix
+
+proc portdpkg::main {args} {
+	global UI_PREFIX destpath os.arch os.platform supported_archs configure.build_arch
+	global portvariants user_options
+
+	ui_msg "$UI_PREFIX [format [msgcat::mc "Creating dpkg for %s-%s"] [option subport] [option version]]"
+
+	switch ${os.platform} {
+	    linux { set project "LinuxPorts" }
+	    default { set project "MacPorts" }
+	}
+
+	if {![info exists user_options(ports_dpkg_no-deps)]} {
+        	# get deplist
+        	set deps [make_dependency_list [option subport]]
+        	set deps [lsort -unique $deps]
+        	foreach dep $deps {
+        		set name [lindex [split $dep /] 0]
+        		set vers [lindex [split $dep /] 1]
+        		# don't re-package ourself
+        		if {$name != [option subport]} {
+        			lappend dependencies "${project}.${name} (>= ${vers})"
+        		}
+        	}
+        
+        	if {[info exists dependencies]} {
+        		ui_debug $dependencies
+        	}
+	} else {
+	    ui_warn "The package will be generated without dependency information!"
+	}
+
+	set controlpath [file join ${destpath} DEBIAN]
+	if {[file exists ${controlpath}]} {
+		if {![file isdirectory ${controlpath}]} {
+			return -code error [format [msgcat::mc "Can not create dpkg control directory. %s not a directory."] ${controlpath}]
+		} else {
+			ui_info [msgcat::mc "Removing stale dpkg control directory."]
+			delete "${controlpath}"
+		}
+	}
+	file mkdir ${controlpath}
+
+	set controlfd [open [file join ${controlpath} control] w+]
+
+	# Size, in kilobytes, of ${destpath}
+   	set pkg_installed-size [expr {[dirSize ${destpath}] / 1024}]
+
+	# Create debian dependency list
+	if {[info exists dependencies]} {
+		if {[llength ${dependencies}] != 0} {
+			set pkg_depends [join ${dependencies} ", "]
+		}
+	}
+
+	# Create dpkg version number
+	if {[option epoch] != 0} {
+		set pkg_version "[option epoch]:[option version]"
+	} else {
+		set pkg_version "[option version]"
+	}
+	if {[option revision] != 0} {
+		append pkg_version "-[option revision]"
+	}
+	# append the port variants string to the revision bit of the Debian version string
+	# there is no more appropriate place and this appears to be acceptable (and useful).
+	if {[option portvariants] ne ""} {
+		append pkg_version "[string map {"_" "~"} [option portvariants]]"
+	}
+
+	# Set dpkg category to first (main) category
+	set pkg_category [lindex [option categories] 0]
+
+	# Format the long description. Add a homepage if possible.
+	if {[exists long_description]} {
+		set pkg_long_description [join [list {*}[option long_description] "\n"] " "]
+	} elseif {[exists description]} {
+		set pkg_long_description " [option description]\n"
+	} else {
+		set pkg_long_description " [option subport]\n"
+	}
+
+     if {[option portvariants] ne ""} {
+		append pkg_long_description " .\n"
+		append pkg_long_description " This package contains the [option portvariants] variant of port:[option subport]\n"
+	}
+	# remove empty lines
+	set pkg_long_description [string map {"\n[ ]*\n" "\n"} ${pkg_long_description}]
+ 	# Indent after a newline
+	set pkg_long_description [string map {"\n" "\n "} ${pkg_long_description}]
+	# prune trailing spaces so we can test properly for a final newline below.
+	while {[string index ${pkg_long_description} end] eq " "} {
+		set pkg_long_description [string range ${pkg_long_description} 0 end-1]
+	}
+
+	# Discern correct architecture
+	# From http://www.debian.org/doc/debian-policy/ch-customized-programs.html#fr55:
+	# The following architectures and operating systems are currently recognised
+	# by dpkg-archictecture. The architecture, arch, is one of the following:
+	# alpha, arm, hppa, i386, ia64, m68k, mips, mipsel, powerpc, s390, sh, sheb,
+	# sparc and sparc64. The operating system, os, is one of: linux, gnu,
+	# freebsd and openbsd. Use of gnu in this string is reserved for the
+	# GNU/Hurd operating system.
+	switch -regex ${configure.build_arch} {
+		i[3-9]86 { set pkg_arch "i386" }
+		x86_64 { set pkg_arch "x86_64" }
+		default { set pkg_arch ${os.arch} }
+	}
+
+	# On systems other than Linux, the Architecture must contain
+	# the operating system name
+	if {${os.platform} != "linux"} {
+		set pkg_arch "${os.platform}-${pkg_arch}"
+	} elseif {${pkg_arch} == "x86_64"} {
+		set pkg_arch "amd64"
+	}
+
+	# An architecture-independent package
+	if {$supported_archs eq "noarch"} {
+		set pkg_arch "all"
+	}
+
+	puts $controlfd "Package: ${project}.[option subport]"
+	puts $controlfd "Architecture: ${pkg_arch}"
+	puts $controlfd "Version: ${pkg_version}"
+	puts $controlfd "Section: ${pkg_category}"
+	puts $controlfd "Maintainer: [option maintainers]"
+	if {[info exists pkg_depends]} {
+		puts $controlfd "Depends: ${pkg_depends}"
+	}
+	puts $controlfd "Installed-Size: ${pkg_installed-size}"
+	puts $controlfd "Provides: [option subport]"
+	puts $controlfd "Replaces: [option subport]"
+
+	puts -nonewline $controlfd "Description: [option description]"
+	puts -nonewline $controlfd " $pkg_long_description"
+	if {[string index ${pkg_long_description} end] ne "\n"} {
+		puts $controlfd ""
+	}
+	if {[exists homepage]} {
+		puts $controlfd "Homepage: [option homepage]"
+	}
+	close $controlfd
+
+	# Build debian package in package.destpath
+	system "dpkg-deb -v -b \"${destpath}\" \"[option package.destpath]\""
+
+	ui_info [msgcat::mc "Removing dpkg control directory."]
+	delete "${controlpath}"
+}
+
+proc portdpkg::make_dependency_list {portname} {
+	set result {}
+	if {[catch {set res [mport_lookup $portname]} error]} {
+		global errorInfo
+		ui_debug "$errorInfo"
+		ui_error "port lookup failed: $error"
+		return 1
+	}
+	foreach {name array} $res {
+		array set portinfo $array
+
+		if {[info exists portinfo(depends_run)] || [info exists portinfo(depends_lib)]} {
+			# get the union of depends_run and depends_lib
+			# xxx: only examines the portfile component of the depspec
+			set depends {}
+			if {[info exists portinfo(depends_run)]} {
+				ui_debug "${name} depends_run=$portinfo(depends_run)"
+				eval "lappend depends $portinfo(depends_run)"
+			}
+			if {[info exists portinfo(depends_lib)]} {
+				ui_debug "${name} depends_lib=$portinfo(depends_lib)"
+				eval "lappend depends $portinfo(depends_lib)"
+			}
+
+			foreach depspec $depends {
+				set dep [lindex [split $depspec :] end]
+				eval "lappend result [make_dependency_list $dep]"
+			}
+		}
+				ui_debug "${name} : $portinfo(name) / $portinfo(version)"
+				lappend result $portinfo(name)/$portinfo(version)
+				unset portinfo
+	}
+	return $result
+}
diff --git a/src/package1.0/portrpm.tcl b/src/package1.0/portrpm.tcl
new file mode 100644
index 000000000..6d385b1e5
--- /dev/null
+++ b/src/package1.0/portrpm.tcl
@@ -0,0 +1,250 @@
+# et:ts=4
+# portrpm.tcl
+# $Id$
+#
+# Copyright (c) 2005 - 2007, 2009 - 2011, 2013 The MacPorts Project
+# Copyright (c) 2002 - 2003 Apple Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. Neither the name of Apple Inc. nor the names of its contributors
+#    may be used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+
+package provide portrpm 1.0
+package require portutil 1.0
+
+set org.macports.rpm [target_new org.macports.rpm portrpm::rpm_main]
+target_runtype ${org.macports.rpm} always
+target_provides ${org.macports.rpm} rpm
+target_requires ${org.macports.rpm} archivefetch unarchive destroot
+
+namespace eval portrpm {
+}
+
+# Options
+options rpm.asroot \
+        package.destpath
+
+# Set up defaults
+default rpm.asroot yes
+
+default rpm.srcdir {${prefix}/src/macports}
+default rpm.tmpdir {${prefix}/var/tmp}
+
+set_ui_prefix
+
+proc portrpm::rpm_main {args} {
+    global subport version revision UI_PREFIX
+
+    ui_msg "$UI_PREFIX [format [msgcat::mc "Creating RPM package for %s-%s"] ${subport} ${version}]"
+
+    return [rpm_pkg $subport $version $revision]
+}
+
+proc portrpm::rpm_pkg {portname portversion portrevision} {
+    global UI_PREFIX rpm.asroot package.destpath portdbpath destpath workpath \
+           prefix categories maintainers description long_description \
+           homepage epoch portpath os.platform os.arch os.version os.major \
+           supported_archs configure.build_arch license
+
+    set rpmdestpath ""
+    if {![string equal ${package.destpath} ${workpath}] && ![string equal ${package.destpath} ""]} {
+        set rpm.asroot no
+        set pkgpath ${package.destpath}
+        file mkdir ${pkgpath}/BUILD \
+                   ${pkgpath}/RPMS \
+                   ${pkgpath}/SOURCES \
+                   ${pkgpath}/SPECS \
+                   ${pkgpath}/SRPMS
+        set rpmdestpath "--define '_topdir ${pkgpath}'"
+    }
+
+    set rpmbuildarch ""
+    if {$supported_archs eq "noarch"} {
+        set rpmbuildarch "--target noarch"
+    } elseif {[variant_exists universal] && [variant_isset universal]} {
+        set rpmbuildarch "--target fat"
+    } elseif {${configure.build_arch} != ""} {
+        set rpmbuildarch "--target ${configure.build_arch}"
+    }
+
+    foreach dir [list "${prefix}/src/macports/RPMS" "${prefix}/src/apple/RPMS" "/usr/src/apple/RPMS" "/macports/rpms/RPMS"] {
+        foreach arch [list ${configure.build_arch} ${os.arch} "fat" "noarch"] {
+            set rpmpath "$dir/${arch}/${portname}-${portversion}-${portrevision}.${arch}.rpm"
+	    if {[file readable $rpmpath] && ([file mtime ${rpmpath}] >= [file mtime ${portpath}/Portfile])} {
+                ui_debug "$rpmpath"
+                ui_msg "$UI_PREFIX [format [msgcat::mc "RPM package for %s version %s is up-to-date"] ${portname} ${portversion}]"
+                return 0
+            }
+        }
+    }
+
+    set specpath ${workpath}/${portname}.spec
+    # long_description, description, or homepage may not exist
+    foreach variable {long_description description homepage categories maintainers} {
+        if {![info exists $variable]} {
+            set pkg_$variable ""
+        } else {
+            set pkg_$variable [set $variable]
+        }
+    }
+    set category   [lindex [split $categories " "] 0]
+    set maintainer $maintainers
+
+    set dependencies {}
+    # get deplist
+    set deps [make_dependency_list $portname]
+    set deps [lsort -unique $deps]
+    foreach dep $deps {
+        set name [lindex [split $dep /] 0]
+        set vers [lindex [split $dep /] 1]
+        # don't re-package ourself
+        if {$name != $portname} {
+            lappend dependencies "${name} >= ${vers}"
+        }
+    }
+
+	# depend on system (virtual packages for apple stuff)
+	lappend dependencies "org.macports.${os.platform}${os.major}"
+
+    set listpath ${workpath}/${portname}.filelist
+    system "rm -f '${workpath}/${portname}.filelist' && touch '${workpath}/${portname}.filelist'"
+    #system "cd '${destpath}' && find . -type d | grep -v -E '^.$' | sed -e 's/\"/\\\"/g' -e 's/^./%dir \"/' -e 's/$/\"/' > '${workpath}/${portname}.filelist'"
+    system "cd '${destpath}' && find . ! -type d | grep -v /etc/ | sed -e 's/\"/\\\"/g' -e 's/^./\"/' -e 's/$/\"/' >> '${workpath}/${portname}.filelist'"
+    system "cd '${destpath}' && find . ! -type d | grep /etc/ | sed -e 's/\"/\\\"/g' -e 's/^./%config \"/' -e 's/$/\"/' >> '${workpath}/${portname}.filelist'"
+    write_spec ${specpath} ${destpath} ${listpath} $portname $portversion $portrevision $pkg_description $pkg_long_description $pkg_homepage $category $license $maintainer $dependencies $epoch
+    system "MP_USERECEIPTS='${portdbpath}/receipts' rpmbuild -bb -v ${rpmbuildarch} ${rpmdestpath} ${specpath}"
+
+    return 0
+}
+
+proc portrpm::make_dependency_list {portname} {
+    set result {}
+    if {[catch {set res [mport_lookup $portname]} error]} {
+		global errorInfo
+		ui_debug "$errorInfo"
+        ui_error "port lookup failed: $error"
+        return 1
+    }
+    foreach {name array} $res {
+        array set portinfo $array
+
+        if {[info exists portinfo(depends_run)] || [info exists portinfo(depends_lib)]} {
+            # get the union of depends_run and depends_lib
+            # xxx: only examines the portfile component of the depspec
+            set depends {}
+            if {[info exists portinfo(depends_run)]} { eval "lappend depends $portinfo(depends_run)" }
+            if {[info exists portinfo(depends_lib)]} { eval "lappend depends $portinfo(depends_lib)" }
+
+            foreach depspec $depends {
+                set dep [lindex [split $depspec :] end]
+
+                # xxx: nasty hack
+                if {$dep != "XFree86"} {
+                    eval "lappend result [make_dependency_list $dep]"
+                }
+            }
+        }
+        lappend result $portinfo(name)/$portinfo(version)
+        unset portinfo
+    }
+    ui_debug "dependencies for ${portname}: $result"
+    return $result
+}
+
+proc portrpm::word_wrap {orig Length} {
+    set pos 0
+    set line ""
+    set text ""
+
+    set words [split $orig]
+    set numWords [llength $words]
+    for {set cnt 0} {$cnt < $numWords} {incr cnt} {
+	set w [lindex $words $cnt]
+	set wLen [string length $w]
+
+	if {($pos+$wLen < $Length)} {
+	    # append word to current line
+	    if {$pos} {append line " "; incr pos}
+	    append line $w
+	    incr pos $wLen
+	} else {
+	    # line full => write buffer and  begin a new line
+	    if {[string length $text]} {append text "\n"}
+	    append text $line
+	    set line $w
+	    set pos $wLen
+	}
+    }
+
+    if {[string length $text]} {append text "\n"}
+    if {[string length $line]} {append text $line}
+    return $text
+}
+
+proc portrpm::write_spec {specfile destroot filelist portname portversion portrevision description long_description homepage category license maintainer dependencies epoch} {
+    set specfd [open ${specfile} w+]
+    set origportname ${portname}
+    regsub -all -- "\-" $portversion "_" portversion
+    regsub -all -- "\-" $portname "_" portname
+    puts $specfd "\#Spec file generated by MacPorts
+%define distribution MacPorts
+%define vendor MacPorts
+%define packager ${maintainer}
+
+%define buildroot ${destroot}
+# Avoid cleaning BuildRoot in the pre-install:
+%define __spec_install_pre     %{___build_pre}
+%define __spec_clean_body      %{nil}
+
+Summary: ${description}
+Name: ${portname}
+Version: ${portversion}
+Release: ${portrevision}
+Group: ${category}
+License: ${license}
+URL: ${homepage}
+BuildRoot: ${destroot}
+AutoReq: no"
+    if {$epoch != 0} {
+	    puts $specfd "Epoch: ${epoch}"
+    }
+    if {[llength ${dependencies}] != 0} {
+	foreach require ${dependencies} {
+	    puts $specfd "Requires: [regsub -all -- "\-" $require "_"]"
+	}
+    }
+    set wrap_description [word_wrap ${long_description} 72]
+    puts $specfd "
+%description
+$wrap_description
+
+%prep
+%build
+%install
+%clean
+
+%files -f ${filelist}"
+    close $specfd
+}
diff --git a/src/package1.0/portsrpm.tcl b/src/package1.0/portsrpm.tcl
new file mode 100644
index 000000000..5589b2f83
--- /dev/null
+++ b/src/package1.0/portsrpm.tcl
@@ -0,0 +1,293 @@
+# et:ts=4
+# portsrpm.tcl
+# $Id$
+#
+# Copyright (c) 2007, 2009, 2011, 2013 The MacPorts Project
+# Copyright (c) 2002 - 2003 Apple Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. Neither the name of Apple Inc. nor the names of its contributors
+#    may be used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+
+package provide portsrpm 1.0
+package require portutil 1.0
+package require portfetch 1.0
+
+set org.macports.srpm [target_new org.macports.srpm portsrpm::srpm_main]
+target_runtype ${org.macports.srpm} always
+target_provides ${org.macports.srpm} srpm
+target_requires ${org.macports.srpm} checksum
+
+namespace eval portsrpm {
+}
+
+options package.destpath
+
+# Set up defaults
+default srpm.asroot yes
+
+set_ui_prefix
+
+proc portsrpm::srpm_main {args} {
+    global subport version revision UI_PREFIX
+
+    ui_msg "$UI_PREFIX [format [msgcat::mc "Creating SRPM package for %s-%s"] ${subport} ${version}]"
+
+    return [srpm_pkg $subport $version $revision]
+}
+
+proc portsrpm::srpm_pkg {portname portversion portrevision} {
+    global UI_PREFIX package.destpath portdbpath destpath workpath distpath \
+           prefix categories maintainers description long_description \
+           homepage epoch portpath distfiles os.platform os.arch os.version \
+           os.major
+
+    set fetch_urls {}
+    portfetch::checkfiles fetch_urls
+
+    set rpmdestpath ""
+    if {![string equal ${package.destpath} ${workpath}] && ![string equal ${package.destpath} ""]} {
+        set pkgpath ${package.destpath}
+        file mkdir ${pkgpath}/BUILD \
+                   ${pkgpath}/RPMS \
+                   ${pkgpath}/SOURCES \
+                   ${pkgpath}/SPECS \
+                   ${pkgpath}/SRPMS
+        set rpmdestpath "--define '_topdir ${pkgpath}'"
+    }
+
+    foreach dir [list "${prefix}/src/macports/SRPMS" "${prefix}/src/apple/SRPMS" "/usr/src/apple/SRPMS" "/macports/rpms/SRPMS"] {
+        foreach arch {"src" "nosrc"} {
+            set rpmpath "$dir/${portname}-${portversion}-${portrevision}.${arch}.rpm"
+	    if {[file readable $rpmpath] && ([file mtime ${rpmpath}] >= [file mtime ${portpath}/Portfile])} {
+                ui_debug "$rpmpath"
+                ui_msg "$UI_PREFIX [format [msgcat::mc "SRPM package for %s version %s is up-to-date"] ${portname} ${portversion}]"
+                return 0
+            }
+        }
+    }
+
+    set specpath ${workpath}/${portname}-port.spec
+    # long_description, description, or homepage may not exist
+    foreach variable {long_description description homepage categories maintainers} {
+        if {![info exists $variable]} {
+            set pkg_$variable ""
+        } else {
+            set pkg_$variable [set $variable]
+        }
+    }
+    set category   [lindex [split $categories " "] 0]
+    set license    "Unknown"
+    set maintainer $maintainers
+
+    set dependencies {}
+    # get deplist
+    set deps [make_dependency_list $portname]
+    set deps [lsort -unique $deps]
+    foreach dep $deps {
+        set name [lindex [split $dep /] 0]
+        set vers [lindex [split $dep /] 1]
+        # don't re-package ourself
+        if {$name != $portname} {
+            lappend dependencies "${name} >= ${vers}"
+        }
+    }
+
+    # true = .src.rpm (with distfiles), false = .nosrc.rpm (without distfiles)
+    set src false
+
+    #set sourcespath ${prefix}/src/macports/SOURCES
+    set sourcespath "`rpm --eval %{_sourcedir}`"
+
+    system "cp -p ${portpath}/Portfile ${sourcespath}/$portname-Portfile"
+    if {[info exists ${portpath}/files]} {
+        system "cd ${portpath} && zip -r -q ${sourcespath}/$portname-files.zip files -x \\*.DS_Store -x files/.svn\\*"
+        set zip $portname-files.zip
+    } else {
+        set zip ""
+    }
+    foreach dist $distfiles {
+        system "cp -p ${distpath}/${dist} ${sourcespath}/${dist}"
+    }
+
+    write_port_spec ${specpath} $portname $portversion $portrevision $pkg_description $pkg_long_description $pkg_homepage $category $license $maintainer $distfiles $fetch_urls $dependencies $epoch $src $zip
+    system "rpmbuild -bs -v --nodeps ${rpmdestpath} ${specpath}"
+
+    return 0
+}
+
+proc portsrpm::make_dependency_list {portname} {
+    set result {}
+    if {[catch {set res [mport_lookup $portname]} error]} {
+		global errorInfo
+		ui_debug "$errorInfo"
+        ui_error "port lookup failed: $error"
+        return 1
+    }
+    foreach {name array} $res {
+        array set portinfo $array
+
+        if {[info exists portinfo(depends_fetch)] || [info exists portinfo(depends_extract)]
+            || [info exists portinfo(depends_build)] || [info exists portinfo(depends_lib)]} {
+            # get the union of depends_fetch, depends_extract, depends_build and depends_lib
+            # xxx: only examines the portfile component of the depspec
+            set depends {}
+            if {[info exists portinfo(depends_fetch)]} { eval "lappend depends $portinfo(depends_fetch)" }
+            if {[info exists portinfo(depends_extract)]} { eval "lappend depends $portinfo(depends_extract)" }
+            if {[info exists portinfo(depends_build)]} { eval "lappend depends $portinfo(depends_build)" }
+            if {[info exists portinfo(depends_lib)]} { eval "lappend depends $portinfo(depends_lib)" }
+
+            foreach depspec $depends {
+                set dep [lindex [split $depspec :] end]
+
+                # xxx: nasty hack
+                if {$dep != "XFree86"} {
+                    eval "lappend result [make_dependency_list $dep]"
+                }
+            }
+        }
+        lappend result $portinfo(name)/$portinfo(version)
+        unset portinfo
+    }
+    ui_debug "dependencies for ${portname}: $result"
+    return $result
+}
+
+proc portsrpm::word_wrap {orig Length} {
+    set pos 0
+    set line ""
+    set text ""
+
+    set words [split $orig]
+    set numWords [llength $words]
+    for {set cnt 0} {$cnt < $numWords} {incr cnt} {
+	set w [lindex $words $cnt]
+	set wLen [string length $w]
+
+	if {($pos+$wLen < $Length)} {
+	    # append word to current line
+	    if {$pos} {append line " "; incr pos}
+	    append line $w
+	    incr pos $wLen
+	} else {
+	    # line full => write buffer and  begin a new line
+	    if {[string length $text]} {append text "\n"}
+	    append text $line
+	    set line $w
+	    set pos $wLen
+	}
+    }
+
+    if {[string length $text]} {append text "\n"}
+    if {[string length $line]} {append text $line}
+    return $text
+}
+
+proc portsrpm::write_port_spec {specfile portname portversion portrevision description long_description homepage category license maintainer distfiles fetch_urls dependencies epoch src zip} {
+    set specfd [open ${specfile} w+]
+    set origportname ${portname}
+    regsub -all -- "\-" $portversion "_" portversion
+    regsub -all -- "\-" $portname "_" portname
+    puts $specfd "\#Spec file generated by MacPorts
+%define distribution MacPorts
+%define vendor MacPorts
+%define packager ${maintainer}
+
+Summary: ${description}
+Name: ${portname}
+Version: ${portversion}
+Release: ${portrevision}
+Group: ${category}
+License: ${license}
+URL: ${homepage}
+BuildRoot: %{_tmppath}/%{name}-%{version}-root
+Source0: ${portname}-Portfile"
+    if {$zip ne ""} {
+        puts $specfd "Source1: $zip"
+    }
+    if {$epoch != 0} {
+	    puts $specfd "Epoch: ${epoch}"
+    }
+    set first 2
+    set count $first
+    puts $specfd "#distfiles"
+    foreach file ${distfiles} {
+
+        puts -nonewline $specfd "Source${count}: "
+        if {![info exists $fetch_urls]} {
+        foreach {url_var distfile}  ${fetch_urls} {
+            if {$distfile eq $file} {
+                 global portfetch::$url_var master_sites
+                 set site [lindex [set $url_var] 0]
+                 set file [portfetch::assemble_url $site $distfile]
+                 break
+            }
+        }
+        }
+        puts $specfd $file
+        if (!$src) {
+            puts $specfd "NoSource: $count"
+        }
+        incr count
+    }
+    puts $specfd "AutoReq: no"
+    if {[llength ${dependencies}] != 0} {
+	foreach require ${dependencies} {
+	    puts $specfd "BuildRequires: [regsub -all -- "\-" $require "_"]"
+	}
+    }
+    set wrap_description [word_wrap ${long_description} 72]
+    if {$zip ne ""} {
+        set and "-a 1"
+    } else {
+        set and ""
+    }
+    puts $specfd "
+%description
+$wrap_description
+
+%prep
+%setup -c $and -T
+cp -p %{SOURCE0} Portfile
+#prepare work area
+port fetch
+port checksum
+port extract
+port patch
+
+%build
+port configure
+port build
+
+%install
+rm -rf \$RPM_BUILD_ROOT
+mkdir -p \$RPM_BUILD_ROOT
+port destroot
+port rpm
+
+%clean
+port clean"
+    close $specfd
+}
diff --git a/src/port/port.tcl b/src/port/port.tcl
old mode 100755
new mode 100644
index b5bb55f3d..ae04f161e
--- a/src/port/port.tcl
+++ b/src/port/port.tcl
@@ -4076,6 +4076,9 @@ set action_array [dict create \
     mdmg        [list action_target         [ACTION_ARGS_PORTS]] \
     mpkg        [list action_target         [ACTION_ARGS_PORTS]] \
     pkg         [list action_target         [ACTION_ARGS_PORTS]] \
+    dpkg        [list action_target         [ACTION_ARGS_PORTS]] \
+    rpm         [list action_target         [ACTION_ARGS_PORTS]] \
+    srpm        [list action_target         [ACTION_ARGS_PORTS]] \
     \
     snapshot    [list action_snapshot       [ACTION_ARGS_STRINGS]] \
     restore     [list action_restore        [ACTION_ARGS_STRINGS]] \
@@ -4178,6 +4181,7 @@ set cmd_opts_array [dict create {*}{
     snapshot    {create list {diff 1} all {delete 1} help {note 1}}
     restore     {{snapshot-id 1} last}
     migrate     {continue}
+    dpkg        {no-deps}
 }]
 
 ##
diff --git a/src/port1.0/portsandbox.tcl b/src/port1.0/portsandbox.tcl
index cff38a6d9..5da6c487e 100644
--- a/src/port1.0/portsandbox.tcl
+++ b/src/port1.0/portsandbox.tcl
@@ -30,6 +30,7 @@
 package provide portsandbox 1.0
 package require porttrace 1.0
 package require portutil 1.0
+package require portrpm 1.0
 
 namespace eval portsandbox {
 }
@@ -76,6 +77,10 @@ proc portsandbox::set_profile {target} {
                 set allow_dirs [list ${package.destpath}]
             }
         }
+        rpm -
+        srpm {
+            set allow_dirs [list ${rpm.srcdir} ${rpm.tmpdir}]
+        }
     }
 
     lappend allow_dirs $workpath ${portutil::autoconf::trace_sipworkaround_path}
diff --git a/src/port1.0/portutil.tcl b/src/port1.0/portutil.tcl
index 35c0b8c75..ff4f41ee0 100644
--- a/src/port1.0/portutil.tcl
+++ b/src/port1.0/portutil.tcl
@@ -1487,6 +1487,9 @@ proc target_run {ditem} {
                         pkg         -
                         portpkg     -
                         mpkg        -
+                        rpm         -
+                        srpm        -
+                        dpkg        -
                         mdmg        -
                         ""          { set deptypes [list depends_fetch depends_extract depends_patch depends_lib depends_build depends_run] }
 
