#!/usr/bin/env port-tclsh
# -*- coding: utf-8; mode: tcl; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- vim:fenc=utf-8:ft=tcl:et:sw=4:ts=4:sts=4

# This PortGroup is included automatically by the customised MacPorts/LinuxPorts "base"
# layer from the MacStrop repo, after Portfiles are parsed. It scans the depends_build
# and depends_lib dependency lists for ports that are known to have a "devport" subport.
# It then makes certain that these devports are declared in the build dependencies.

namespace eval devport_helper {
    # our directory:
    #set thisfile [dict get [info frame 0] file]
    set thisfile [info script]
    variable currentportgroupdir [file dirname ${thisfile}]
    set useportgroup 0
    set updatedb 0
    if {[info exists ::argv]} {
        set asscript 1
        proc ui_info {msg} {
            puts stderr ${msg}
        }
        set ui_debug ui_info
        set ui_error ui_info
    } else {
        set asscript 0
        # We'd like to check if the current port has any dependencies at all to
        # avoid searching for devports when we can. But dependency declaration in
        # variants may not have been done so we always generate the DB and we
        # always install the callback.
        set useportgroup 1
        if {!([file exists ${currentportgroupdir}/devport_db.tcl]
                && [file mtime ${thisfile}] <= [file mtime ${currentportgroupdir}/devport_db.tcl])} {
            set updatedb 1
        }
    }

    proc generate_db {} {
        ui_info "Generating the devport database in ${devport_helper::currentportgroupdir}"
        # use the port driver to find all ports called ${name}-dev
        set devports [exec port -q info --index --line --name "*-dev"]
        # generate a database (array) that maps the main port name to its corresponding devport
        if {![catch {set fp [open ${devport_helper::currentportgroupdir}/devport_db.tcl "w"]} err]} {
            puts ${fp} "array unset devportDB"
            puts ${fp} "array set devportDB \[list \\"
            foreach dp ${devports} {
                # the mainport name is the devport name minus the "-dev" suffix
                # (because the devport name is generated by appending "-dev" to the mainport's name...)
                puts ${fp} "  [string range ${dp} 0 [string last "-dev" ${dp}]-1]\t${dp} \\"
            }
            puts ${fp} "\]"
            close ${fp}
        } else {
            ${devport_helper::ui_error} "Error writing ${currentportgroupdir}/devport_db.tcl: $err"
            return -code error "Error writing devport database ${currentportgroupdir}/devport_db.tcl"
        }
    }

    # check if we're invoked as a standalone script, or if the devport database hasn't been created yet:
    if {${asscript} || ${updatedb}} {
        generate_db
    }
    # this PortGroup is included through "base" *after* the Portfile has been parsed, but the callbacks
    # from any other PGs will be executed after we've been read. So, we need to use a callback too in
    # order to scan the best possibly definitive depends_lib and depends_build lists.
    proc callback {} {
        global depends_lib depends_build conflicts_build conflicts_configure
        if {${devport_helper::useportgroup}} { ## this is where we do the actual PortGroup work:
            ui_debug "Looking for ${devport_helper::currentportgroupdir}/devport_db.tcl"
            if {![catch {source "${devport_helper::currentportgroupdir}/devport_db.tcl"} err] && [info exists devportDB]} {
                # scan the depends_build and depends_lib lists for ports that have devports
                if {![info exists depends_build]} {
                    depends_build
                }
                if {![info exists depends_lib]} {
                    depends_lib
                }
                foreach d [list {*}${depends_build} {*}${depends_lib}] {
                    set dep [lindex [split ${d} ":"] end]
                    if {[info exists devportDB(${dep})]} {
                        set devdep $devportDB(${dep})
                        # found one, let's see if the devport is already declared in depends_build:
                        if {[lsearch -regexp ${depends_build} "\[^ \]*:${devdep}"] < 0} {
                            set blisted -1
                            if {[info exists conflicts_build]} {
                                set blisted [lsearch ${conflicts_build} "${devdep}"]
                            }
                            if {${blisted} < 0 && [info exists conflicts_configure]} {
                                set blisted [lsearch ${conflicts_configure} "${devdep}"]
                            }
                            if {${blisted} < 0} {
                                ui_debug "port:${devdep} is missing from the build dependencies; adding it"
                                depends_build-append "port:${devdep}"
                                if {[catch {registry_active ${devdep}}]} {
                                    # it'd be nice if there were a conditional way to use ui_warn here
                                    # where it prints before asking the used to install a dependency
                                    # that may simply have been deactivate (= is installed).
                                    # With my patched "base" the ui_info routine is an acceptable workaround.
                                    ui_info "WARNING: port:${devdep} not installed or not activated."
                                }
                            } else {
                                ui_debug "port:${devdep} is listed as a configure or build conflict; NOT adding it"
                            }
                        }
                    }
                }
                ui_debug "Parsed ${devport_helper::currentportgroupdir}/devport_db.tcl"
            } else {
                ui_error "Error reading ${devport_helper::currentportgroupdir}/devport_db.tcl: $err"
                return -code error "Error reading devport database ${devport_helper::currentportgroupdir}/devport_db.tcl"
            }
        }
    }
}
if {${devport_helper::useportgroup}} {
    port::register_callback devport_helper::callback
}

