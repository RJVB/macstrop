diff --git a/qtbase/src/corelib/tools/qdatetime.h b/qtbase/src/corelib/tools/qdatetime.h
index 2518dc73014f815cbe9e6b36c3e96bc10413b238..3d69264023bb61d20f25e8498321a1f2ca3395d8 100644
--- a/qtbase/src/corelib/tools/qdatetime.h
+++ b/qtbase/src/corelib/tools/qdatetime.h
@@ -55,6 +55,7 @@ Q_FORWARD_DECLARE_OBJC_CLASS(NSDate);
 QT_BEGIN_NAMESPACE
 
 class QTimeZone;
+class QStringView;
 
 class Q_CORE_EXPORT QDate
 {
@@ -127,6 +128,9 @@ QT_DEPRECATED inline bool setYMD(int y, int m, int d)
     { return jd_ >= minJd() && jd_ <= maxJd() ? QDate(jd_) : QDate() ; }
     Q_DECL_CONSTEXPR inline qint64 toJulianDay() const { return jd; }
 
+    // RJVB backported QStringView from 5.10
+    QString toString(QStringView format) const;
+
 private:
     // using extra parentheses around min to avoid expanding it if it is a macro
     static Q_DECL_CONSTEXPR inline qint64 nullJd() { return (std::numeric_limits<qint64>::min)(); }
@@ -191,6 +195,10 @@ public:
     void start();
     int restart();
     int elapsed() const;
+
+    // RJVB backported QStringView from 5.10
+    QString toString(QStringView format) const;
+
 private:
     enum TimeFlag { NullTime = -1 };
     Q_DECL_CONSTEXPR inline int ds() const { return mds == -1 ? 0 : mds; }
@@ -363,6 +371,9 @@ public:
     NSDate *toNSDate() const Q_DECL_NS_RETURNS_AUTORELEASED;
 #endif
 
+    // RJVB backported QStringView from 5.10
+    QString toString(QStringView format) const;
+
 private:
     friend class QDateTimePrivate;
 
diff --git a/qtbase/src/corelib/tools/qstring.h b/qtbase/src/corelib/tools/qstring.h
index 8f957a7b22bb6ffeabb90370b769eff552a084f6..898b69e2c2e37da97248c51310bdf1ee84d87734 100644
--- a/qtbase/src/corelib/tools/qstring.h
+++ b/qtbase/src/corelib/tools/qstring.h
@@ -83,6 +83,8 @@ class QString;
 class QStringList;
 class QTextCodec;
 class QStringRef;
+class QStringView;
+
 template <typename T> class QVector;
 
 class QLatin1String
@@ -132,6 +138,17 @@ public:
     inline QT_ASCII_CAST_WARN bool operator>=(const QByteArray &s) const;
 #endif // !defined(QT_NO_CAST_FROM_ASCII) && !defined(QT_RESTRICTED_CAST_FROM_ASCII)
 
+    // RJVB backported QStringView from Qt 5.10
+    Q_REQUIRED_RESULT bool startsWith(QStringView s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW;
+    Q_REQUIRED_RESULT bool startsWith(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW;
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR bool startsWith(QChar c) const Q_DECL_NOTHROW;
+    Q_REQUIRED_RESULT inline bool startsWith(QChar c, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW;
+
+    Q_REQUIRED_RESULT bool endsWith(QStringView s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW;
+    Q_REQUIRED_RESULT bool endsWith(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW;
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR bool endsWith(QChar c) const Q_DECL_NOTHROW;
+    Q_REQUIRED_RESULT inline bool endsWith(QChar c, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW;
+
 private:
     int m_size;
     const char *m_data;
@@ -875,6 +898,12 @@ private:
 public:
     typedef Data * DataPtr;
     inline DataPtr &data_ptr() { return d; }
+
+    // RJVB backported QStringView from 5.10
+    Q_REQUIRED_RESULT QString arg(QStringView a, int fieldWidth = 0,
+                QChar fillChar = QLatin1Char(' ')) const;
+    Q_REQUIRED_RESULT bool startsWith(QStringView s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW;
+    Q_REQUIRED_RESULT bool endsWith(QStringView s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW;
 };
 
 inline QString::QString(QLatin1String aLatin1) : d(fromLatin1_helper(aLatin1.latin1(), aLatin1.size()))
@@ -1537,6 +1569,10 @@ public:
     qulonglong toULongLong(bool *ok = Q_NULLPTR, int base = 10) const;
     float toFloat(bool *ok = Q_NULLPTR) const;
     double toDouble(bool *ok = Q_NULLPTR) const;
+
+    // RJVB backported QStringView from 5.10
+    Q_REQUIRED_RESULT bool startsWith(QStringView s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW;
+    Q_REQUIRED_RESULT bool endsWith(QStringView s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW;
 };
 Q_DECLARE_TYPEINFO(QStringRef, Q_PRIMITIVE_TYPE);
 
diff --git a/qtbase/src/corelib/tools/qstringalgorithms.h b/qtbase/src/corelib/tools/qstringalgorithms.h
new file mode 100644
index 0000000000000000000000000000000000000000..aaa702301ed49db6a1c9a2edbad227a2f57acaa7
--- /dev/null
+++ b/qtbase/src/corelib/tools/qstringalgorithms.h
@@ -0,0 +1,88 @@
+/****************************************************************************
+**
+** Copyright (C) 2017 Klar√§lvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Marc Mutz <marc.mutz@kdab.com>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QSTRINGALGORITHMS_H
+#define QSTRINGALGORITHMS_H
+
+#include <QtCore/qnamespace.h>
+
+#if 0
+#pragma qt_class(QStringAlgorithms)
+#endif
+
+QT_BEGIN_NAMESPACE
+
+class QByteArray;
+class QLatin1String;
+class QStringView;
+template <typename T> class QVector;
+
+namespace QtPrivate {
+
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION qsizetype qustrlen(const ushort *str) Q_DECL_NOTHROW;
+
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION int compareStrings(QStringView   lhs, QStringView   rhs, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION int compareStrings(QStringView   lhs, QLatin1String rhs, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION int compareStrings(QLatin1String lhs, QStringView   rhs, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION int compareStrings(QLatin1String lhs, QLatin1String rhs, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+
+
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool startsWith(QStringView   haystack, QStringView   needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool startsWith(QStringView   haystack, QLatin1String needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool startsWith(QLatin1String haystack, QStringView   needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool startsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool endsWith(QStringView   haystack, QStringView   needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool endsWith(QStringView   haystack, QLatin1String needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool endsWith(QLatin1String haystack, QStringView   needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool endsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION QStringView   trimmed(QStringView   s) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION QLatin1String trimmed(QLatin1String s) Q_DECL_NOTHROW;
+
+Q_REQUIRED_RESULT Q_CORE_EXPORT QByteArray convertToLatin1(QStringView str);
+Q_REQUIRED_RESULT Q_CORE_EXPORT QByteArray convertToUtf8(QStringView str);
+Q_REQUIRED_RESULT Q_CORE_EXPORT QByteArray convertToLocal8Bit(QStringView str);
+Q_REQUIRED_RESULT Q_CORE_EXPORT QVector<uint> convertToUcs4(QStringView str);
+
+} // namespace QtPRivate
+
+QT_END_NAMESPACE
+
+#endif // QSTRINGALGORTIHMS_H
diff --git a/qtbase/src/corelib/tools/qstringiterator_p.h b/qtbase/src/corelib/tools/qstringiterator_p.h
index 7cf59ae42fe4d1093ab0f5a2919b69b9a3ea62a6..b5e5274b48dc03d72143a26d192342f8accf9165 100644
--- a/qtbase/src/corelib/tools/qstringiterator_p.h
+++ b/qtbase/src/corelib/tools/qstringiterator_p.h
@@ -57,11 +57,16 @@
 
 QT_BEGIN_NAMESPACE
 
+class QStringView;
+
 class QStringIterator
 {
     QString::const_iterator i, pos, e;
 
 public:
+    // RJVB backported from 5.10
+    explicit QStringIterator(QStringView string, qsizetype idx = 0);
+
     inline explicit QStringIterator(const QString &string)
         : i(string.constBegin()),
           pos(string.constBegin()),
diff --git a/qtbase/src/corelib/tools/qstringliteral.h b/qtbase/src/corelib/tools/qstringliteral.h
new file mode 100644
index 0000000000000000000000000000000000000000..6a1a74a80e61222fad9bcdcc65f85308bc26fd32
--- /dev/null
+++ b/qtbase/src/corelib/tools/qstringliteral.h
@@ -0,0 +1,128 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Copyright (C) 2016 Intel Corporation.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QSTRINGLITERAL_H
+#define QSTRINGLITERAL_H
+
+#include <QtCore/qarraydata.h>
+
+#if 0
+#pragma qt_class(QStringLiteral)
+#endif
+
+QT_BEGIN_NAMESPACE
+
+typedef QTypedArrayData<ushort> QStringData;
+
+#if defined(Q_OS_WIN) && !defined(Q_COMPILER_UNICODE_STRINGS)
+// fall back to wchar_t if the a Windows compiler does not
+// support Unicode string literals, assuming wchar_t is 2 bytes
+// on that platform (sanity-checked by static_assert further below)
+
+#if defined(Q_CC_MSVC)
+#    define QT_UNICODE_LITERAL_II(str) L##str
+#else
+#    define QT_UNICODE_LITERAL_II(str) L"" str
+#endif
+typedef wchar_t qunicodechar;
+
+#else
+// all our supported compilers support Unicode string literals,
+// even if their Q_COMPILER_UNICODE_STRING has been revoked due
+// to lacking stdlib support. But QStringLiteral only needs the
+// core language feature, so just use u"" here unconditionally:
+
+#define QT_UNICODE_LITERAL_II(str) u"" str
+typedef char16_t qunicodechar;
+
+#endif
+
+Q_STATIC_ASSERT_X(sizeof(qunicodechar) == 2,
+        "qunicodechar must typedef an integral type of size 2");
+
+#define QT_UNICODE_LITERAL(str) QT_UNICODE_LITERAL_II(str)
+#define QStringLiteral(str) \
+    ([]() Q_DECL_NOEXCEPT -> QString { \
+        enum { Size = sizeof(QT_UNICODE_LITERAL(str))/2 - 1 }; \
+        static const QStaticStringData<Size> qstring_literal = { \
+            Q_STATIC_STRING_DATA_HEADER_INITIALIZER(Size), \
+            QT_UNICODE_LITERAL(str) }; \
+        QStringDataPtr holder = { qstring_literal.data_ptr() }; \
+        const QString qstring_literal_temp(holder); \
+        return qstring_literal_temp; \
+    }()) \
+    /**/
+
+#define Q_STATIC_STRING_DATA_HEADER_INITIALIZER_WITH_OFFSET(size, offset) \
+    { Q_REFCOUNT_INITIALIZE_STATIC, size, 0, 0, offset } \
+    /**/
+
+#define Q_STATIC_STRING_DATA_HEADER_INITIALIZER(size) \
+    Q_STATIC_STRING_DATA_HEADER_INITIALIZER_WITH_OFFSET(size, sizeof(QStringData)) \
+    /**/
+
+#ifndef QT_NO_UNICODE_LITERAL
+# ifndef QT_UNICODE_LITERAL
+#  error "If you change QStringLiteral, please change QStringViewLiteral, too"
+# endif
+# define QStringViewLiteral(str) QStringView(QT_UNICODE_LITERAL(str))
+#endif
+
+template <int N>
+struct QStaticStringData
+{
+    QArrayData str;
+    qunicodechar data[N + 1];
+
+    QStringData *data_ptr() const
+    {
+        Q_ASSERT(str.ref.isStatic());
+        return const_cast<QStringData *>(static_cast<const QStringData*>(&str));
+    }
+};
+
+struct QStringDataPtr
+{
+    QStringData *ptr;
+};
+
+QT_END_NAMESPACE
+
+#endif // QSTRINGLITERAL_H
diff --git a/qtbase/src/corelib/tools/qstringview.cpp b/qtbase/src/corelib/tools/qstringview.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..7e7a23209194549d104b0fe671d42163071b68b5
--- /dev/null
+++ b/qtbase/src/corelib/tools/qstringview.cpp
@@ -0,0 +1,1690 @@
+/****************************************************************************
+**
+** Copyright (C) 2017 Klar√§lvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Marc Mutz <marc.mutz@kdab.com>
+** Contact: http://www.qt.io/licensing/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qstringview.h"
+#include "qstringalgorithms_p.h"
+#include "qstringiterator_p.h"
+#include "qsimd_p.h"
+#include "qendian.h"
+#include "qunicodetables_p.h"
+#ifndef QT_NO_TEXTCODEC
+#include <qtextcodec.h>
+#endif
+#include <private/qutfcodec_p.h>
+#include <qvector.h>
+#include <qdatetime.h>
+
+QT_BEGIN_NAMESPACE
+
+// from qunicodetables.cpp@5.10 :
+extern const unsigned short *uc_property_trie_array(), *specialCaseMap_array();
+static const unsigned short *uc_property_trie = uc_property_trie_array();
+static const unsigned short *specialCaseMap = specialCaseMap_array();
+
+#define GET_PROP_INDEX(ucs4) \
+       (ucs4 < 0x11000 \
+        ? (uc_property_trie[uc_property_trie[ucs4>>5] + (ucs4 & 0x1f)]) \
+        : (uc_property_trie[uc_property_trie[((ucs4 - 0x11000)>>8) + 0x880] + (ucs4 & 0xff)]))
+
+#define GET_PROP_INDEX_UCS2(ucs2) \
+       (uc_property_trie[uc_property_trie[ucs2>>5] + (ucs2 & 0x1f)])
+
+extern const QUnicodeTables::Properties *uc_properties_array();
+static const QUnicodeTables::Properties *uc_properties = uc_properties_array();
+
+Q_DECL_CONST_FUNCTION static inline const QUnicodeTables::Properties *qGetProp(uint ucs4) Q_DECL_NOTHROW
+{
+    return uc_properties + GET_PROP_INDEX(ucs4);
+}
+
+// from qchar.cpp@5.10 :
+template <typename Traits, typename T>
+Q_DECL_CONST_FUNCTION static inline T convertCase_helper(T uc) Q_DECL_NOTHROW
+{
+    const QUnicodeTables::Properties *prop = qGetProp(uc);
+
+    if (Q_UNLIKELY(Traits::caseSpecial(prop))) {
+        const ushort *specialCase = specialCaseMap + Traits::caseDiff(prop);
+        // so far, there are no special cases beyond BMP (guaranteed by the qunicodetables generator)
+        return *specialCase == 1 ? specialCase[1] : uc;
+    }
+
+    return uc + Traits::caseDiff(prop);
+}
+
+// static inline uint foldCase(const ushort *ch, const ushort *start)
+// {
+//     uint ucs4 = *ch;
+//     if (QChar::isLowSurrogate(ucs4) && ch > start && QChar::isHighSurrogate(*(ch - 1)))
+//         ucs4 = QChar::surrogateToUcs4(*(ch - 1), ucs4);
+//     return convertCase_helper<QUnicodeTables::CasefoldTraits>(ucs4);
+// }
+// 
+static inline uint foldCase(uint ch, uint &last) Q_DECL_NOTHROW
+{
+    uint ucs4 = ch;
+    if (QChar::isLowSurrogate(ucs4) && QChar::isHighSurrogate(last))
+        ucs4 = QChar::surrogateToUcs4(last, ucs4);
+    last = ch;
+    return convertCase_helper<QUnicodeTables::CasefoldTraits>(ucs4);
+}
+
+// static inline ushort foldCase(ushort ch) Q_DECL_NOTHROW
+// {
+//     return convertCase_helper<QUnicodeTables::CasefoldTraits>(ch);
+// }
+// 
+// static inline QChar foldCase(QChar ch) Q_DECL_NOTHROW
+// {
+//     return QChar(foldCase(ch.unicode()));
+// }
+// 
+// from qstring.cpp@5.10 :
+qsizetype QtPrivate::qustrlen(const ushort *str) Q_DECL_NOTHROW
+{
+    qsizetype result = 0;
+
+#ifdef __SSE2__
+    // find the 16-byte alignment immediately prior or equal to str
+    quintptr misalignment = quintptr(str) & 0xf;
+    Q_ASSERT((misalignment & 1) == 0);
+    const ushort *ptr = str - (misalignment / 2);
+
+    // load 16 bytes and see if we have a null
+    // (aligned loads can never segfault)
+    const __m128i zeroes = _mm_setzero_si128();
+    __m128i data = _mm_load_si128(reinterpret_cast<const __m128i *>(ptr));
+    __m128i comparison = _mm_cmpeq_epi16(data, zeroes);
+    quint32 mask = _mm_movemask_epi8(comparison);
+
+    // ignore the result prior to the beginning of str
+    mask >>= misalignment;
+
+    // Have we found something in the first block? Need to handle it now
+    // because of the left shift above.
+    if (mask)
+        return qCountTrailingZeroBits(quint32(mask)) / 2;
+
+    do {
+        ptr += 8;
+        data = _mm_load_si128(reinterpret_cast<const __m128i *>(ptr));
+
+        comparison = _mm_cmpeq_epi16(data, zeroes);
+        mask = _mm_movemask_epi8(comparison);
+    } while (mask == 0);
+
+    // found a null
+    uint idx = qCountTrailingZeroBits(quint32(mask));
+    return ptr - str + idx / 2;
+#endif
+
+    if (sizeof(wchar_t) == sizeof(ushort))
+        return wcslen(reinterpret_cast<const wchar_t *>(str));
+
+    while (*str++)
+        ++result;
+    return result;
+}
+
+// Unicode case-insensitive comparison
+static int ucstricmp(const QChar *a, const QChar *ae, const QChar *b, const QChar *be)
+{
+    if (a == b)
+        return (ae - be);
+    if (a == 0)
+        return be - b;
+    if (b == 0)
+        return a - ae;
+
+    const QChar *e = ae;
+    if (be - b < ae - a)
+        e = a + (be - b);
+
+    uint alast = 0;
+    uint blast = 0;
+    while (a < e) {
+//         qDebug() << hex << alast << blast;
+//         qDebug() << hex << "*a=" << *a << "alast=" << alast << "folded=" << foldCase (*a, alast);
+//         qDebug() << hex << "*b=" << *b << "blast=" << blast << "folded=" << foldCase (*b, blast);
+        int diff = foldCase(a->unicode(), alast) - foldCase(b->unicode(), blast);
+        if ((diff))
+            return diff;
+        ++a;
+        ++b;
+    }
+    if (a == ae) {
+        if (b == be)
+            return 0;
+        return -1;
+    }
+    return 1;
+}
+
+#if defined(__mips_dsp)
+// From qstring_mips_dsp_asm.S
+extern "C" int qt_ucstrncmp_mips_dsp_asm(const ushort *a,
+                                         const ushort *b,
+                                         unsigned len);
+#endif
+
+#if defined(Q_COMPILER_LAMBDA) && !defined(__OPTIMIZE_SIZE__)
+namespace {
+template <uint MaxCount> struct UnrollTailLoop
+{
+    template <typename RetType, typename Functor1, typename Functor2, typename Number>
+    static inline RetType exec(Number count, RetType returnIfExited, Functor1 loopCheck, Functor2 returnIfFailed, Number i = 0)
+    {
+        /* equivalent to:
+         *   while (count--) {
+         *       if (loopCheck(i))
+         *           return returnIfFailed(i);
+         *   }
+         *   return returnIfExited;
+         */
+
+        if (!count)
+            return returnIfExited;
+
+        bool check = loopCheck(i);
+        if (check) {
+            const RetType &retval = returnIfFailed(i);
+            return retval;
+        }
+
+        return UnrollTailLoop<MaxCount - 1>::exec(count - 1, returnIfExited, loopCheck, returnIfFailed, i + 1);
+    }
+
+    template <typename Functor, typename Number>
+    static inline void exec(Number count, Functor code)
+    {
+        /* equivalent to:
+         *   for (Number i = 0; i < count; ++i)
+         *       code(i);
+         */
+        exec(count, 0, [=](Number i) -> bool { code(i); return false; }, [](Number) { return 0; });
+    }
+};
+template <> template <typename RetType, typename Functor1, typename Functor2, typename Number>
+inline RetType UnrollTailLoop<0>::exec(Number, RetType returnIfExited, Functor1, Functor2, Number)
+{
+    return returnIfExited;
+}
+}
+#endif
+
+// Unicode case-sensitive compare two same-sized strings
+static int ucstrncmp(const QChar *a, const QChar *b, size_t l)
+{
+#ifdef __OPTIMIZE_SIZE__
+    const QChar *end = a + l;
+    while (a < end) {
+        if (int diff = (int)a->unicode() - (int)b->unicode())
+            return diff;
+        ++a;
+        ++b;
+    }
+    return 0;
+#else
+#if defined(__mips_dsp)
+    Q_STATIC_ASSERT(sizeof(uint) == sizeof(size_t));
+    if (l >= 8) {
+        return qt_ucstrncmp_mips_dsp_asm(reinterpret_cast<const ushort*>(a),
+                                         reinterpret_cast<const ushort*>(b),
+                                         l);
+    }
+#endif // __mips_dsp
+#ifdef __SSE2__
+    const char *ptr = reinterpret_cast<const char*>(a);
+    qptrdiff distance = reinterpret_cast<const char*>(b) - ptr;
+    a += l & ~7;
+    b += l & ~7;
+    l &= 7;
+
+    // we're going to read ptr[0..15] (16 bytes)
+    for ( ; ptr + 15 < reinterpret_cast<const char *>(a); ptr += 16) {
+        __m128i a_data = _mm_loadu_si128((const __m128i*)ptr);
+        __m128i b_data = _mm_loadu_si128((const __m128i*)(ptr + distance));
+        __m128i result = _mm_cmpeq_epi16(a_data, b_data);
+        uint mask = ~_mm_movemask_epi8(result);
+        if (ushort(mask)) {
+            // found a different byte
+            uint idx = qCountTrailingZeroBits(mask);
+            return reinterpret_cast<const QChar *>(ptr + idx)->unicode()
+                    - reinterpret_cast<const QChar *>(ptr + distance + idx)->unicode();
+        }
+    }
+    const auto lambda = [=](size_t i) -> int {
+        return reinterpret_cast<const QChar *>(ptr)[i].unicode()
+                - reinterpret_cast<const QChar *>(ptr + distance)[i].unicode();
+    };
+    return UnrollTailLoop<7>::exec(l, 0, lambda, lambda);
+#endif
+#if defined(__ARM_NEON__) && defined(Q_PROCESSOR_ARM_64) // vaddv is only available on Aarch64
+    if (l >= 8) {
+        const QChar *end = a + l;
+        const uint16x8_t mask = { 1, 1 << 1, 1 << 2, 1 << 3, 1 << 4, 1 << 5, 1 << 6, 1 << 7 };
+        while (a + 7 < end) {
+            uint16x8_t da = vld1q_u16(reinterpret_cast<const uint16_t *>(a));
+            uint16x8_t db = vld1q_u16(reinterpret_cast<const uint16_t *>(b));
+
+            uint8_t r = ~(uint8_t)vaddvq_u16(vandq_u16(vceqq_u16(da, db), mask));
+            if (r) {
+                // found a different QChar
+                uint idx = qCountTrailingZeroBits(r);
+                return (int)a[idx].unicode() - (int)b[idx].unicode();
+            }
+            a += 8;
+            b += 8;
+        }
+        l &= 7;
+    }
+    const auto lambda = [=](size_t i) -> int {
+        return a[i].unicode() - b[i].unicode();
+    };
+    return UnrollTailLoop<7>::exec(l, 0, lambda, lambda);
+#endif // __ARM_NEON__
+    if (!l)
+        return 0;
+
+    // check alignment
+    if ((reinterpret_cast<quintptr>(a) & 2) == (reinterpret_cast<quintptr>(b) & 2)) {
+        // both addresses have the same alignment
+        if (reinterpret_cast<quintptr>(a) & 2) {
+            // both addresses are not aligned to 4-bytes boundaries
+            // compare the first character
+            if (*a != *b)
+                return a->unicode() - b->unicode();
+            --l;
+            ++a;
+            ++b;
+
+            // now both addresses are 4-bytes aligned
+        }
+
+        // both addresses are 4-bytes aligned
+        // do a fast 32-bit comparison
+        const quint32 *da = reinterpret_cast<const quint32 *>(a);
+        const quint32 *db = reinterpret_cast<const quint32 *>(b);
+        const quint32 *e = da + (l >> 1);
+        for ( ; da != e; ++da, ++db) {
+            if (*da != *db) {
+                a = reinterpret_cast<const QChar *>(da);
+                b = reinterpret_cast<const QChar *>(db);
+                if (*a != *b)
+                    return a->unicode() - b->unicode();
+                return a[1].unicode() - b[1].unicode();
+            }
+        }
+
+        // do we have a tail?
+        a = reinterpret_cast<const QChar *>(da);
+        b = reinterpret_cast<const QChar *>(db);
+        return (l & 1) ? a->unicode() - b->unicode() : 0;
+    } else {
+        // one of the addresses isn't 4-byte aligned but the other is
+        const QChar *e = a + l;
+        for ( ; a != e; ++a, ++b) {
+            if (*a != *b)
+                return a->unicode() - b->unicode();
+        }
+    }
+    return 0;
+#endif
+}
+
+template <typename Number>
+Q_DECL_CONSTEXPR int lencmp(Number lhs, Number rhs) Q_DECL_NOTHROW
+{
+    return lhs == rhs ? 0 :
+           lhs >  rhs ? 1 :
+           /* else */  -1 ;
+}
+
+// Unicode case-sensitive comparison
+static int ucstrcmp(const QChar *a, size_t alen, const QChar *b, size_t blen)
+{
+    if (a == b && alen == blen)
+        return 0;
+    const size_t l = qMin(alen, blen);
+    int cmp = ucstrncmp(a, b, l);
+    return cmp ? cmp : lencmp(alen, blen);
+}
+
+static int qt_compare_strings(QStringView lhs, QStringView rhs, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    if (cs == Qt::CaseSensitive)
+        return ucstrcmp(lhs.begin(), lhs.size(), rhs.begin(), rhs.size());
+    else
+        return ucstricmp(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
+}
+
+static int qt_compare_strings(QStringView lhs, QLatin1String rhs, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    const QString r(rhs);
+    if (cs == Qt::CaseSensitive)
+        return ucstrcmp(lhs.begin(), lhs.size(), r.begin(), r.size());
+    else
+        return ucstricmp(lhs.begin(), lhs.end(), r.begin(), r.end());
+}
+
+static int qt_compare_strings(QLatin1String lhs, QStringView rhs, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    return -qt_compare_strings(rhs, lhs, cs);
+}
+
+static int qt_compare_strings(QLatin1String lhs, QLatin1String rhs, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    if (lhs.size() == 0)
+        return lencmp(0, rhs.size());
+    const auto l = std::min(lhs.size(), rhs.size());
+    int r;
+    if (cs == Qt::CaseSensitive)
+        r = qstrncmp(lhs.data(), rhs.data(), l);
+    else
+        r = qstrnicmp(lhs.data(), rhs.data(), l);
+    return r ? r : lencmp(lhs.size(), rhs.size());
+}
+
+// qstringview.cpp @ 5.10
+/*!
+    \relates QStringView
+    \internal
+    \since 5.10
+
+    Returns an integer that compares to 0 as \a lhs compares to \a rhs.
+
+    If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
+    otherwise the comparison is case-insensitive.
+
+    Case-sensitive comparison is based exclusively on the numeric Unicode values
+    of the characters and is very fast, but is not what a human would expect.
+    Consider sorting user-visible strings with QString::localeAwareCompare().
+*/
+int QtPrivate::compareStrings(QStringView lhs, QStringView rhs, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    return qt_compare_strings(lhs, rhs, cs);
+}
+
+/*!
+    \relates QStringView
+    \internal
+    \since 5.10
+    \overload
+
+    Returns an integer that compares to 0 as \a lhs compares to \a rhs.
+
+    If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
+    otherwise the comparison is case-insensitive.
+
+    Case-sensitive comparison is based exclusively on the numeric Unicode values
+    of the characters and is very fast, but is not what a human would expect.
+    Consider sorting user-visible strings with QString::localeAwareCompare().
+*/
+int QtPrivate::compareStrings(QStringView lhs, QLatin1String rhs, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    return qt_compare_strings(lhs, rhs, cs);
+}
+
+/*!
+    \relates QStringView
+    \internal
+    \since 5.10
+    \overload
+
+    Returns an integer that compares to 0 as \a lhs compares to \a rhs.
+
+    If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
+    otherwise the comparison is case-insensitive.
+
+    Case-sensitive comparison is based exclusively on the numeric Unicode values
+    of the characters and is very fast, but is not what a human would expect.
+    Consider sorting user-visible strings with QString::localeAwareCompare().
+*/
+int QtPrivate::compareStrings(QLatin1String lhs, QStringView rhs, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    return qt_compare_strings(lhs, rhs, cs);
+}
+
+/*!
+    \relates QStringView
+    \internal
+    \since 5.10
+    \overload
+
+    Returns an integer that compares to 0 as \a lhs compares to \a rhs.
+
+    If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
+    otherwise the comparison is case-insensitive.
+
+    Case-sensitive comparison is based exclusively on the numeric Latin-1 values
+    of the characters and is very fast, but is not what a human would expect.
+    Consider sorting user-visible strings with QString::localeAwareCompare().
+*/
+int QtPrivate::compareStrings(QLatin1String lhs, QLatin1String rhs, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    return qt_compare_strings(lhs, rhs, cs);
+}
+
+#if defined(__SSE2__)
+static inline __m128i mergeQuestionMarks(__m128i chunk)
+{
+    const __m128i questionMark = _mm_set1_epi16('?');
+
+# ifdef __SSE4_2__
+    // compare the unsigned shorts for the range 0x0100-0xFFFF
+    // note on the use of _mm_cmpestrm:
+    //  The MSDN documentation online (http://technet.microsoft.com/en-us/library/bb514080.aspx)
+    //  says for range search the following:
+    //    For each character c in a, determine whether b0 <= c <= b1 or b2 <= c <= b3
+    //
+    //  However, all examples on the Internet, including from Intel
+    //  (see http://software.intel.com/en-us/articles/xml-parsing-accelerator-with-intel-streaming-simd-extensions-4-intel-sse4/)
+    //  put the range to be searched first
+    //
+    //  Disassembly and instruction-level debugging with GCC and ICC show
+    //  that they are doing the right thing. Inverting the arguments in the
+    //  instruction does cause a bunch of test failures.
+
+    const __m128i rangeMatch = _mm_cvtsi32_si128(0xffff0100);
+    const __m128i offLimitMask = _mm_cmpestrm(rangeMatch, 2, chunk, 8,
+            _SIDD_UWORD_OPS | _SIDD_CMP_RANGES | _SIDD_UNIT_MASK);
+
+    // replace the non-Latin 1 characters in the chunk with question marks
+    chunk = _mm_blendv_epi8(chunk, questionMark, offLimitMask);
+# else
+    // SSE has no compare instruction for unsigned comparison.
+    // The variables must be shiffted + 0x8000 to be compared
+    const __m128i signedBitOffset = _mm_set1_epi16(short(0x8000));
+    const __m128i thresholdMask = _mm_set1_epi16(short(0xff + 0x8000));
+
+    const __m128i signedChunk = _mm_add_epi16(chunk, signedBitOffset);
+    const __m128i offLimitMask = _mm_cmpgt_epi16(signedChunk, thresholdMask);
+
+#  ifdef __SSE4_1__
+    // replace the non-Latin 1 characters in the chunk with question marks
+    chunk = _mm_blendv_epi8(chunk, questionMark, offLimitMask);
+#  else
+    // offLimitQuestionMark contains '?' for each 16 bits that was off-limit
+    // the 16 bits that were correct contains zeros
+    const __m128i offLimitQuestionMark = _mm_and_si128(offLimitMask, questionMark);
+
+    // correctBytes contains the bytes that were in limit
+    // the 16 bits that were off limits contains zeros
+    const __m128i correctBytes = _mm_andnot_si128(offLimitMask, chunk);
+
+    // merge offLimitQuestionMark and correctBytes to have the result
+    chunk = _mm_or_si128(correctBytes, offLimitQuestionMark);
+#  endif
+# endif
+    return chunk;
+}
+#endif
+
+namespace {
+    template <typename StringView>
+    StringView qt_trimmed(StringView s) Q_DECL_NOTHROW
+    {
+        auto begin = s.begin();
+        auto end = s.end();
+        QStringAlgorithms<const StringView>::trimmed_helper_positions(begin, end);
+        return StringView{begin, end};
+    }
+}
+
+/*!
+    \fn QStringView QtPrivate::trimmed(QStringView s)
+    \fn QLatin1String QtPrivate::trimmed(QLatin1String s)
+    \internal
+    \relates QStringView
+    \since 5.10
+
+    Returns \a s with whitespace removed from the start and the end.
+
+    Whitespace means any character for which QChar::isSpace() returns
+    \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
+    '\\f', '\\r', and ' '.
+
+    \sa QString::trimmed(), QStringView::trimmed(), QLatin1String::trimmed()
+*/
+QStringView QtPrivate::trimmed(QStringView s) Q_DECL_NOTHROW
+{
+    return qt_trimmed(s);
+}
+
+QLatin1String QtPrivate::trimmed(QLatin1String s) Q_DECL_NOTHROW
+{
+    auto res = qt_trimmed(QStringView(QString(s)));
+    return QLatin1String(res.toLatin1());
+}
+
+static void qt_to_latin1(uchar *dst, const ushort *src, int length)
+{
+#if defined(__SSE2__)
+    uchar *e = dst + length;
+    qptrdiff offset = 0;
+
+    // we're going to write to dst[offset..offset+15] (16 bytes)
+    for ( ; dst + offset + 15 < e; offset += 16) {
+        __m128i chunk1 = _mm_loadu_si128((const __m128i*)(src + offset)); // load
+        chunk1 = mergeQuestionMarks(chunk1);
+
+        __m128i chunk2 = _mm_loadu_si128((const __m128i*)(src + offset + 8)); // load
+        chunk2 = mergeQuestionMarks(chunk2);
+
+        // pack the two vector to 16 x 8bits elements
+        const __m128i result = _mm_packus_epi16(chunk1, chunk2);
+        _mm_storeu_si128((__m128i*)(dst + offset), result); // store
+    }
+
+    length = length % 16;
+    dst += offset;
+    src += offset;
+
+#  if defined(Q_COMPILER_LAMBDA) && !defined(__OPTIMIZE_SIZE__)
+    return UnrollTailLoop<15>::exec(length, [=](int i) { dst[i] = (src[i]>0xff) ? '?' : (uchar) src[i]; });
+#  endif
+#elif defined(__ARM_NEON__)
+    // Refer to the documentation of the SSE2 implementation
+    // this use eactly the same method as for SSE except:
+    // 1) neon has unsigned comparison
+    // 2) packing is done to 64 bits (8 x 8bits component).
+    if (length >= 16) {
+        const int chunkCount = length >> 3; // divided by 8
+        const uint16x8_t questionMark = vdupq_n_u16('?'); // set
+        const uint16x8_t thresholdMask = vdupq_n_u16(0xff); // set
+        for (int i = 0; i < chunkCount; ++i) {
+            uint16x8_t chunk = vld1q_u16((uint16_t *)src); // load
+            src += 8;
+
+            const uint16x8_t offLimitMask = vcgtq_u16(chunk, thresholdMask); // chunk > thresholdMask
+            const uint16x8_t offLimitQuestionMark = vandq_u16(offLimitMask, questionMark); // offLimitMask & questionMark
+            const uint16x8_t correctBytes = vbicq_u16(chunk, offLimitMask); // !offLimitMask & chunk
+            chunk = vorrq_u16(correctBytes, offLimitQuestionMark); // correctBytes | offLimitQuestionMark
+            const uint8x8_t result = vmovn_u16(chunk); // narrowing move->packing
+            vst1_u8(dst, result); // store
+            dst += 8;
+        }
+        length = length % 8;
+    }
+#endif
+#if defined(__mips_dsp)
+    qt_toLatin1_mips_dsp_asm(dst, src, length);
+#else
+    while (length--) {
+        *dst++ = (*src>0xff) ? '?' : (uchar) *src;
+        ++src;
+    }
+#endif
+}
+
+static QByteArray qt_convert_to_latin1(QStringView string)
+{
+    if (Q_UNLIKELY(string.isNull()))
+        return QByteArray();
+
+    QByteArray ba(string.length(), Qt::Uninitialized);
+
+    // since we own the only copy, we're going to const_cast the constData;
+    // that avoids an unnecessary call to detach() and expansion code that will never get used
+    qt_to_latin1(reinterpret_cast<uchar *>(const_cast<char *>(ba.constData())),
+                 reinterpret_cast<const ushort *>(string.data()), string.length());
+    return ba;
+}
+
+QByteArray QtPrivate::convertToLatin1(QStringView string)
+{
+    return qt_convert_to_latin1(string);
+}
+
+static QByteArray qt_convert_to_utf8(QStringView str)
+{
+    if (str.isNull())
+        return QByteArray();
+
+    return QUtf8::convertFromUnicode(str.data(), str.length());
+}
+
+/*!
+    \since 5.10
+    \internal
+    \relates QStringView
+
+    Returns a UTF-8 representation of \a string as a QByteArray.
+
+    UTF-8 is a Unicode codec and can represent all characters in a Unicode
+    string like QStringView.
+
+    \sa QString::toUtf8(), QStringView::toUtf8()
+*/
+QByteArray QtPrivate::convertToUtf8(QStringView string)
+{
+    return qt_convert_to_utf8(string);
+}
+
+static QByteArray qt_convert_to_local_8bit(QStringView string)
+{
+    if (string.isNull())
+        return QByteArray();
+#ifndef QT_NO_TEXTCODEC
+    QTextCodec *localeCodec = QTextCodec::codecForLocale();
+    if (localeCodec)
+        return localeCodec->fromUnicode(QString::fromUtf8(string.toUtf8()));
+#endif // QT_NO_TEXTCODEC
+    return qt_convert_to_latin1(string);
+}
+
+QByteArray QtPrivate::convertToLocal8Bit(QStringView string)
+{
+    return qt_convert_to_local_8bit(string);
+}
+
+QStringIterator::QStringIterator(QStringView string, qsizetype idx)
+    : i(string.begin()),
+      pos(i + idx),
+      e(string.end())
+{
+}
+
+static QVector<uint> qt_convert_to_ucs4(QStringView string)
+{
+    QVector<uint> v(string.length());
+    uint *a = const_cast<uint*>(v.constData());
+    QStringIterator it(string);
+    while (it.hasNext())
+        *a++ = it.next();
+    v.resize(a - v.constData());
+    return v;
+}
+
+QVector<uint> QtPrivate::convertToUcs4(QStringView string)
+{
+    return qt_convert_to_ucs4(string);
+}
+
+// static bool _isNull(QChar &c)
+// {
+//     return c.isNull();
+// }
+
+static bool _isNull(QStringView &c)
+{
+    return c.isNull();
+}
+
+static bool _isNull(QLatin1String &c)
+{
+    return c.data() == nullptr;
+}
+
+template <typename Haystack, typename Needle>
+bool qt_starts_with_impl(Haystack haystack, Needle needle, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    if (_isNull(haystack))
+        return _isNull(needle); // historical behavior, consider changing in ### Qt 6.
+    const auto haystackLen = haystack.size();
+    const auto needleLen = needle.size();
+    if (haystackLen == 0)
+        return needleLen == 0;
+    if (needleLen > haystackLen)
+        return false;
+
+    return qt_compare_strings(haystack.left(needleLen), needle, cs) == 0;
+}
+
+// static inline bool qt_starts_with(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs)
+// {
+//     return qt_starts_with_impl(haystack, needle, cs);
+// }
+// 
+// static inline bool qt_starts_with(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs)
+// {
+//     return qt_starts_with_impl(haystack, needle, cs);
+// }
+/*
+static inline bool qt_starts_with(QStringView haystack, QChar needle, Qt::CaseSensitivity cs)
+{
+    return haystack.size()
+           && (cs == Qt::CaseSensitive ? haystack.front() == needle
+                                       : foldCase(haystack.front()) == foldCase(needle));
+}*/
+
+bool QtPrivate::startsWith(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    return qt_starts_with_impl(haystack, needle, cs);
+}
+
+bool QtPrivate::startsWith(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    return qt_starts_with_impl(haystack, needle, cs);
+}
+
+bool QtPrivate::startsWith(QLatin1String haystack, QStringView needle, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    return qt_starts_with_impl(haystack, needle, cs);
+}
+
+bool QtPrivate::startsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    return qt_starts_with_impl(haystack, needle, cs);
+}
+
+template <typename Haystack, typename Needle>
+bool qt_ends_with_impl(Haystack haystack, Needle needle, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    if (_isNull(haystack))
+        return _isNull(needle); // historical behavior, consider changing in ### Qt 6.
+    const auto haystackLen = haystack.size();
+    const auto needleLen = needle.size();
+    if (haystackLen == 0)
+        return needleLen == 0;
+    if (haystackLen < needleLen)
+        return false;
+
+    return qt_compare_strings(haystack.right(needleLen), needle, cs) == 0;
+}
+
+// static inline bool qt_ends_with(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs)
+// {
+//     return qt_ends_with_impl(haystack, needle, cs);
+// }
+// 
+// static inline bool qt_ends_with(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs)
+// {
+//     return qt_ends_with_impl(haystack, needle, cs);
+// }
+// 
+// static inline bool qt_ends_with(QStringView haystack, QChar needle, Qt::CaseSensitivity cs)
+// {
+//     return haystack.size()
+//            && (cs == Qt::CaseSensitive ? haystack.back() == needle
+//                                        : foldCase(haystack.back()) == foldCase(needle));
+// }
+// 
+bool QtPrivate::endsWith(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    return qt_ends_with_impl(haystack, needle, cs);
+}
+
+bool QtPrivate::endsWith(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    return qt_ends_with_impl(haystack, needle, cs);
+}
+
+bool QtPrivate::endsWith(QLatin1String haystack, QStringView needle, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    return qt_ends_with_impl(haystack, needle, cs);
+}
+
+bool QtPrivate::endsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs) Q_DECL_NOTHROW
+{
+    return qt_ends_with_impl(haystack, needle, cs);
+}
+
+/*!
+    \class QStringView
+    \inmodule QtCore
+    \since 5.10
+    \brief The QStringView class provides a unified view on UTF-16 strings with a read-only subset of the QString API.
+    \reentrant
+    \ingroup tools
+    \ingroup string-processing
+
+    A QStringView references a contiguous portion of a UTF-16 string it does
+    not own. It acts as an interface type to all kinds of UTF-16 string,
+    without the need to construct a QString first.
+
+    The UTF-16 string may be represented as an array (or an array-compatible
+    data-structure such as QString,
+    std::basic_string, etc.) of QChar, \c ushort, \c char16_t (on compilers that
+    support C++11 Unicode strings) or (on platforms, such as Windows,
+    where it is a 16-bit type) \c wchar_t.
+
+    QStringView is designed as an interface type; its main use-case is
+    as a function parameter type. When QStringViews are used as automatic
+    variables or data members, care must be taken to ensure that the referenced
+    string data (for example, owned by a QString) outlives the QStringView on all code paths,
+    lest the string view ends up referencing deleted data.
+
+    When used as an interface type, QStringView allows a single function to accept
+    a wide variety of UTF-16 string data sources. One function accepting QStringView
+    thus replaces three function overloads (taking QString, QStringRef, and
+    \c{(const QChar*, int)}), while at the same time enabling even more string data
+    sources to be passed to the function, such as \c{u"Hello World"}, a \c char16_t
+    string literal.
+
+    QStringViews should be passed by value, not by reference-to-const:
+    \code
+    void myfun1(QStringView sv);        // preferred
+    void myfun2(const QStringView &sv); // compiles and works, but slower
+    \endcode
+
+    If you want to give your users maximum freedom in what strings they can pass
+    to your function, accompany the QStringView overload with overloads for
+
+    \list
+        \li \e QChar: this overload can delegate to the QStringView version:
+            \code
+            void fun(QChar ch) { fun(QStringView(&ch, 1)); }
+            \endcode
+            even though, for technical reasons, QStringView cannot provide a
+            QChar constructor by itself.
+        \li \e QString: if you store an unmodified copy of the string and thus would
+            like to take advantage of QString's implicit sharing.
+        \li QLatin1String: if you can implement the function without converting the
+            QLatin1String to UTF-16 first; users expect a function overloaded on
+            QLatin1String to perform strictly less memory allocations than the
+            semantically equivalent call of the QStringView version, involving
+            construction of a QString from the QLatin1String.
+    \endlist
+
+    QStringView can also be used as the return value of a function. If you call a
+    function returning QStringView, take extra care to not keep the QStringView
+    around longer than the function promises to keep the referenced string data alive.
+    If in doubt, obtain a strong reference to the data by calling toString() to convert
+    the QStringView into a QString.
+
+    QStringView is a \e{Literal Type}, but since it stores data as \c{char16_t}, iteration
+    is not \c constexpr (casts from \c{const char16_t*} to \c{const QChar*}, which is not
+    allowed in \c constexpr functions). You can use an indexed loop and/or utf16() in
+    \c constexpr contexts instead.
+
+    \note We strongly discourage the use of QList<QStringView>,
+    because QList is a very inefficient container for QStringViews (it would heap-allocate
+    every element). Use QVector (or std::vector) to hold QStringViews instead.
+
+    \sa QString, QStringRef
+*/
+
+/*!
+    \typedef QStringView::value_type
+
+    Alias for \c{const QChar}. Provided for compatibility with the STL.
+*/
+
+/*!
+    \typedef QStringView::difference_type
+
+    Alias for \c{std::ptrdiff_t}. Provided for compatibility with the STL.
+*/
+
+/*!
+    \typedef QStringView::size_type
+
+    Alias for qsizetype. Provided for compatibility with the STL.
+
+    Unlike other Qt classes, QStringView uses qsizetype as its \c size_type, to allow
+    accepting data from \c{std::basic_string} without truncation. The Qt API functions,
+    for example length(), return \c int, while the STL-compatible functions, for example
+    size(), return \c size_type.
+*/
+
+/*!
+    \typedef QStringView::reference
+
+    Alias for \c{value_type &}. Provided for compatibility with the STL.
+
+    QStringView does not support mutable references, so this is the same
+    as const_reference.
+*/
+
+/*!
+    \typedef QStringView::const_reference
+
+    Alias for \c{value_type &}. Provided for compatibility with the STL.
+*/
+
+/*!
+    \typedef QStringView::pointer
+
+    Alias for \c{value_type *}. Provided for compatibility with the STL.
+
+    QStringView does not support mutable pointers, so this is the same
+    as const_pointer.
+*/
+
+/*!
+    \typedef QStringView::const_pointer
+
+    Alias for \c{value_type *}. Provided for compatibility with the STL.
+*/
+
+/*!
+    \typedef QStringView::iterator
+
+    This typedef provides an STL-style const iterator for QStringView.
+
+    QStringView does not support mutable iterators, so this is the same
+    as const_iterator.
+
+    \sa const_iterator, reverse_iterator
+*/
+
+/*!
+    \typedef QStringView::const_iterator
+
+    This typedef provides an STL-style const iterator for QStringView.
+
+    \sa iterator, const_reverse_iterator
+*/
+
+/*!
+    \typedef QStringView::reverse_iterator
+
+    This typedef provides an STL-style const reverse iterator for QStringView.
+
+    QStringView does not support mutable reverse iterators, so this is the
+    same as const_reverse_iterator.
+
+    \sa const_reverse_iterator, iterator
+*/
+
+/*!
+    \typedef QStringView::const_reverse_iterator
+
+    This typedef provides an STL-style const reverse iterator for QStringView.
+
+    \sa reverse_iterator, const_iterator
+*/
+
+/*!
+    \fn QStringView::QStringView()
+
+    Constructs a null string view.
+
+    \sa isNull()
+*/
+
+/*!
+    \fn QStringView::QStringView(std::nullptr_t)
+
+    Constructs a null string view.
+
+    \sa isNull()
+*/
+
+/*!
+    \fn QStringView::QStringView(const Char *str, qsizetype len)
+
+    Constructs a string view on \a str with length \a len.
+
+    The range \c{[str,len)} must remain valid for the lifetime of this string view object.
+
+    Passing \c nullptr as \a str is safe if \a len is 0, too, and results in a null string view.
+
+    The behavior is undefined if \a len is negative or, when positive, if \a str is \c nullptr.
+
+    This constructor only participates in overload resolution if \c Char is a compatible
+    character type. The compatible character types are: \c QChar, \c ushort, \c char16_t and
+    (on platforms, such as Windows, where it is a 16-bit type) \c wchar_t.
+*/
+
+/*!
+    \fn QStringView::QStringView(const Char *first, const Char *last)
+
+    Constructs a string view on \a first with length (\a last - \a first).
+
+    The range \c{[first,last)} must remain valid for the lifetime of
+    this string view object.
+
+    Passing \c nullptr as \a first is safe if \a last is nullptr, too,
+    and results in a null string view.
+
+    The behavior is undefined if \a last precedes \a first, or \a first
+    is \c nullptr and \a last is not.
+
+    This constructor only participates in overload resolution if \c Char
+    is a compatible character type. The compatible character types
+    are: \c QChar, \c ushort, \c char16_t and (on platforms, such as
+    Windows, where it is a 16-bit type) \c wchar_t.
+*/
+
+/*!
+    \fn QStringView::QStringView(const Char *str)
+
+    Constructs a string view on \a str. The length is determined
+    by scanning for the first \c{Char(0)}.
+
+    \a str must remain valid for the lifetime of this string view object.
+
+    Passing \c nullptr as \a str is safe and results in a null string view.
+
+    This constructor only participates in overload resolution if \a
+    str is not an array and if \c Char is a compatible character
+    type. The compatible character types are: \c QChar, \c ushort, \c
+    char16_t and (on platforms, such as Windows, where it is a 16-bit
+    type) \c wchar_t.
+*/
+
+/*!
+    \fn QStringView::QStringView(const Char (&string)[N])
+
+    Constructs a string view on the character string literal \a string.
+    The length is set to \c{N-1}, excluding the trailing \{Char(0)}.
+    If you need the full array, use the constructor from pointer and
+    size instead:
+
+    \code
+    auto sv = QStringView(array, std::size(array)); // using C++17 std::size()
+    \endcode
+
+    \a string must remain valid for the lifetime of this string view
+    object.
+
+    This constructor only participates in overload resolution if \a
+    string is an actual array and \c Char is a compatible character
+    type. The compatible character types are: \c QChar, \c ushort, \c
+    char16_t and (on platforms, such as Windows, where it is a 16-bit
+    type) \c wchar_t.
+*/
+
+/*!
+    \fn QStringView::QStringView(const QString &str)
+
+    Constructs a string view on \a str.
+
+    \c{str.data()} must remain valid for the lifetime of this string view object.
+
+    The string view will be null if and only if \c{str.isNull()}.
+*/
+
+/*!
+    \fn QStringView::QStringView(const QStringRef &str)
+
+    Constructs a string view on \a str.
+
+    \c{str.data()} must remain valid for the lifetime of this string view object.
+
+    The string view will be null if and only if \c{str.isNull()}.
+*/
+
+/*!
+    \fn QStringView::QStringView(const StdBasicString &str)
+
+    Constructs a string view on \a str. The length is taken from \c{str.size()}.
+
+    \c{str.data()} must remain valid for the lifetime of this string view object.
+
+    This constructor only participates in overload resolution if \c StdBasicString is an
+    instantiation of \c std::basic_string with a compatible character type. The
+    compatible character types are: \c QChar, \c ushort, \c char16_t and
+    (on platforms, such as Windows, where it is a 16-bit type) \c wchar_t.
+
+    The string view will be empty if and only if \c{str.empty()}. It is unspecified
+    whether this constructor can result in a null string view (\c{str.data()} would
+    have to return \c nullptr for this).
+
+    \sa isNull(), isEmpty()
+*/
+
+/*!
+    \fn QString QStringView::toString() const
+
+    Returns a deep copy of this string view's data as a QString.
+
+    The return value will be the null QString if and only if this string view is null.
+
+    \warning QStringView can store strings with more than 2\sup{30} characters
+    while QString cannot. Calling this function on a string view for which size()
+    returns a value greater than \c{INT_MAX / 2} constitutes undefined behavior.
+*/
+
+/*!
+    \fn const QChar *QStringView::data() const
+
+    Returns a const pointer to the first character in the string.
+
+    \note The character array represented by the return value is \e not null-terminated.
+
+    \sa begin(), end(), utf16()
+*/
+
+/*!
+    \fn const storage_type *QStringView::utf16() const
+
+    Returns a const pointer to the first character in the string.
+
+    \c{storage_type} is \c{char16_t}, except on MSVC 2013 (which lacks \c char16_t support),
+    where it is \c{wchar_t} instead.
+
+    \note The character array represented by the return value is \e not null-terminated.
+
+    \sa begin(), end(), data()
+*/
+
+/*!
+    \fn QStringView::const_iterator QStringView::begin() const
+
+    Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first character in
+    the string.
+
+    This function is provided for STL compatibility.
+
+    \sa end(), cbegin(), rbegin(), data()
+*/
+
+/*!
+    \fn QStringView::const_iterator QStringView::cbegin() const
+
+    Same as begin().
+
+    This function is provided for STL compatibility.
+
+    \sa cend(), begin(), crbegin(), data()
+*/
+
+/*!
+    \fn QStringView::const_iterator QStringView::end() const
+
+    Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
+    character after the last character in the list.
+
+    This function is provided for STL compatibility.
+
+    \sa begin(), cend(), rend()
+*/
+
+/*! \fn QStringView::const_iterator QStringView::cend() const
+
+    Same as end().
+
+    This function is provided for STL compatibility.
+
+    \sa cbegin(), end(), crend()
+*/
+
+/*!
+    \fn QStringView::const_reverse_iterator QStringView::rbegin() const
+
+    Returns a const \l{STL-style iterators}{STL-style} reverse iterator pointing to the first
+    character in the string, in reverse order.
+
+    This function is provided for STL compatibility.
+
+    \sa rend(), crbegin(), begin()
+*/
+
+/*!
+    \fn QStringView::const_reverse_iterator QStringView::crbegin() const
+
+    Same as rbegin().
+
+    This function is provided for STL compatibility.
+
+    \sa crend(), rbegin(), cbegin()
+*/
+
+/*!
+    \fn QStringView::const_reverse_iterator QStringView::rend() const
+
+    Returns a \l{STL-style iterators}{STL-style} reverse iterator pointing to one past
+    the last character in the string, in reverse order.
+
+    This function is provided for STL compatibility.
+
+    \sa rbegin(), crend(), end()
+*/
+
+/*!
+    \fn QStringView::const_reverse_iterator QStringView::crend() const
+
+    Same as rend().
+
+    This function is provided for STL compatibility.
+
+    \sa crbegin(), rend(), cend()
+*/
+
+/*!
+    \fn bool QStringView::empty() const
+
+    Returns whether this string view is empty - that is, whether \c{size() == 0}.
+
+    This function is provided for STL compatibility.
+
+    \sa isEmpty(), isNull(), size(), length()
+*/
+
+/*!
+    \fn bool QStringView::isEmpty() const
+
+    Returns whether this string view is empty - that is, whether \c{size() == 0}.
+
+    This function is provided for compatibility with other Qt containers.
+
+    \sa empty(), isNull(), size(), length()
+*/
+
+/*!
+    \fn bool QStringView::isNull() const
+
+    Returns whether this string view is null - that is, whether \c{data() == nullptr}.
+
+    This functions is provided for compatibility with other Qt containers.
+
+    \sa empty(), isEmpty(), size(), length()
+*/
+
+/*!
+    \fn qsizetype QStringView::size() const
+
+    Returns the size of this string view, in UTF-16 code points (that is,
+    surrogate pairs count as two for the purposes of this function, the same
+    as in QString and QStringRef).
+
+    \sa empty(), isEmpty(), isNull(), length()
+*/
+
+/*!
+    \fn int QStringView::length() const
+
+    Same as size(), except returns the result as an \c int.
+
+    This function is provided for compatibility with other Qt containers.
+
+    \warning QStringView can represent strings with more than 2\sup{31} characters.
+    Calling this function on a string view for which size() returns a value greater
+    than \c{INT_MAX} constitutes undefined behavior.
+
+    \sa empty(), isEmpty(), isNull(), size()
+*/
+
+/*!
+    \fn QChar QStringView::operator[](qsizetype n) const
+
+    Returns the character at position \a n in this string view.
+
+    The behavior is undefined if \a n is negative or not less than size().
+
+    \sa at(), front(), back()
+*/
+
+/*!
+    \fn QChar QStringView::at(qsizetype n) const
+
+    Returns the character at position \a n in this string view.
+
+    The behavior is undefined if \a n is negative or not less than size().
+
+    \sa operator[](), front(), back()
+*/
+
+/*!
+    \fn QChar QStringView::front() const
+
+    Returns the first character in the string. Same as first().
+
+    This function is provided for STL compatibility.
+
+    \warning Calling this function on an empty string view constitutes
+    undefined behavior.
+
+    \sa back(), first(), last()
+*/
+
+/*!
+    \fn QChar QStringView::back() const
+
+    Returns the last character in the string. Same as last().
+
+    This function is provided for STL compatibility.
+
+    \warning Calling this function on an empty string view constitutes
+    undefined behavior.
+
+    \sa front(), first(), last()
+*/
+
+/*!
+    \fn QChar QStringView::first() const
+
+    Returns the first character in the string. Same as front().
+
+    This function is provided for compatibility with other Qt containers.
+
+    \warning Calling this function on an empty string view constitutes
+    undefined behavior.
+
+    \sa front(), back(), last()
+*/
+
+/*!
+    \fn QChar QStringView::last() const
+
+    Returns the last character in the string. Same as back().
+
+    This function is provided for compatibility with other Qt containers.
+
+    \warning Calling this function on an empty string view constitutes
+    undefined behavior.
+
+    \sa back(), front(), first()
+*/
+
+/*!
+    \fn QStringView QStringView::mid(qsizetype start) const
+
+    Returns the substring starting at position \a start in this object,
+    and extending to the end of the string.
+
+    \note The behavior is undefined when \a start < 0 or \a start > size().
+
+    \sa left(), right(), chopped(), chop(), truncate()
+*/
+
+/*!
+    \fn QStringView QStringView::mid(qsizetype start, qsizetype length) const
+    \overload
+
+    Returns the substring of length \a length starting at position
+    \a start in this object.
+
+    \note The behavior is undefined when \a start < 0, \a length < 0,
+    or \a start + \a length > size().
+
+    \sa left(), right(), chopped(), chop(), truncate()
+*/
+
+/*!
+    \fn QStringView QStringView::left(qsizetype length) const
+
+    Returns the substring of length \a length starting at position
+    0 in this object.
+
+    \note The behavior is undefined when \a length < 0 or \a length > size().
+
+    \sa mid(), right(), chopped(), chop(), truncate()
+*/
+
+/*!
+    \fn QStringView QStringView::right(qsizetype length) const
+
+    Returns the substring of length \a length starting at position
+    size() - \a length in this object.
+
+    \note The behavior is undefined when \a length < 0 or \a length > size().
+
+    \sa mid(), left(), chopped(), chop(), truncate()
+*/
+
+/*!
+    \fn QStringView QStringView::chopped(qsizetype length) const
+
+    Returns the substring of length size() - \a length starting at the
+    beginning of this object.
+
+    Same as \c{left(size() - length)}.
+
+    \note The behavior is undefined when \a length < 0 or \a length > size().
+
+    \sa mid(), left(), right(), chop(), truncate()
+*/
+
+/*!
+    \fn void QStringView::truncate(qsizetype length)
+
+    Truncates this string view to length \a length.
+
+    Same as \c{*this = left(length)}.
+
+    \note The behavior is undefined when \a length < 0 or \a length > size().
+
+    \sa mid(), left(), right(), chopped(), chop()
+*/
+
+/*!
+    \fn void QStringView::chop(qsizetype length)
+
+    Truncates this string view by \a length characters.
+
+    Same as \c{*this = left(size() - length)}.
+
+    \note The behavior is undefined when \a length < 0 or \a length > size().
+
+    \sa mid(), left(), right(), chopped(), truncate()
+*/
+
+/*!
+    \fn QStringView QStringView::trimmed() const
+
+    Strips leading and trailing whitespace and returns the result.
+
+    Whitespace means any character for which QChar::isSpace() returns
+    \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
+    '\\f', '\\r', and ' '.
+*/
+
+/*!
+    \fn bool QStringView::startsWith(QStringView str, Qt::CaseSensitivity cs) const
+    \fn bool QStringView::startsWith(QLatin1String l1, Qt::CaseSensitivity cs) const
+    \fn bool QStringView::startsWith(QChar ch) const
+    \fn bool QStringView::startsWith(QChar ch, Qt::CaseSensitivity cs) const
+
+    Returns \c true if this string-view starts with string-view \a str,
+    Latin-1 string \a l1, or character \a ch, respectively;
+    otherwise returns \c false.
+
+    If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
+    otherwise the search is case-insensitive.
+
+    \sa endsWith()
+*/
+
+/*!
+    \fn bool QStringView::endsWith(QStringView str, Qt::CaseSensitivity cs) const
+    \fn bool QStringView::endsWith(QLatin1String l1, Qt::CaseSensitivity cs) const
+    \fn bool QStringView::endsWith(QChar ch) const
+    \fn bool QStringView::endsWith(QChar ch, Qt::CaseSensitivity cs) const
+
+    Returns \c true if this string-view ends with string-view \a str,
+    Latin-1 string \a l1, or character \a ch, respectively;
+    otherwise returns \c false.
+
+    If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
+    otherwise the search is case-insensitive.
+
+    \sa startsWith()
+*/
+
+/*!
+    \fn QByteArray QStringView::toLatin1() const
+
+    Returns a Latin-1 representation of the string as a QByteArray.
+
+    The behavior is undefined if the string contains non-Latin1 characters.
+
+    \sa toUtf8(), toLocal8Bit(), QTextCodec, qConvertToLatin1()
+*/
+
+/*!
+    \fn QByteArray QStringView::toLocal8Bit() const
+
+    Returns a local 8-bit representation of the string as a QByteArray.
+
+    QTextCodec::codecForLocale() is used to perform the conversion from
+    Unicode. If the locale's encoding could not be determined, this function
+    does the same as toLatin1().
+
+    The behavior is undefined if the string contains characters not
+    supported by the locale's 8-bit encoding.
+
+    \sa toLatin1(), toUtf8(), QTextCodec
+*/
+
+/*!
+    \fn QByteArray QStringView::toUtf8() const
+
+    Returns a UTF-8 representation of the string as a QByteArray.
+
+    UTF-8 is a Unicode codec and can represent all characters in a Unicode
+    string like QString.
+
+    \sa toLatin1(), toLocal8Bit(), QTextCodec, qConvertToUtf8()
+*/
+
+/*!
+    \fn QVector<uint> QStringView::toUcs4() const
+
+    Returns a UCS-4/UTF-32 representation of the string as a QVector<uint>.
+
+    UCS-4 is a Unicode codec and therefore it is lossless. All characters from
+    this string will be encoded in UCS-4. Any invalid sequence of code units in
+    this string is replaced by the Unicode replacement character
+    (QChar::ReplacementCharacter, which corresponds to \c{U+FFFD}).
+
+    The returned vector is not 0-terminated.
+
+    \sa toUtf8(), toLatin1(), toLocal8Bit(), QTextCodec
+*/
+
+/*!
+    \fn qToStringViewIgnoringNull(const QStringLike &s);
+    \since 5.10
+    \internal
+
+    Convert \a s to a QStringView ignoring \c{s.isNull()}.
+
+    Returns a string-view that references \a{s}' data, but is never null.
+
+    This is a faster way to convert a QString or QStringRef to a QStringView,
+    if null QStrings can legitimately be treated as empty ones.
+
+    \sa QString::isNull(), QStringRef::isNull(), QStringView
+*/
+
+QString QStringView::toString() const
+{
+    return Q_ASSERT10(size() == length()), QString(data(), length());
+}
+
+uint qHash(QStringView key, uint seed) Q_DECL_NOTHROW
+{
+    return qHash(key.toString(), seed);
+}
+
+// From qstring.h @ 5.10 :
+
+bool QLatin1String::startsWith(QStringView s, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW
+{
+    return QtPrivate::startsWith(*this, s, cs);
+}
+
+Q_REQUIRED_RESULT QVector<uint> QStringView::toUcs4() const
+{
+    return QtPrivate::convertToUcs4(*this);
+}
+
+Q_REQUIRED_RESULT bool QLatin1String::startsWith(QLatin1String s, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW
+{
+    return QtPrivate::startsWith(*this, s, cs);
+}
+
+Q_REQUIRED_RESULT Q_DECL_CONSTEXPR bool QLatin1String::startsWith(QChar c) const Q_DECL_NOTHROW
+{
+    return size() && front() == c;
+}
+
+Q_REQUIRED_RESULT inline bool QLatin1String::startsWith(QChar c, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW
+{
+    return QtPrivate::startsWith(*this, QStringView(&c, 1), cs);
+}
+
+Q_REQUIRED_RESULT bool QLatin1String::endsWith(QStringView s, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW
+{
+    return QtPrivate::endsWith(*this, s, cs);
+}
+
+Q_REQUIRED_RESULT bool QLatin1String::endsWith(QLatin1String s, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW
+{
+    return QtPrivate::endsWith(*this, s, cs);
+}
+
+Q_REQUIRED_RESULT Q_DECL_CONSTEXPR bool QLatin1String::endsWith(QChar c) const Q_DECL_NOTHROW
+{
+    return size() && back() == c;
+}
+
+Q_REQUIRED_RESULT inline bool QLatin1String::endsWith(QChar c, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW
+{
+    return QtPrivate::endsWith(*this, QStringView(&c, 1), cs);
+}
+
+Q_REQUIRED_RESULT QString QString::arg(QStringView a, int fieldWidth, QChar fillChar) const
+{
+    return arg(a.toString(), fieldWidth, fillChar);
+}
+
+Q_REQUIRED_RESULT bool QString::startsWith(QStringView s, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW
+{
+    return QtPrivate::startsWith(*this, s, cs);
+}
+
+Q_REQUIRED_RESULT bool QString::endsWith(QStringView s, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW
+{
+    return QtPrivate::endsWith(*this, s, cs);
+}
+
+Q_REQUIRED_RESULT bool QStringRef::startsWith(QStringView s, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW
+{
+    return QtPrivate::startsWith(*this, s, cs);
+}
+
+Q_REQUIRED_RESULT bool QStringRef::endsWith(QStringView s, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW
+{
+    return QtPrivate::endsWith(*this, s, cs);
+}
+
+// from qdatetime.cpp @ 5.10
+
+QString QDate::toString(QStringView format) const
+{
+    return QLocale::system().toString(*this, format.toString()); // QLocale::c() ### Qt6
+}
+
+QString QTime::toString(QStringView format) const
+{
+    return QLocale::system().toString(*this, format.toString()); // QLocale::c() ### Qt6
+}
+
+QString QDateTime::toString(QStringView format) const
+{
+    return QLocale::system().toString(*this, format.toString()); // QLocale::c() ### Qt6
+}
+
+
+QT_END_NAMESPACE
diff --git a/qtbase/src/corelib/tools/qstringview.h b/qtbase/src/corelib/tools/qstringview.h
new file mode 100644
index 0000000000000000000000000000000000000000..045ed767602f87f0ad32340d9118b7ff7d114268
--- /dev/null
+++ b/qtbase/src/corelib/tools/qstringview.h
@@ -0,0 +1,373 @@
+/****************************************************************************
+**
+** Copyright (C) 2017 Klar√§lvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Marc Mutz <marc.mutz@kdab.com>
+** Contact: http://www.qt.io/licensing/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifndef QSTRINGVIEW_H
+#define QSTRINGVIEW_H
+
+#ifndef QT_STRINGVIEW_LEVEL
+#  define QT_STRINGVIEW_LEVEL 1
+#endif
+
+#include <QtCore/qchar.h>
+#include <QtCore/qbytearray.h>
+// RJVB : include qstring.h instead of qstringliteral.h
+#include <QtCore/qstring.h>
+#include <QtCore/qstringalgorithms.h>
+#include <QtCore/qdebug.h>
+
+#include <string>
+
+#if !defined(Q_ASSERT10)
+#  if defined(QT_NO_DEBUG) && !defined(QT_FORCE_ASSERTS)
+#    define Q_ASSERT10(cond) static_cast<void>(false && (cond))
+#  else
+#    define Q_ASSERT10(cond) ((cond) ? static_cast<void>(0) : qt_assert(#cond, __FILE__, __LINE__))
+#  endif
+#endif
+
+QT_BEGIN_NAMESPACE
+
+class QString;
+class QStringRef;
+
+namespace QtPrivate {
+template <typename Char>
+struct IsCompatibleCharTypeHelper
+    : std::integral_constant<bool,
+                             std::is_same<Char, QChar>::value ||
+                             std::is_same<Char, ushort>::value ||
+#if defined(Q_COMPILER_UNICODE_STRINGS)
+                             std::is_same<Char, char16_t>::value ||
+#endif
+                             (std::is_same<Char, wchar_t>::value && sizeof(wchar_t) == sizeof(QChar))> {};
+template <typename Char>
+struct IsCompatibleCharType
+    : IsCompatibleCharTypeHelper<typename std::remove_cv<typename std::remove_reference<Char>::type>::type> {};
+
+template <typename Array>
+struct IsCompatibleArrayHelper : std::false_type {};
+template <typename Char, size_t N>
+struct IsCompatibleArrayHelper<Char[N]>
+    : IsCompatibleCharType<Char> {};
+template <typename Array>
+struct IsCompatibleArray
+    : IsCompatibleArrayHelper<typename std::remove_cv<typename std::remove_reference<Array>::type>::type> {};
+
+template <typename Pointer>
+struct IsCompatiblePointerHelper : std::false_type {};
+template <typename Char>
+struct IsCompatiblePointerHelper<Char*>
+    : IsCompatibleCharType<Char> {};
+template <typename Pointer>
+struct IsCompatiblePointer
+    : IsCompatiblePointerHelper<typename std::remove_cv<typename std::remove_reference<Pointer>::type>::type> {};
+
+template <typename T>
+struct IsCompatibleStdBasicStringHelper : std::false_type {};
+template <typename Char, typename...Args>
+struct IsCompatibleStdBasicStringHelper<std::basic_string<Char, Args...> >
+    : IsCompatibleCharType<Char> {};
+
+template <typename T>
+struct IsCompatibleStdBasicString
+    : IsCompatibleStdBasicStringHelper<
+        typename std::remove_cv<typename std::remove_reference<T>::type>::type
+      > {};
+
+} // namespace QtPrivate
+
+class Q_CORE_EXPORT QStringView
+{
+public:
+#if defined(Q_OS_WIN) && !defined(Q_COMPILER_UNICODE_STRINGS)
+    typedef wchar_t storage_type;
+#else
+    typedef char16_t storage_type;
+#endif
+    typedef const QChar value_type;
+    typedef std::ptrdiff_t difference_type;
+    typedef qsizetype size_type;
+    typedef value_type &reference;
+    typedef value_type &const_reference;
+    typedef value_type *pointer;
+    typedef value_type *const_pointer;
+
+    typedef pointer iterator;
+    typedef const_pointer const_iterator;
+    typedef std::reverse_iterator<iterator> reverse_iterator;
+    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
+
+private:
+    template <typename Char>
+    using if_compatible_char = typename std::enable_if<QtPrivate::IsCompatibleCharType<Char>::value, bool>::type;
+
+    template <typename Array>
+    using if_compatible_array = typename std::enable_if<QtPrivate::IsCompatibleArray<Array>::value, bool>::type;
+
+    template <typename Pointer>
+    using if_compatible_pointer = typename std::enable_if<QtPrivate::IsCompatiblePointer<Pointer>::value, bool>::type;
+
+    template <typename T>
+    using if_compatible_string = typename std::enable_if<QtPrivate::IsCompatibleStdBasicString<T>::value, bool>::type;
+
+    template <typename T>
+    using if_compatible_qstring_like = typename std::enable_if<std::is_same<T, QString>::value || std::is_same<T, QStringRef>::value, bool>::type;
+
+    template <typename Char, size_t N>
+    static Q_DECL_CONSTEXPR qsizetype lengthHelperArray(const Char (&)[N]) Q_DECL_NOTHROW
+    {
+        return qsizetype(N - 1);
+    }
+
+    template <typename Char>
+    static qsizetype lengthHelperPointer(const Char *str) Q_DECL_NOTHROW
+    {
+#if defined(Q_CC_GNU) && !defined(Q_CC_CLANG) && !defined(Q_CC_INTEL)
+        if (__builtin_constant_p(*str)) {
+            qsizetype result = 0;
+            while (*str++)
+                ++result;
+            return result;
+        }
+#endif
+        return QtPrivate::qustrlen(reinterpret_cast<const ushort *>(str));
+    }
+    static qsizetype lengthHelperPointer(const QChar *str) Q_DECL_NOTHROW
+    {
+        return QtPrivate::qustrlen(reinterpret_cast<const ushort *>(str));
+    }
+
+    template <typename Char>
+    static const storage_type *castHelper(const Char *str) Q_DECL_NOTHROW
+    { return reinterpret_cast<const storage_type*>(str); }
+    static Q_DECL_CONSTEXPR const storage_type *castHelper(const storage_type *str) Q_DECL_NOTHROW
+    { return str; }
+
+public:
+    Q_DECL_CONSTEXPR QStringView() Q_DECL_NOTHROW
+        : m_size(0), m_data(nullptr) {}
+    Q_DECL_CONSTEXPR QStringView(std::nullptr_t) Q_DECL_NOTHROW
+        : QStringView() {}
+
+    template <typename Char, if_compatible_char<Char> = true>
+    Q_DECL_CONSTEXPR QStringView(const Char *str, qsizetype len)
+        : m_size((Q_ASSERT10(len >= 0), Q_ASSERT10(str || !len), len)),
+          m_data(castHelper(str)) {}
+
+    template <typename Char, if_compatible_char<Char> = true>
+    Q_DECL_CONSTEXPR QStringView(const Char *f, const Char *l)
+        : QStringView(f, l - f) {}
+
+#ifdef Q_QDOC
+    template <typename Char, size_t N>
+    Q_DECL_CONSTEXPR QStringView(const Char (&array)[N]) Q_DECL_NOTHROW;
+
+    template <typename Char>
+    Q_DECL_CONSTEXPR QStringView(const Char *str) Q_DECL_NOTHROW;
+#else
+    template <typename Array, if_compatible_array<Array> = true>
+    Q_DECL_CONSTEXPR QStringView(const Array &str) Q_DECL_NOTHROW
+        : QStringView(str, lengthHelperArray(str)) {}
+
+    template <typename Pointer, if_compatible_pointer<Pointer> = true>
+    Q_DECL_CONSTEXPR QStringView(const Pointer &str) Q_DECL_NOTHROW
+        : QStringView(str, str ? lengthHelperPointer(str) : 0) {}
+#endif
+
+#ifdef Q_QDOC
+    QStringView(const QString &str) Q_DECL_NOTHROW;
+    QStringView(const QStringRef &str) Q_DECL_NOTHROW;
+#else
+    template <typename String, if_compatible_qstring_like<String> = true>
+    QStringView(const String &str) Q_DECL_NOTHROW
+        : QStringView(str.isNull() ? nullptr : str.data(), qsizetype(str.size())) {}
+#endif
+
+    template <typename StdBasicString, if_compatible_string<StdBasicString> = true>
+    QStringView(const StdBasicString &str) Q_DECL_NOTHROW
+        : QStringView(str.data(), qsizetype(str.size())) {}
+
+    Q_REQUIRED_RESULT QString toString() const; // defined in qstring.h
+
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR qsizetype size() const Q_DECL_NOTHROW { return m_size; }
+    Q_REQUIRED_RESULT const_pointer data() const Q_DECL_NOTHROW { return reinterpret_cast<const_pointer>(m_data); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR const storage_type *utf16() const Q_DECL_NOTHROW { return m_data; }
+
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QChar operator[](qsizetype n) const
+    { return Q_ASSERT10(n >= 0), Q_ASSERT10(n < size()), QChar(m_data[n]); }
+
+    //
+    // QString API
+    //
+
+    Q_REQUIRED_RESULT QByteArray toLatin1() const { return QtPrivate::convertToLatin1(*this); }
+    Q_REQUIRED_RESULT QByteArray toUtf8() const { return QtPrivate::convertToUtf8(*this); }
+    Q_REQUIRED_RESULT QByteArray toLocal8Bit() const { return QtPrivate::convertToLocal8Bit(*this); }
+    Q_REQUIRED_RESULT QVector<uint> toUcs4() const;
+
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QChar at(qsizetype n) const { return (*this)[n]; }
+
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QStringView mid(qsizetype pos) const
+    { return Q_ASSERT10(pos >= 0), Q_ASSERT10(pos <= size()), QStringView(m_data + pos, m_size - pos); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QStringView mid(qsizetype pos, qsizetype n) const
+    { return Q_ASSERT10(pos >= 0), Q_ASSERT10(n >= 0), Q_ASSERT10(pos + n <= size()), QStringView(m_data + pos, n); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QStringView left(qsizetype n) const
+    { return Q_ASSERT10(n >= 0), Q_ASSERT10(n <= size()), QStringView(m_data, n); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QStringView right(qsizetype n) const
+    { return Q_ASSERT10(n >= 0), Q_ASSERT10(n <= size()), QStringView(m_data + m_size - n, n); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QStringView chopped(qsizetype n) const
+    { return Q_ASSERT10(n >= 0), Q_ASSERT10(n <= size()), QStringView(m_data, m_size - n); }
+
+    Q_DECL_RELAXED_CONSTEXPR void truncate(qsizetype n)
+    { Q_ASSERT(n >= 0); Q_ASSERT(n <= size()); m_size = n; }
+    Q_DECL_RELAXED_CONSTEXPR void chop(qsizetype n)
+    { Q_ASSERT(n >= 0); Q_ASSERT(n <= size()); m_size -= n; }
+
+    Q_REQUIRED_RESULT QStringView trimmed() const Q_DECL_NOTHROW { return QtPrivate::trimmed(*this); }
+
+    Q_REQUIRED_RESULT bool startsWith(QStringView s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW
+    { return QtPrivate::startsWith(*this, s, cs); }
+    Q_REQUIRED_RESULT bool startsWith(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW;
+    Q_REQUIRED_RESULT bool startsWith(QChar c) const Q_DECL_NOTHROW
+    { return !empty() && front() == c; }
+    Q_REQUIRED_RESULT bool startsWith(QChar c, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW
+    { return QtPrivate::startsWith(*this, QStringView(&c, 1), cs); }
+
+    Q_REQUIRED_RESULT bool endsWith(QStringView s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW
+    { return QtPrivate::endsWith(*this, s, cs); }
+    Q_REQUIRED_RESULT bool endsWith(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW;
+    Q_REQUIRED_RESULT bool endsWith(QChar c) const Q_DECL_NOTHROW
+    { return !empty() && back() == c; }
+    Q_REQUIRED_RESULT bool endsWith(QChar c, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW
+    { return QtPrivate::endsWith(*this, QStringView(&c, 1), cs); }
+
+    //
+    // STL compatibility API:
+    //
+    Q_REQUIRED_RESULT const_iterator begin()   const Q_DECL_NOTHROW { return data(); }
+    Q_REQUIRED_RESULT const_iterator end()     const Q_DECL_NOTHROW { return data() + size(); }
+    Q_REQUIRED_RESULT const_iterator cbegin()  const Q_DECL_NOTHROW { return begin(); }
+    Q_REQUIRED_RESULT const_iterator cend()    const Q_DECL_NOTHROW { return end(); }
+    Q_REQUIRED_RESULT const_reverse_iterator rbegin()  const Q_DECL_NOTHROW { return const_reverse_iterator(end()); }
+    Q_REQUIRED_RESULT const_reverse_iterator rend()    const Q_DECL_NOTHROW { return const_reverse_iterator(begin()); }
+    Q_REQUIRED_RESULT const_reverse_iterator crbegin() const Q_DECL_NOTHROW { return rbegin(); }
+    Q_REQUIRED_RESULT const_reverse_iterator crend()   const Q_DECL_NOTHROW { return rend(); }
+
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR bool empty() const Q_DECL_NOTHROW { return size() == 0; }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QChar front() const { return Q_ASSERT10(!empty()), QChar(m_data[0]); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QChar back()  const { return Q_ASSERT10(!empty()), QChar(m_data[m_size - 1]); }
+
+    //
+    // Qt compatibility API:
+    //
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR bool isNull() const Q_DECL_NOTHROW { return !m_data; }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR bool isEmpty() const Q_DECL_NOTHROW { return empty(); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR int length() const /* not nothrow! */
+    { return Q_ASSERT10(int(size()) == size()), int(size()); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QChar first() const { return front(); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QChar last()  const { return back(); }
+
+private:
+    qsizetype m_size;
+    const storage_type *m_data;
+};
+Q_DECLARE_TYPEINFO(QStringView, Q_PRIMITIVE_TYPE);
+
+template <typename QStringLike, typename std::enable_if<
+    std::is_same<QStringLike, QString>::value || std::is_same<QStringLike, QStringRef>::value,
+    bool>::type = true>
+inline QStringView qToStringViewIgnoringNull(const QStringLike &s) Q_DECL_NOTHROW
+{ return QStringView(s.data(), s.size()); }
+
+Q_CORE_EXPORT Q_DECL_PURE_FUNCTION uint qHash(QStringView key, uint seed = 0) Q_DECL_NOTHROW;
+
+#ifndef QT_NO_UNICODE_LITERAL
+# ifndef QT_UNICODE_LITERAL
+#  error "If you change QStringLiteral, please change QStringViewLiteral, too"
+# endif
+# define QStringViewLiteral(str) QStringView(QT_UNICODE_LITERAL(str))
+#endif
+
+// QStringView <> QStringView
+inline bool operator==(QStringView lhs, QStringView rhs) Q_DECL_NOTHROW { return lhs.size() == rhs.size() && QtPrivate::compareStrings(lhs, rhs) == 0; }
+inline bool operator!=(QStringView lhs, QStringView rhs) Q_DECL_NOTHROW { return !(lhs == rhs); }
+inline bool operator< (QStringView lhs, QStringView rhs) Q_DECL_NOTHROW { return QtPrivate::compareStrings(lhs, rhs) <  0; }
+inline bool operator<=(QStringView lhs, QStringView rhs) Q_DECL_NOTHROW { return QtPrivate::compareStrings(lhs, rhs) <= 0; }
+inline bool operator> (QStringView lhs, QStringView rhs) Q_DECL_NOTHROW { return QtPrivate::compareStrings(lhs, rhs) >  0; }
+inline bool operator>=(QStringView lhs, QStringView rhs) Q_DECL_NOTHROW { return QtPrivate::compareStrings(lhs, rhs) >= 0; }
+
+// QStringView <> QChar
+inline bool operator==(QStringView lhs, QChar rhs) Q_DECL_NOTHROW { return lhs == QStringView(&rhs, 1); }
+inline bool operator!=(QStringView lhs, QChar rhs) Q_DECL_NOTHROW { return lhs != QStringView(&rhs, 1); }
+inline bool operator< (QStringView lhs, QChar rhs) Q_DECL_NOTHROW { return lhs <  QStringView(&rhs, 1); }
+inline bool operator<=(QStringView lhs, QChar rhs) Q_DECL_NOTHROW { return lhs <= QStringView(&rhs, 1); }
+inline bool operator> (QStringView lhs, QChar rhs) Q_DECL_NOTHROW { return lhs >  QStringView(&rhs, 1); }
+inline bool operator>=(QStringView lhs, QChar rhs) Q_DECL_NOTHROW { return lhs >= QStringView(&rhs, 1); }
+
+inline bool operator==(QChar lhs, QStringView rhs) Q_DECL_NOTHROW { return QStringView(&lhs, 1) == rhs; }
+inline bool operator!=(QChar lhs, QStringView rhs) Q_DECL_NOTHROW { return QStringView(&lhs, 1) != rhs; }
+inline bool operator< (QChar lhs, QStringView rhs) Q_DECL_NOTHROW { return QStringView(&lhs, 1) <  rhs; }
+inline bool operator<=(QChar lhs, QStringView rhs) Q_DECL_NOTHROW { return QStringView(&lhs, 1) <= rhs; }
+inline bool operator> (QChar lhs, QStringView rhs) Q_DECL_NOTHROW { return QStringView(&lhs, 1) >  rhs; }
+inline bool operator>=(QChar lhs, QStringView rhs) Q_DECL_NOTHROW { return QStringView(&lhs, 1) >= rhs; }
+
+// QStringView <> QLatin1String
+inline bool operator==(QStringView lhs, QLatin1String rhs) Q_DECL_NOTHROW { return lhs.size() == rhs.size() && QtPrivate::compareStrings(lhs, rhs) == 0; }
+inline bool operator!=(QStringView lhs, QLatin1String rhs) Q_DECL_NOTHROW { return !(lhs == rhs); }
+inline bool operator< (QStringView lhs, QLatin1String rhs) Q_DECL_NOTHROW { return QtPrivate::compareStrings(lhs, rhs) <  0; }
+inline bool operator<=(QStringView lhs, QLatin1String rhs) Q_DECL_NOTHROW { return QtPrivate::compareStrings(lhs, rhs) <= 0; }
+inline bool operator> (QStringView lhs, QLatin1String rhs) Q_DECL_NOTHROW { return QtPrivate::compareStrings(lhs, rhs) >  0; }
+inline bool operator>=(QStringView lhs, QLatin1String rhs) Q_DECL_NOTHROW { return QtPrivate::compareStrings(lhs, rhs) >= 0; }
+
+inline bool operator==(QLatin1String lhs, QStringView rhs) Q_DECL_NOTHROW { return lhs.size() == rhs.size() && QtPrivate::compareStrings(lhs, rhs) == 0; }
+inline bool operator!=(QLatin1String lhs, QStringView rhs) Q_DECL_NOTHROW { return !(lhs == rhs); }
+inline bool operator< (QLatin1String lhs, QStringView rhs) Q_DECL_NOTHROW { return QtPrivate::compareStrings(lhs, rhs) <  0; }
+inline bool operator<=(QLatin1String lhs, QStringView rhs) Q_DECL_NOTHROW { return QtPrivate::compareStrings(lhs, rhs) <= 0; }
+inline bool operator> (QLatin1String lhs, QStringView rhs) Q_DECL_NOTHROW { return QtPrivate::compareStrings(lhs, rhs) >  0; }
+inline bool operator>=(QLatin1String lhs, QStringView rhs) Q_DECL_NOTHROW { return QtPrivate::compareStrings(lhs, rhs) >= 0; }
+
+// added by RJVB
+inline QDebug operator << (QDebug d, const QStringView& q)
+{
+    d.nospace() << "QStringView(" << q.toString() << ")";
+    return d.space();
+}
+
+QT_END_NAMESPACE
+
+#endif /* QSTRINGVIEW_H */
diff --git a/qtbase/src/corelib/tools/qunicodetables.cpp b/qtbase/src/corelib/tools/qunicodetables.cpp
index 01fa8b21023a8cfa3f396a01388fb54bca6485b9..17d6cd180c3c3287174acc89607d5a821a8ff682 100644
--- a/qtbase/src/corelib/tools/qunicodetables.cpp
+++ b/qtbase/src/corelib/tools/qunicodetables.cpp
@@ -5746,7 +5746,6 @@ static const unsigned short uc_property_trie[] = {
     2494, 2494, 2494, 2494, 2494, 2494, 2494, 2494,
     2494, 2494, 2494, 2494, 2494, 2494, 2489, 2489
 };
-
 #define GET_PROP_INDEX(ucs4) \
        (ucs4 < 0x11000 \
         ? (uc_property_trie[uc_property_trie[ucs4>>5] + (ucs4 & 0x1f)]) \
@@ -12889,3 +12888,17 @@ enum { NormalizationCorrectionsVersionMax = 7 };
 using namespace QUnicodeTables;
 
 QT_END_NAMESPACE
+
+// RJVB for backported QStringView
+const unsigned short *uc_property_trie_array()
+{
+    return uc_property_trie;
+}
+const Properties *uc_properties_array()
+{
+    return uc_properties;
+}
+const unsigned short *specialCaseMap_array()
+{
+    return specialCaseMap;
+}
diff --git a/qtbase/src/corelib/tools/tools.pri b/qtbase/src/corelib/tools/tools.pri
index bea8e9743527649110f9bc73063c7695b14254f4..9f5d6fa3a6bd5b4b7776de0e257fb04beb19e256 100644
--- a/qtbase/src/corelib/tools/tools.pri
+++ b/qtbase/src/corelib/tools/tools.pri
@@ -57,11 +57,13 @@ HEADERS +=  \
         tools/qsize.h \
         tools/qstack.h \
         tools/qstring.h \
+        tools/qstringalgorithms.h \
         tools/qstringalgorithms_p.h \
         tools/qstringbuilder.h \
         tools/qstringiterator_p.h \
         tools/qstringlist.h \
         tools/qstringmatcher.h \
+        tools/qstringview.h \
         tools/qtextboundaryfinder.h \
         tools/qtimeline.h \
         tools/qtools_p.h \
@@ -71,6 +73,9 @@ HEADERS +=  \
         tools/qvector.h \
         tools/qversionnumber.h
 
+# RJVB: for QStringView; we use qstring.h instead
+# HEADERS +=  \
+#         tools/qstringliteral.h
 
 SOURCES += \
         tools/qarraydata.cpp \
@@ -111,6 +116,10 @@ SOURCES += \
         tools/qvsnprintf.cpp \
         tools/qversionnumber.cpp
 
+# RJVB : backport QStringView
+SOURCES += \
+        tools/qstringview.cpp 
+
 NO_PCH_SOURCES = tools/qstring_compat.cpp
 msvc: NO_PCH_SOURCES += tools/qvector_msvc.cpp
 false: SOURCES += $$NO_PCH_SOURCES # Hack for QtCreator
diff --git a/qtbase/include/QtCore/QStringAlgorithms b/qtbase/include/QtCore/QStringAlgorithms
new file mode 100644
index 00000000..a520c646
--- /dev/null
+++ b/qtbase/include/QtCore/QStringAlgorithms
@@ -0,0 +1 @@
+#include "qstringalgorithms.h"
diff --git a/qtbase/include/QtCore/QStringView b/qtbase/include/QtCore/QStringView
new file mode 100644
index 00000000..022413cc
--- /dev/null
+++ b/qtbase/include/QtCore/QStringView
@@ -0,0 +1 @@
+#include "qstringview.h"
diff --git a/qtbase/include/QtCore/qstringalgorithms.h b/qtbase/include/QtCore/qstringalgorithms.h
new file mode 100644
index 00000000..77a5df53
--- /dev/null
+++ b/qtbase/include/QtCore/qstringalgorithms.h
@@ -0,0 +1 @@
+#include "../../src/corelib/tools/qstringalgorithms.h"
diff --git a/qtbase/include/QtCore/qstringliteral.h b/qtbase/include/QtCore/qstringliteral.h
new file mode 100644
index 00000000..0804f98f
--- /dev/null
+++ b/qtbase/include/QtCore/qstringliteral.h
@@ -0,0 +1 @@
+#include "../../src/corelib/tools/qstringliteral.h"
diff --git a/qtbase/include/QtCore/qstringview.h b/qtbase/include/QtCore/qstringview.h
new file mode 100644
index 00000000..b9364542
--- /dev/null
+++ b/qtbase/include/QtCore/qstringview.h
@@ -0,0 +1 @@
+#include "../../src/corelib/tools/qstringview.h"
