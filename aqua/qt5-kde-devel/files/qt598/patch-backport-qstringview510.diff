diff --git a/qtbase/src/corelib/tools/qstringalgorithms.h b/qtbase/src/corelib/tools/qstringalgorithms.h
new file mode 100644
index 0000000000000000000000000000000000000000..aaa702301ed49db6a1c9a2edbad227a2f57acaa7
--- /dev/null
+++ b/qtbase/src/corelib/tools/qstringalgorithms.h
@@ -0,0 +1,88 @@
+/****************************************************************************
+**
+** Copyright (C) 2017 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Marc Mutz <marc.mutz@kdab.com>
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QSTRINGALGORITHMS_H
+#define QSTRINGALGORITHMS_H
+
+#include <QtCore/qnamespace.h>
+
+#if 0
+#pragma qt_class(QStringAlgorithms)
+#endif
+
+QT_BEGIN_NAMESPACE
+
+class QByteArray;
+class QLatin1String;
+class QStringView;
+template <typename T> class QVector;
+
+namespace QtPrivate {
+
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION qsizetype qustrlen(const ushort *str) Q_DECL_NOTHROW;
+
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION int compareStrings(QStringView   lhs, QStringView   rhs, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION int compareStrings(QStringView   lhs, QLatin1String rhs, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION int compareStrings(QLatin1String lhs, QStringView   rhs, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION int compareStrings(QLatin1String lhs, QLatin1String rhs, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+
+
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool startsWith(QStringView   haystack, QStringView   needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool startsWith(QStringView   haystack, QLatin1String needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool startsWith(QLatin1String haystack, QStringView   needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool startsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool endsWith(QStringView   haystack, QStringView   needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool endsWith(QStringView   haystack, QLatin1String needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool endsWith(QLatin1String haystack, QStringView   needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION bool endsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs = Qt::CaseSensitive) Q_DECL_NOTHROW;
+
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION QStringView   trimmed(QStringView   s) Q_DECL_NOTHROW;
+Q_REQUIRED_RESULT Q_CORE_EXPORT Q_DECL_PURE_FUNCTION QLatin1String trimmed(QLatin1String s) Q_DECL_NOTHROW;
+
+Q_REQUIRED_RESULT Q_CORE_EXPORT QByteArray convertToLatin1(QStringView str);
+Q_REQUIRED_RESULT Q_CORE_EXPORT QByteArray convertToUtf8(QStringView str);
+Q_REQUIRED_RESULT Q_CORE_EXPORT QByteArray convertToLocal8Bit(QStringView str);
+Q_REQUIRED_RESULT Q_CORE_EXPORT QVector<uint> convertToUcs4(QStringView str);
+
+} // namespace QtPRivate
+
+QT_END_NAMESPACE
+
+#endif // QSTRINGALGORTIHMS_H
diff --git a/qtbase/src/corelib/tools/qstringliteral.h b/qtbase/src/corelib/tools/qstringliteral.h
new file mode 100644
index 0000000000000000000000000000000000000000..6a1a74a80e61222fad9bcdcc65f85308bc26fd32
--- /dev/null
+++ b/qtbase/src/corelib/tools/qstringliteral.h
@@ -0,0 +1,128 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Copyright (C) 2016 Intel Corporation.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QSTRINGLITERAL_H
+#define QSTRINGLITERAL_H
+
+#include <QtCore/qarraydata.h>
+
+#if 0
+#pragma qt_class(QStringLiteral)
+#endif
+
+QT_BEGIN_NAMESPACE
+
+typedef QTypedArrayData<ushort> QStringData;
+
+#if defined(Q_OS_WIN) && !defined(Q_COMPILER_UNICODE_STRINGS)
+// fall back to wchar_t if the a Windows compiler does not
+// support Unicode string literals, assuming wchar_t is 2 bytes
+// on that platform (sanity-checked by static_assert further below)
+
+#if defined(Q_CC_MSVC)
+#    define QT_UNICODE_LITERAL_II(str) L##str
+#else
+#    define QT_UNICODE_LITERAL_II(str) L"" str
+#endif
+typedef wchar_t qunicodechar;
+
+#else
+// all our supported compilers support Unicode string literals,
+// even if their Q_COMPILER_UNICODE_STRING has been revoked due
+// to lacking stdlib support. But QStringLiteral only needs the
+// core language feature, so just use u"" here unconditionally:
+
+#define QT_UNICODE_LITERAL_II(str) u"" str
+typedef char16_t qunicodechar;
+
+#endif
+
+Q_STATIC_ASSERT_X(sizeof(qunicodechar) == 2,
+        "qunicodechar must typedef an integral type of size 2");
+
+#define QT_UNICODE_LITERAL(str) QT_UNICODE_LITERAL_II(str)
+#define QStringLiteral(str) \
+    ([]() Q_DECL_NOEXCEPT -> QString { \
+        enum { Size = sizeof(QT_UNICODE_LITERAL(str))/2 - 1 }; \
+        static const QStaticStringData<Size> qstring_literal = { \
+            Q_STATIC_STRING_DATA_HEADER_INITIALIZER(Size), \
+            QT_UNICODE_LITERAL(str) }; \
+        QStringDataPtr holder = { qstring_literal.data_ptr() }; \
+        const QString qstring_literal_temp(holder); \
+        return qstring_literal_temp; \
+    }()) \
+    /**/
+
+#define Q_STATIC_STRING_DATA_HEADER_INITIALIZER_WITH_OFFSET(size, offset) \
+    { Q_REFCOUNT_INITIALIZE_STATIC, size, 0, 0, offset } \
+    /**/
+
+#define Q_STATIC_STRING_DATA_HEADER_INITIALIZER(size) \
+    Q_STATIC_STRING_DATA_HEADER_INITIALIZER_WITH_OFFSET(size, sizeof(QStringData)) \
+    /**/
+
+#ifndef QT_NO_UNICODE_LITERAL
+# ifndef QT_UNICODE_LITERAL
+#  error "If you change QStringLiteral, please change QStringViewLiteral, too"
+# endif
+# define QStringViewLiteral(str) QStringView(QT_UNICODE_LITERAL(str))
+#endif
+
+template <int N>
+struct QStaticStringData
+{
+    QArrayData str;
+    qunicodechar data[N + 1];
+
+    QStringData *data_ptr() const
+    {
+        Q_ASSERT(str.ref.isStatic());
+        return const_cast<QStringData *>(static_cast<const QStringData*>(&str));
+    }
+};
+
+struct QStringDataPtr
+{
+    QStringData *ptr;
+};
+
+QT_END_NAMESPACE
+
+#endif // QSTRINGLITERAL_H
diff --git a/qtbase/src/corelib/tools/qstringview.cpp b/qtbase/src/corelib/tools/qstringview.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..6321427a2d74b7b514988f749ba6ab353c381c7b
--- /dev/null
+++ b/qtbase/src/corelib/tools/qstringview.cpp
@@ -0,0 +1,775 @@
+/****************************************************************************
+**
+** Copyright (C) 2017 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Marc Mutz <marc.mutz@kdab.com>
+** Contact: http://www.qt.io/licensing/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qstringview.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QStringView
+    \inmodule QtCore
+    \since 5.10
+    \brief The QStringView class provides a unified view on UTF-16 strings with a read-only subset of the QString API.
+    \reentrant
+    \ingroup tools
+    \ingroup string-processing
+
+    A QStringView references a contiguous portion of a UTF-16 string it does
+    not own. It acts as an interface type to all kinds of UTF-16 string,
+    without the need to construct a QString first.
+
+    The UTF-16 string may be represented as an array (or an array-compatible
+    data-structure such as QString,
+    std::basic_string, etc.) of QChar, \c ushort, \c char16_t (on compilers that
+    support C++11 Unicode strings) or (on platforms, such as Windows,
+    where it is a 16-bit type) \c wchar_t.
+
+    QStringView is designed as an interface type; its main use-case is
+    as a function parameter type. When QStringViews are used as automatic
+    variables or data members, care must be taken to ensure that the referenced
+    string data (for example, owned by a QString) outlives the QStringView on all code paths,
+    lest the string view ends up referencing deleted data.
+
+    When used as an interface type, QStringView allows a single function to accept
+    a wide variety of UTF-16 string data sources. One function accepting QStringView
+    thus replaces three function overloads (taking QString, QStringRef, and
+    \c{(const QChar*, int)}), while at the same time enabling even more string data
+    sources to be passed to the function, such as \c{u"Hello World"}, a \c char16_t
+    string literal.
+
+    QStringViews should be passed by value, not by reference-to-const:
+    \code
+    void myfun1(QStringView sv);        // preferred
+    void myfun2(const QStringView &sv); // compiles and works, but slower
+    \endcode
+
+    If you want to give your users maximum freedom in what strings they can pass
+    to your function, accompany the QStringView overload with overloads for
+
+    \list
+        \li \e QChar: this overload can delegate to the QStringView version:
+            \code
+            void fun(QChar ch) { fun(QStringView(&ch, 1)); }
+            \endcode
+            even though, for technical reasons, QStringView cannot provide a
+            QChar constructor by itself.
+        \li \e QString: if you store an unmodified copy of the string and thus would
+            like to take advantage of QString's implicit sharing.
+        \li QLatin1String: if you can implement the function without converting the
+            QLatin1String to UTF-16 first; users expect a function overloaded on
+            QLatin1String to perform strictly less memory allocations than the
+            semantically equivalent call of the QStringView version, involving
+            construction of a QString from the QLatin1String.
+    \endlist
+
+    QStringView can also be used as the return value of a function. If you call a
+    function returning QStringView, take extra care to not keep the QStringView
+    around longer than the function promises to keep the referenced string data alive.
+    If in doubt, obtain a strong reference to the data by calling toString() to convert
+    the QStringView into a QString.
+
+    QStringView is a \e{Literal Type}, but since it stores data as \c{char16_t}, iteration
+    is not \c constexpr (casts from \c{const char16_t*} to \c{const QChar*}, which is not
+    allowed in \c constexpr functions). You can use an indexed loop and/or utf16() in
+    \c constexpr contexts instead.
+
+    \note We strongly discourage the use of QList<QStringView>,
+    because QList is a very inefficient container for QStringViews (it would heap-allocate
+    every element). Use QVector (or std::vector) to hold QStringViews instead.
+
+    \sa QString, QStringRef
+*/
+
+/*!
+    \typedef QStringView::value_type
+
+    Alias for \c{const QChar}. Provided for compatibility with the STL.
+*/
+
+/*!
+    \typedef QStringView::difference_type
+
+    Alias for \c{std::ptrdiff_t}. Provided for compatibility with the STL.
+*/
+
+/*!
+    \typedef QStringView::size_type
+
+    Alias for qsizetype. Provided for compatibility with the STL.
+
+    Unlike other Qt classes, QStringView uses qsizetype as its \c size_type, to allow
+    accepting data from \c{std::basic_string} without truncation. The Qt API functions,
+    for example length(), return \c int, while the STL-compatible functions, for example
+    size(), return \c size_type.
+*/
+
+/*!
+    \typedef QStringView::reference
+
+    Alias for \c{value_type &}. Provided for compatibility with the STL.
+
+    QStringView does not support mutable references, so this is the same
+    as const_reference.
+*/
+
+/*!
+    \typedef QStringView::const_reference
+
+    Alias for \c{value_type &}. Provided for compatibility with the STL.
+*/
+
+/*!
+    \typedef QStringView::pointer
+
+    Alias for \c{value_type *}. Provided for compatibility with the STL.
+
+    QStringView does not support mutable pointers, so this is the same
+    as const_pointer.
+*/
+
+/*!
+    \typedef QStringView::const_pointer
+
+    Alias for \c{value_type *}. Provided for compatibility with the STL.
+*/
+
+/*!
+    \typedef QStringView::iterator
+
+    This typedef provides an STL-style const iterator for QStringView.
+
+    QStringView does not support mutable iterators, so this is the same
+    as const_iterator.
+
+    \sa const_iterator, reverse_iterator
+*/
+
+/*!
+    \typedef QStringView::const_iterator
+
+    This typedef provides an STL-style const iterator for QStringView.
+
+    \sa iterator, const_reverse_iterator
+*/
+
+/*!
+    \typedef QStringView::reverse_iterator
+
+    This typedef provides an STL-style const reverse iterator for QStringView.
+
+    QStringView does not support mutable reverse iterators, so this is the
+    same as const_reverse_iterator.
+
+    \sa const_reverse_iterator, iterator
+*/
+
+/*!
+    \typedef QStringView::const_reverse_iterator
+
+    This typedef provides an STL-style const reverse iterator for QStringView.
+
+    \sa reverse_iterator, const_iterator
+*/
+
+/*!
+    \fn QStringView::QStringView()
+
+    Constructs a null string view.
+
+    \sa isNull()
+*/
+
+/*!
+    \fn QStringView::QStringView(std::nullptr_t)
+
+    Constructs a null string view.
+
+    \sa isNull()
+*/
+
+/*!
+    \fn QStringView::QStringView(const Char *str, qsizetype len)
+
+    Constructs a string view on \a str with length \a len.
+
+    The range \c{[str,len)} must remain valid for the lifetime of this string view object.
+
+    Passing \c nullptr as \a str is safe if \a len is 0, too, and results in a null string view.
+
+    The behavior is undefined if \a len is negative or, when positive, if \a str is \c nullptr.
+
+    This constructor only participates in overload resolution if \c Char is a compatible
+    character type. The compatible character types are: \c QChar, \c ushort, \c char16_t and
+    (on platforms, such as Windows, where it is a 16-bit type) \c wchar_t.
+*/
+
+/*!
+    \fn QStringView::QStringView(const Char *first, const Char *last)
+
+    Constructs a string view on \a first with length (\a last - \a first).
+
+    The range \c{[first,last)} must remain valid for the lifetime of
+    this string view object.
+
+    Passing \c nullptr as \a first is safe if \a last is nullptr, too,
+    and results in a null string view.
+
+    The behavior is undefined if \a last precedes \a first, or \a first
+    is \c nullptr and \a last is not.
+
+    This constructor only participates in overload resolution if \c Char
+    is a compatible character type. The compatible character types
+    are: \c QChar, \c ushort, \c char16_t and (on platforms, such as
+    Windows, where it is a 16-bit type) \c wchar_t.
+*/
+
+/*!
+    \fn QStringView::QStringView(const Char *str)
+
+    Constructs a string view on \a str. The length is determined
+    by scanning for the first \c{Char(0)}.
+
+    \a str must remain valid for the lifetime of this string view object.
+
+    Passing \c nullptr as \a str is safe and results in a null string view.
+
+    This constructor only participates in overload resolution if \a
+    str is not an array and if \c Char is a compatible character
+    type. The compatible character types are: \c QChar, \c ushort, \c
+    char16_t and (on platforms, such as Windows, where it is a 16-bit
+    type) \c wchar_t.
+*/
+
+/*!
+    \fn QStringView::QStringView(const Char (&string)[N])
+
+    Constructs a string view on the character string literal \a string.
+    The length is set to \c{N-1}, excluding the trailing \{Char(0)}.
+    If you need the full array, use the constructor from pointer and
+    size instead:
+
+    \code
+    auto sv = QStringView(array, std::size(array)); // using C++17 std::size()
+    \endcode
+
+    \a string must remain valid for the lifetime of this string view
+    object.
+
+    This constructor only participates in overload resolution if \a
+    string is an actual array and \c Char is a compatible character
+    type. The compatible character types are: \c QChar, \c ushort, \c
+    char16_t and (on platforms, such as Windows, where it is a 16-bit
+    type) \c wchar_t.
+*/
+
+/*!
+    \fn QStringView::QStringView(const QString &str)
+
+    Constructs a string view on \a str.
+
+    \c{str.data()} must remain valid for the lifetime of this string view object.
+
+    The string view will be null if and only if \c{str.isNull()}.
+*/
+
+/*!
+    \fn QStringView::QStringView(const QStringRef &str)
+
+    Constructs a string view on \a str.
+
+    \c{str.data()} must remain valid for the lifetime of this string view object.
+
+    The string view will be null if and only if \c{str.isNull()}.
+*/
+
+/*!
+    \fn QStringView::QStringView(const StdBasicString &str)
+
+    Constructs a string view on \a str. The length is taken from \c{str.size()}.
+
+    \c{str.data()} must remain valid for the lifetime of this string view object.
+
+    This constructor only participates in overload resolution if \c StdBasicString is an
+    instantiation of \c std::basic_string with a compatible character type. The
+    compatible character types are: \c QChar, \c ushort, \c char16_t and
+    (on platforms, such as Windows, where it is a 16-bit type) \c wchar_t.
+
+    The string view will be empty if and only if \c{str.empty()}. It is unspecified
+    whether this constructor can result in a null string view (\c{str.data()} would
+    have to return \c nullptr for this).
+
+    \sa isNull(), isEmpty()
+*/
+
+/*!
+    \fn QString QStringView::toString() const
+
+    Returns a deep copy of this string view's data as a QString.
+
+    The return value will be the null QString if and only if this string view is null.
+
+    \warning QStringView can store strings with more than 2\sup{30} characters
+    while QString cannot. Calling this function on a string view for which size()
+    returns a value greater than \c{INT_MAX / 2} constitutes undefined behavior.
+*/
+
+/*!
+    \fn const QChar *QStringView::data() const
+
+    Returns a const pointer to the first character in the string.
+
+    \note The character array represented by the return value is \e not null-terminated.
+
+    \sa begin(), end(), utf16()
+*/
+
+/*!
+    \fn const storage_type *QStringView::utf16() const
+
+    Returns a const pointer to the first character in the string.
+
+    \c{storage_type} is \c{char16_t}, except on MSVC 2013 (which lacks \c char16_t support),
+    where it is \c{wchar_t} instead.
+
+    \note The character array represented by the return value is \e not null-terminated.
+
+    \sa begin(), end(), data()
+*/
+
+/*!
+    \fn QStringView::const_iterator QStringView::begin() const
+
+    Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first character in
+    the string.
+
+    This function is provided for STL compatibility.
+
+    \sa end(), cbegin(), rbegin(), data()
+*/
+
+/*!
+    \fn QStringView::const_iterator QStringView::cbegin() const
+
+    Same as begin().
+
+    This function is provided for STL compatibility.
+
+    \sa cend(), begin(), crbegin(), data()
+*/
+
+/*!
+    \fn QStringView::const_iterator QStringView::end() const
+
+    Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
+    character after the last character in the list.
+
+    This function is provided for STL compatibility.
+
+    \sa begin(), cend(), rend()
+*/
+
+/*! \fn QStringView::const_iterator QStringView::cend() const
+
+    Same as end().
+
+    This function is provided for STL compatibility.
+
+    \sa cbegin(), end(), crend()
+*/
+
+/*!
+    \fn QStringView::const_reverse_iterator QStringView::rbegin() const
+
+    Returns a const \l{STL-style iterators}{STL-style} reverse iterator pointing to the first
+    character in the string, in reverse order.
+
+    This function is provided for STL compatibility.
+
+    \sa rend(), crbegin(), begin()
+*/
+
+/*!
+    \fn QStringView::const_reverse_iterator QStringView::crbegin() const
+
+    Same as rbegin().
+
+    This function is provided for STL compatibility.
+
+    \sa crend(), rbegin(), cbegin()
+*/
+
+/*!
+    \fn QStringView::const_reverse_iterator QStringView::rend() const
+
+    Returns a \l{STL-style iterators}{STL-style} reverse iterator pointing to one past
+    the last character in the string, in reverse order.
+
+    This function is provided for STL compatibility.
+
+    \sa rbegin(), crend(), end()
+*/
+
+/*!
+    \fn QStringView::const_reverse_iterator QStringView::crend() const
+
+    Same as rend().
+
+    This function is provided for STL compatibility.
+
+    \sa crbegin(), rend(), cend()
+*/
+
+/*!
+    \fn bool QStringView::empty() const
+
+    Returns whether this string view is empty - that is, whether \c{size() == 0}.
+
+    This function is provided for STL compatibility.
+
+    \sa isEmpty(), isNull(), size(), length()
+*/
+
+/*!
+    \fn bool QStringView::isEmpty() const
+
+    Returns whether this string view is empty - that is, whether \c{size() == 0}.
+
+    This function is provided for compatibility with other Qt containers.
+
+    \sa empty(), isNull(), size(), length()
+*/
+
+/*!
+    \fn bool QStringView::isNull() const
+
+    Returns whether this string view is null - that is, whether \c{data() == nullptr}.
+
+    This functions is provided for compatibility with other Qt containers.
+
+    \sa empty(), isEmpty(), size(), length()
+*/
+
+/*!
+    \fn qsizetype QStringView::size() const
+
+    Returns the size of this string view, in UTF-16 code points (that is,
+    surrogate pairs count as two for the purposes of this function, the same
+    as in QString and QStringRef).
+
+    \sa empty(), isEmpty(), isNull(), length()
+*/
+
+/*!
+    \fn int QStringView::length() const
+
+    Same as size(), except returns the result as an \c int.
+
+    This function is provided for compatibility with other Qt containers.
+
+    \warning QStringView can represent strings with more than 2\sup{31} characters.
+    Calling this function on a string view for which size() returns a value greater
+    than \c{INT_MAX} constitutes undefined behavior.
+
+    \sa empty(), isEmpty(), isNull(), size()
+*/
+
+/*!
+    \fn QChar QStringView::operator[](qsizetype n) const
+
+    Returns the character at position \a n in this string view.
+
+    The behavior is undefined if \a n is negative or not less than size().
+
+    \sa at(), front(), back()
+*/
+
+/*!
+    \fn QChar QStringView::at(qsizetype n) const
+
+    Returns the character at position \a n in this string view.
+
+    The behavior is undefined if \a n is negative or not less than size().
+
+    \sa operator[](), front(), back()
+*/
+
+/*!
+    \fn QChar QStringView::front() const
+
+    Returns the first character in the string. Same as first().
+
+    This function is provided for STL compatibility.
+
+    \warning Calling this function on an empty string view constitutes
+    undefined behavior.
+
+    \sa back(), first(), last()
+*/
+
+/*!
+    \fn QChar QStringView::back() const
+
+    Returns the last character in the string. Same as last().
+
+    This function is provided for STL compatibility.
+
+    \warning Calling this function on an empty string view constitutes
+    undefined behavior.
+
+    \sa front(), first(), last()
+*/
+
+/*!
+    \fn QChar QStringView::first() const
+
+    Returns the first character in the string. Same as front().
+
+    This function is provided for compatibility with other Qt containers.
+
+    \warning Calling this function on an empty string view constitutes
+    undefined behavior.
+
+    \sa front(), back(), last()
+*/
+
+/*!
+    \fn QChar QStringView::last() const
+
+    Returns the last character in the string. Same as back().
+
+    This function is provided for compatibility with other Qt containers.
+
+    \warning Calling this function on an empty string view constitutes
+    undefined behavior.
+
+    \sa back(), front(), first()
+*/
+
+/*!
+    \fn QStringView QStringView::mid(qsizetype start) const
+
+    Returns the substring starting at position \a start in this object,
+    and extending to the end of the string.
+
+    \note The behavior is undefined when \a start < 0 or \a start > size().
+
+    \sa left(), right(), chopped(), chop(), truncate()
+*/
+
+/*!
+    \fn QStringView QStringView::mid(qsizetype start, qsizetype length) const
+    \overload
+
+    Returns the substring of length \a length starting at position
+    \a start in this object.
+
+    \note The behavior is undefined when \a start < 0, \a length < 0,
+    or \a start + \a length > size().
+
+    \sa left(), right(), chopped(), chop(), truncate()
+*/
+
+/*!
+    \fn QStringView QStringView::left(qsizetype length) const
+
+    Returns the substring of length \a length starting at position
+    0 in this object.
+
+    \note The behavior is undefined when \a length < 0 or \a length > size().
+
+    \sa mid(), right(), chopped(), chop(), truncate()
+*/
+
+/*!
+    \fn QStringView QStringView::right(qsizetype length) const
+
+    Returns the substring of length \a length starting at position
+    size() - \a length in this object.
+
+    \note The behavior is undefined when \a length < 0 or \a length > size().
+
+    \sa mid(), left(), chopped(), chop(), truncate()
+*/
+
+/*!
+    \fn QStringView QStringView::chopped(qsizetype length) const
+
+    Returns the substring of length size() - \a length starting at the
+    beginning of this object.
+
+    Same as \c{left(size() - length)}.
+
+    \note The behavior is undefined when \a length < 0 or \a length > size().
+
+    \sa mid(), left(), right(), chop(), truncate()
+*/
+
+/*!
+    \fn void QStringView::truncate(qsizetype length)
+
+    Truncates this string view to length \a length.
+
+    Same as \c{*this = left(length)}.
+
+    \note The behavior is undefined when \a length < 0 or \a length > size().
+
+    \sa mid(), left(), right(), chopped(), chop()
+*/
+
+/*!
+    \fn void QStringView::chop(qsizetype length)
+
+    Truncates this string view by \a length characters.
+
+    Same as \c{*this = left(size() - length)}.
+
+    \note The behavior is undefined when \a length < 0 or \a length > size().
+
+    \sa mid(), left(), right(), chopped(), truncate()
+*/
+
+/*!
+    \fn QStringView QStringView::trimmed() const
+
+    Strips leading and trailing whitespace and returns the result.
+
+    Whitespace means any character for which QChar::isSpace() returns
+    \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
+    '\\f', '\\r', and ' '.
+*/
+
+/*!
+    \fn bool QStringView::startsWith(QStringView str, Qt::CaseSensitivity cs) const
+    \fn bool QStringView::startsWith(QLatin1String l1, Qt::CaseSensitivity cs) const
+    \fn bool QStringView::startsWith(QChar ch) const
+    \fn bool QStringView::startsWith(QChar ch, Qt::CaseSensitivity cs) const
+
+    Returns \c true if this string-view starts with string-view \a str,
+    Latin-1 string \a l1, or character \a ch, respectively;
+    otherwise returns \c false.
+
+    If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
+    otherwise the search is case-insensitive.
+
+    \sa endsWith()
+*/
+
+/*!
+    \fn bool QStringView::endsWith(QStringView str, Qt::CaseSensitivity cs) const
+    \fn bool QStringView::endsWith(QLatin1String l1, Qt::CaseSensitivity cs) const
+    \fn bool QStringView::endsWith(QChar ch) const
+    \fn bool QStringView::endsWith(QChar ch, Qt::CaseSensitivity cs) const
+
+    Returns \c true if this string-view ends with string-view \a str,
+    Latin-1 string \a l1, or character \a ch, respectively;
+    otherwise returns \c false.
+
+    If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
+    otherwise the search is case-insensitive.
+
+    \sa startsWith()
+*/
+
+/*!
+    \fn QByteArray QStringView::toLatin1() const
+
+    Returns a Latin-1 representation of the string as a QByteArray.
+
+    The behavior is undefined if the string contains non-Latin1 characters.
+
+    \sa toUtf8(), toLocal8Bit(), QTextCodec, qConvertToLatin1()
+*/
+
+/*!
+    \fn QByteArray QStringView::toLocal8Bit() const
+
+    Returns a local 8-bit representation of the string as a QByteArray.
+
+    QTextCodec::codecForLocale() is used to perform the conversion from
+    Unicode. If the locale's encoding could not be determined, this function
+    does the same as toLatin1().
+
+    The behavior is undefined if the string contains characters not
+    supported by the locale's 8-bit encoding.
+
+    \sa toLatin1(), toUtf8(), QTextCodec
+*/
+
+/*!
+    \fn QByteArray QStringView::toUtf8() const
+
+    Returns a UTF-8 representation of the string as a QByteArray.
+
+    UTF-8 is a Unicode codec and can represent all characters in a Unicode
+    string like QString.
+
+    \sa toLatin1(), toLocal8Bit(), QTextCodec, qConvertToUtf8()
+*/
+
+/*!
+    \fn QVector<uint> QStringView::toUcs4() const
+
+    Returns a UCS-4/UTF-32 representation of the string as a QVector<uint>.
+
+    UCS-4 is a Unicode codec and therefore it is lossless. All characters from
+    this string will be encoded in UCS-4. Any invalid sequence of code units in
+    this string is replaced by the Unicode replacement character
+    (QChar::ReplacementCharacter, which corresponds to \c{U+FFFD}).
+
+    The returned vector is not 0-terminated.
+
+    \sa toUtf8(), toLatin1(), toLocal8Bit(), QTextCodec
+*/
+
+/*!
+    \fn qToStringViewIgnoringNull(const QStringLike &s);
+    \since 5.10
+    \internal
+
+    Convert \a s to a QStringView ignoring \c{s.isNull()}.
+
+    Returns a string-view that references \a{s}' data, but is never null.
+
+    This is a faster way to convert a QString or QStringRef to a QStringView,
+    if null QStrings can legitimately be treated as empty ones.
+
+    \sa QString::isNull(), QStringRef::isNull(), QStringView
+*/
+
+QT_END_NAMESPACE
diff --git a/qtbase/src/corelib/tools/qstringview.h b/qtbase/src/corelib/tools/qstringview.h
new file mode 100644
index 0000000000000000000000000000000000000000..6f990196486020d2a93e4418a7b987ef31736d52
--- /dev/null
+++ b/qtbase/src/corelib/tools/qstringview.h
@@ -0,0 +1,317 @@
+/****************************************************************************
+**
+** Copyright (C) 2017 Klarälvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Marc Mutz <marc.mutz@kdab.com>
+** Contact: http://www.qt.io/licensing/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifndef QSTRINGVIEW_H
+#define QSTRINGVIEW_H
+
+#ifndef QT_STRINGVIEW_LEVEL
+#  define QT_STRINGVIEW_LEVEL 1
+#endif
+
+#include <QtCore/qchar.h>
+#include <QtCore/qbytearray.h>
+// RJVB : include qstring.h instead of qstringliteral.h
+#include <QtCore/qstring.h>
+#include <QtCore/qstringalgorithms.h>
+
+#include <string>
+
+#if !defined(Q_ASSERT10)
+#  if defined(QT_NO_DEBUG) && !defined(QT_FORCE_ASSERTS)
+#    define Q_ASSERT10(cond) static_cast<void>(false && (cond))
+#  else
+#    define Q_ASSERT10(cond) ((cond) ? static_cast<void>(0) : qt_assert(#cond, __FILE__, __LINE__))
+#  endif
+#endif
+
+QT_BEGIN_NAMESPACE
+
+class QString;
+class QStringRef;
+
+namespace QtPrivate {
+template <typename Char>
+struct IsCompatibleCharTypeHelper
+    : std::integral_constant<bool,
+                             std::is_same<Char, QChar>::value ||
+                             std::is_same<Char, ushort>::value ||
+#if defined(Q_COMPILER_UNICODE_STRINGS)
+                             std::is_same<Char, char16_t>::value ||
+#endif
+                             (std::is_same<Char, wchar_t>::value && sizeof(wchar_t) == sizeof(QChar))> {};
+template <typename Char>
+struct IsCompatibleCharType
+    : IsCompatibleCharTypeHelper<typename std::remove_cv<typename std::remove_reference<Char>::type>::type> {};
+
+template <typename Array>
+struct IsCompatibleArrayHelper : std::false_type {};
+template <typename Char, size_t N>
+struct IsCompatibleArrayHelper<Char[N]>
+    : IsCompatibleCharType<Char> {};
+template <typename Array>
+struct IsCompatibleArray
+    : IsCompatibleArrayHelper<typename std::remove_cv<typename std::remove_reference<Array>::type>::type> {};
+
+template <typename Pointer>
+struct IsCompatiblePointerHelper : std::false_type {};
+template <typename Char>
+struct IsCompatiblePointerHelper<Char*>
+    : IsCompatibleCharType<Char> {};
+template <typename Pointer>
+struct IsCompatiblePointer
+    : IsCompatiblePointerHelper<typename std::remove_cv<typename std::remove_reference<Pointer>::type>::type> {};
+
+template <typename T>
+struct IsCompatibleStdBasicStringHelper : std::false_type {};
+template <typename Char, typename...Args>
+struct IsCompatibleStdBasicStringHelper<std::basic_string<Char, Args...> >
+    : IsCompatibleCharType<Char> {};
+
+template <typename T>
+struct IsCompatibleStdBasicString
+    : IsCompatibleStdBasicStringHelper<
+        typename std::remove_cv<typename std::remove_reference<T>::type>::type
+      > {};
+
+} // namespace QtPrivate
+
+class QStringView
+{
+public:
+#if defined(Q_OS_WIN) && !defined(Q_COMPILER_UNICODE_STRINGS)
+    typedef wchar_t storage_type;
+#else
+    typedef char16_t storage_type;
+#endif
+    typedef const QChar value_type;
+    typedef std::ptrdiff_t difference_type;
+    typedef qsizetype size_type;
+    typedef value_type &reference;
+    typedef value_type &const_reference;
+    typedef value_type *pointer;
+    typedef value_type *const_pointer;
+
+    typedef pointer iterator;
+    typedef const_pointer const_iterator;
+    typedef std::reverse_iterator<iterator> reverse_iterator;
+    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
+
+private:
+    template <typename Char>
+    using if_compatible_char = typename std::enable_if<QtPrivate::IsCompatibleCharType<Char>::value, bool>::type;
+
+    template <typename Array>
+    using if_compatible_array = typename std::enable_if<QtPrivate::IsCompatibleArray<Array>::value, bool>::type;
+
+    template <typename Pointer>
+    using if_compatible_pointer = typename std::enable_if<QtPrivate::IsCompatiblePointer<Pointer>::value, bool>::type;
+
+    template <typename T>
+    using if_compatible_string = typename std::enable_if<QtPrivate::IsCompatibleStdBasicString<T>::value, bool>::type;
+
+    template <typename T>
+    using if_compatible_qstring_like = typename std::enable_if<std::is_same<T, QString>::value || std::is_same<T, QStringRef>::value, bool>::type;
+
+    template <typename Char, size_t N>
+    static Q_DECL_CONSTEXPR qsizetype lengthHelperArray(const Char (&)[N]) Q_DECL_NOTHROW
+    {
+        return qsizetype(N - 1);
+    }
+
+    template <typename Char>
+    static qsizetype lengthHelperPointer(const Char *str) Q_DECL_NOTHROW
+    {
+#if defined(Q_CC_GNU) && !defined(Q_CC_CLANG) && !defined(Q_CC_INTEL)
+        if (__builtin_constant_p(*str)) {
+            qsizetype result = 0;
+            while (*str++)
+                ++result;
+            return result;
+        }
+#endif
+        return QtPrivate::qustrlen(reinterpret_cast<const ushort *>(str));
+    }
+    static qsizetype lengthHelperPointer(const QChar *str) Q_DECL_NOTHROW
+    {
+        return QtPrivate::qustrlen(reinterpret_cast<const ushort *>(str));
+    }
+
+    template <typename Char>
+    static const storage_type *castHelper(const Char *str) Q_DECL_NOTHROW
+    { return reinterpret_cast<const storage_type*>(str); }
+    static Q_DECL_CONSTEXPR const storage_type *castHelper(const storage_type *str) Q_DECL_NOTHROW
+    { return str; }
+
+public:
+    Q_DECL_CONSTEXPR QStringView() Q_DECL_NOTHROW
+        : m_size(0), m_data(nullptr) {}
+    Q_DECL_CONSTEXPR QStringView(std::nullptr_t) Q_DECL_NOTHROW
+        : QStringView() {}
+
+    template <typename Char, if_compatible_char<Char> = true>
+    Q_DECL_CONSTEXPR QStringView(const Char *str, qsizetype len)
+        : m_size((Q_ASSERT10(len >= 0), Q_ASSERT10(str || !len), len)),
+          m_data(castHelper(str)) {}
+
+    template <typename Char, if_compatible_char<Char> = true>
+    Q_DECL_CONSTEXPR QStringView(const Char *f, const Char *l)
+        : QStringView(f, l - f) {}
+
+#ifdef Q_QDOC
+    template <typename Char, size_t N>
+    Q_DECL_CONSTEXPR QStringView(const Char (&array)[N]) Q_DECL_NOTHROW;
+
+    template <typename Char>
+    Q_DECL_CONSTEXPR QStringView(const Char *str) Q_DECL_NOTHROW;
+#else
+    template <typename Array, if_compatible_array<Array> = true>
+    Q_DECL_CONSTEXPR QStringView(const Array &str) Q_DECL_NOTHROW
+        : QStringView(str, lengthHelperArray(str)) {}
+
+    template <typename Pointer, if_compatible_pointer<Pointer> = true>
+    Q_DECL_CONSTEXPR QStringView(const Pointer &str) Q_DECL_NOTHROW
+        : QStringView(str, str ? lengthHelperPointer(str) : 0) {}
+#endif
+
+#ifdef Q_QDOC
+    QStringView(const QString &str) Q_DECL_NOTHROW;
+    QStringView(const QStringRef &str) Q_DECL_NOTHROW;
+#else
+    template <typename String, if_compatible_qstring_like<String> = true>
+    QStringView(const String &str) Q_DECL_NOTHROW
+        : QStringView(str.isNull() ? nullptr : str.data(), qsizetype(str.size())) {}
+#endif
+
+    template <typename StdBasicString, if_compatible_string<StdBasicString> = true>
+    QStringView(const StdBasicString &str) Q_DECL_NOTHROW
+        : QStringView(str.data(), qsizetype(str.size())) {}
+
+    Q_REQUIRED_RESULT inline QString toString() const; // defined in qstring.h
+
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR qsizetype size() const Q_DECL_NOTHROW { return m_size; }
+    Q_REQUIRED_RESULT const_pointer data() const Q_DECL_NOTHROW { return reinterpret_cast<const_pointer>(m_data); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR const storage_type *utf16() const Q_DECL_NOTHROW { return m_data; }
+
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QChar operator[](qsizetype n) const
+    { return Q_ASSERT10(n >= 0), Q_ASSERT10(n < size()), QChar(m_data[n]); }
+
+    //
+    // QString API
+    //
+
+    Q_REQUIRED_RESULT QByteArray toLatin1() const { return QtPrivate::convertToLatin1(*this); }
+    Q_REQUIRED_RESULT QByteArray toUtf8() const { return QtPrivate::convertToUtf8(*this); }
+    Q_REQUIRED_RESULT QByteArray toLocal8Bit() const { return QtPrivate::convertToLocal8Bit(*this); }
+    Q_REQUIRED_RESULT inline QVector<uint> toUcs4() const; // defined in qvector.h
+
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QChar at(qsizetype n) const { return (*this)[n]; }
+
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QStringView mid(qsizetype pos) const
+    { return Q_ASSERT10(pos >= 0), Q_ASSERT10(pos <= size()), QStringView(m_data + pos, m_size - pos); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QStringView mid(qsizetype pos, qsizetype n) const
+    { return Q_ASSERT10(pos >= 0), Q_ASSERT10(n >= 0), Q_ASSERT10(pos + n <= size()), QStringView(m_data + pos, n); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QStringView left(qsizetype n) const
+    { return Q_ASSERT10(n >= 0), Q_ASSERT10(n <= size()), QStringView(m_data, n); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QStringView right(qsizetype n) const
+    { return Q_ASSERT10(n >= 0), Q_ASSERT10(n <= size()), QStringView(m_data + m_size - n, n); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QStringView chopped(qsizetype n) const
+    { return Q_ASSERT10(n >= 0), Q_ASSERT10(n <= size()), QStringView(m_data, m_size - n); }
+
+    Q_DECL_RELAXED_CONSTEXPR void truncate(qsizetype n)
+    { Q_ASSERT(n >= 0); Q_ASSERT(n <= size()); m_size = n; }
+    Q_DECL_RELAXED_CONSTEXPR void chop(qsizetype n)
+    { Q_ASSERT(n >= 0); Q_ASSERT(n <= size()); m_size -= n; }
+
+    Q_REQUIRED_RESULT QStringView trimmed() const Q_DECL_NOTHROW { return QtPrivate::trimmed(*this); }
+
+    Q_REQUIRED_RESULT bool startsWith(QStringView s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW
+    { return QtPrivate::startsWith(*this, s, cs); }
+    Q_REQUIRED_RESULT inline bool startsWith(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW;
+    Q_REQUIRED_RESULT bool startsWith(QChar c) const Q_DECL_NOTHROW
+    { return !empty() && front() == c; }
+    Q_REQUIRED_RESULT bool startsWith(QChar c, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW
+    { return QtPrivate::startsWith(*this, QStringView(&c, 1), cs); }
+
+    Q_REQUIRED_RESULT bool endsWith(QStringView s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW
+    { return QtPrivate::endsWith(*this, s, cs); }
+    Q_REQUIRED_RESULT inline bool endsWith(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const Q_DECL_NOTHROW;
+    Q_REQUIRED_RESULT bool endsWith(QChar c) const Q_DECL_NOTHROW
+    { return !empty() && back() == c; }
+    Q_REQUIRED_RESULT bool endsWith(QChar c, Qt::CaseSensitivity cs) const Q_DECL_NOTHROW
+    { return QtPrivate::endsWith(*this, QStringView(&c, 1), cs); }
+
+    //
+    // STL compatibility API:
+    //
+    Q_REQUIRED_RESULT const_iterator begin()   const Q_DECL_NOTHROW { return data(); }
+    Q_REQUIRED_RESULT const_iterator end()     const Q_DECL_NOTHROW { return data() + size(); }
+    Q_REQUIRED_RESULT const_iterator cbegin()  const Q_DECL_NOTHROW { return begin(); }
+    Q_REQUIRED_RESULT const_iterator cend()    const Q_DECL_NOTHROW { return end(); }
+    Q_REQUIRED_RESULT const_reverse_iterator rbegin()  const Q_DECL_NOTHROW { return const_reverse_iterator(end()); }
+    Q_REQUIRED_RESULT const_reverse_iterator rend()    const Q_DECL_NOTHROW { return const_reverse_iterator(begin()); }
+    Q_REQUIRED_RESULT const_reverse_iterator crbegin() const Q_DECL_NOTHROW { return rbegin(); }
+    Q_REQUIRED_RESULT const_reverse_iterator crend()   const Q_DECL_NOTHROW { return rend(); }
+
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR bool empty() const Q_DECL_NOTHROW { return size() == 0; }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QChar front() const { return Q_ASSERT10(!empty()), QChar(m_data[0]); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QChar back()  const { return Q_ASSERT10(!empty()), QChar(m_data[m_size - 1]); }
+
+    //
+    // Qt compatibility API:
+    //
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR bool isNull() const Q_DECL_NOTHROW { return !m_data; }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR bool isEmpty() const Q_DECL_NOTHROW { return empty(); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR int length() const /* not nothrow! */
+    { return Q_ASSERT10(int(size()) == size()), int(size()); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QChar first() const { return front(); }
+    Q_REQUIRED_RESULT Q_DECL_CONSTEXPR QChar last()  const { return back(); }
+private:
+    qsizetype m_size;
+    const storage_type *m_data;
+};
+Q_DECLARE_TYPEINFO(QStringView, Q_PRIMITIVE_TYPE);
+
+template <typename QStringLike, typename std::enable_if<
+    std::is_same<QStringLike, QString>::value || std::is_same<QStringLike, QStringRef>::value,
+    bool>::type = true>
+inline QStringView qToStringViewIgnoringNull(const QStringLike &s) Q_DECL_NOTHROW
+{ return QStringView(s.data(), s.size()); }
+
+QT_END_NAMESPACE
+
+#endif /* QSTRINGVIEW_H */
diff --git a/qtbase/src/corelib/tools/tools.pri b/qtbase/src/corelib/tools/tools.pri
index bea8e9743527649110f9bc73063c7695b14254f4..9f5d6fa3a6bd5b4b7776de0e257fb04beb19e256 100644
--- a/qtbase/src/corelib/tools/tools.pri
+++ b/qtbase/src/corelib/tools/tools.pri
@@ -57,11 +57,13 @@ HEADERS +=  \
         tools/qsize.h \
         tools/qstack.h \
         tools/qstring.h \
+        tools/qstringalgorithms.h \
         tools/qstringalgorithms_p.h \
         tools/qstringbuilder.h \
         tools/qstringiterator_p.h \
         tools/qstringlist.h \
         tools/qstringmatcher.h \
+        tools/qstringview.h \
         tools/qtextboundaryfinder.h \
         tools/qtimeline.h \
         tools/qtools_p.h \
@@ -71,6 +73,9 @@ HEADERS +=  \
         tools/qvector.h \
         tools/qversionnumber.h
 
+# RJVB: for QStringView; we use qstring.h instead
+# HEADERS +=  \
+#         tools/qstringliteral.h
 
 SOURCES += \
         tools/qarraydata.cpp \
@@ -111,6 +116,10 @@ SOURCES += \
         tools/qvsnprintf.cpp \
         tools/qversionnumber.cpp
 
+# RJVB : backport QStringView
+SOURCES += \
+        tools/qstringview.cpp 
+
 NO_PCH_SOURCES = tools/qstring_compat.cpp
 msvc: NO_PCH_SOURCES += tools/qvector_msvc.cpp
 false: SOURCES += $$NO_PCH_SOURCES # Hack for QtCreator
diff --git a/qtbase/include/QtCore/QStringAlgorithms b/qtbase/include/QtCore/QStringAlgorithms
new file mode 100644
index 00000000..a520c646
--- /dev/null
+++ b/qtbase/include/QtCore/QStringAlgorithms
@@ -0,0 +1 @@
+#include "qstringalgorithms.h"
diff --git a/qtbase/include/QtCore/QStringView b/qtbase/include/QtCore/QStringView
new file mode 100644
index 00000000..022413cc
--- /dev/null
+++ b/qtbase/include/QtCore/QStringView
@@ -0,0 +1 @@
+#include "qstringview.h"
diff --git a/qtbase/include/QtCore/qstringalgorithms.h b/qtbase/include/QtCore/qstringalgorithms.h
new file mode 100644
index 00000000..77a5df53
--- /dev/null
+++ b/qtbase/include/QtCore/qstringalgorithms.h
@@ -0,0 +1 @@
+#include "../../src/corelib/tools/qstringalgorithms.h"
diff --git a/qtbase/include/QtCore/qstringliteral.h b/qtbase/include/QtCore/qstringliteral.h
new file mode 100644
index 00000000..0804f98f
--- /dev/null
+++ b/qtbase/include/QtCore/qstringliteral.h
@@ -0,0 +1 @@
+#include "../../src/corelib/tools/qstringliteral.h"
diff --git a/qtbase/include/QtCore/qstringview.h b/qtbase/include/QtCore/qstringview.h
new file mode 100644
index 00000000..b9364542
--- /dev/null
+++ b/qtbase/include/QtCore/qstringview.h
@@ -0,0 +1 @@
+#include "../../src/corelib/tools/qstringview.h"
