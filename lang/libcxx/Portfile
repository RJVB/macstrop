PortSystem              1.0
PortGroup               compiler_blacklist_versions 1.0
PortGroup               LTO 1.0
PortGroup               compress_workdir 1.0

if {${os.platform} eq "darwin" && ${os.major} < 11} {
    ui_debug "Platform ${os.platform}, version ${os.major}.${os.minor}"
    # The official/mainstream port:libcxx has received some useful
    # tweaks recently, for 10.6 and earlier.
    name                libcxx_from_macstrop
    version             0
    ui_msg "${name}@${version}"
    replaced_by         libcxx
    PortGroup           obsolete 1.0
    return
} else {
    name                libcxx
}

epoch                   1
# FUTURE WARNING:
# Starting with LLVM 8.0.0, users that wish to link together translation units built
# with different versions of libc++'s headers into the same final linked image MUST
# define the _LIBCPP_HIDE_FROM_ABI_PER_TU macro to 1 when building those translation
# units. Not defining _LIBCPP_HIDE_FROM_ABI_PER_TU to 1 and linking translation units
# built with different versions of libc++'s headers together may lead to ODR violations
# and ABI issues. On the flipside, code size improvements should be expected for
# everyone not defining the macro.
# Hence see patch-config-availability+ABIhiding.diff

version                 9.0.1
if {[variant_isset macports_libcxx]} {
    revision            3
}
# some kind of version that should be larger than the current_version Apple gave to this libc++ version
# could also simply be a version that is based on Apple's libc++ version on the OS version we are building for.
set version4macports    900.99.1

categories              lang
platforms               darwin
license                 MIT NCSA
maintainers             gmail.com:rjvbertin {jeremyhu @jeremyhu}
description             libc++ is a new implementation of the C++ standard library with support for C++11 and portions of C++14.
long_description        ${description} \
                        Because objects cannot be passed between different versions of the C++ runtime, this port must \
                        replace the host version in order to be used.  On Snow Leopard and earlier, this is done \
                        automatically because there is no existing host version of this library.  On Lion and later, \
                        users must build the port with +replacemnt_libcxx and install the root manually if they wish \
                        to replace the existing host implementation. They can also use the +macports_libcxx variant which installs \
                        the library under $prefix/lib where it will be picked up by subsequent MacPorts builds. \
                        It can also be loaded via DYLD_INSERT_LIBRARIES or the optlibs script\; \
                        applications started that way will then use a more recent libc++ than the host provides.

homepage                http://libcxx.llvm.org/

# master_sites            http://www.llvm.org/releases/${version}/
master_sites            https://github.com/llvm/llvm-project/releases/download/llvmorg-${version}
dist_subdir             llvm

use_xz                  yes

variant replacemnt_libcxx description {EXPERTS ONLY: Build a replacement libcxxabi and libcxx even if it is already part of the base OS.} {}
variant macports_libcxx description "EXPERTS ONLY: Install the libcxx library so that MacPorts build will link against it" {}

# cmake requires C++11 and thus libc++. Avoid circular dependencies and allow
# building using the cmake build system only when the system has already has libc++
# installed, either natively or because the libc++ conversion has been bootstrapped.
# Also require cmake to be present.
# check the presence of cmake by checking the registry for the activated port as
# ${prefix} will be set to "${prefix}" during portindex'ing ...
set use_cmake           [expr [file exists /usr/lib/libc++.dylib] && [lindex [lindex [registry_active cmake] 0] 2]]
if {${os.major} >= 11 && ![variant_isset replacemnt_libcxx] && ![variant_isset macports_libcxx]} {
    # nothing to be done in this case, we're a stub port
    set is_stub         yes
}

if {![tbool use_cmake]} {
    ui_debug "/usr/lib/libc++.dylib and/or ${prefix}/bin/cmake are missing"
    # force a bootstrap using the mainstream port:libcxx
    ## NB ##
    # We could also embed the bootstrap version, maintaining the 2 different build methods
    # like we long did, except clamping the bootstart libc++ version to 5.0.1
    name                libcxx_from_macstrop
    ui_msg "${name}@${version}"
    long_description    ${description} \n\
                        This port can only been installed if you already have a libc++ in /usr/lib \
                        and have port:cmake installed.
    replaced_by         libcxx
    PortGroup           obsolete 1.0
    return
}

set libcxxabi_distname  libcxxabi-${version}.src
set libcxx_distname     libcxx-${version}.src

distfiles               ${libcxxabi_distname}${extract.suffix} \
                        ${libcxx_distname}${extract.suffix}

checksums               ${libcxxabi_distname}${extract.suffix} \
                        rmd160  8f1529d722a6ffe44c44290dbea5a8a9ca2acea9 \
                        sha256  e8f978aa4cfae2d7a0b4d89275637078557cca74b35c31b7283d4786948a8aac \
                        ${libcxx_distname}${extract.suffix} \
                        rmd160  b85b557e1fa372f2f3eb854c13ca103abb671d66 \
                        sha256  0981ff11b862f4f179a13576ab0a2f5530f46bd3b6b4a90f568ccc6a62914b34

if {${name} eq "libcxx"} {
    PortGroup           devport 1.0
    create_devport      port:${name}
}

if {![is_mainport]} {
    if {![tbool use_cmake] || [tbool is_stub]} {
        long_description-append \n>>> This is a stub port unless you set +macports_libcxx
        pre-destroot {
            ui_error "This port only exists when port:libcxx is installed +macports_libcxx"
            return -code error "invalid configuration"
        }
    }
    # nothing else to be done
    return
}
# for version4macports:
revision                [expr ${revision} + 1]

if {[tbool use_cmake]} {
    PortGroup           cmake 1.1
    distfiles-append    llvm-${version}.src${extract.suffix}
    worksrcdir          llvm-${version}.src
    checksums-append    llvm-${version}.src${extract.suffix} \
                        rmd160  151c137ac3a514b6d32aaee5bb77dd32eb7d1f19 \
                        sha256  00a1ee1f389f81e9979f3a640a01c431b3021de0d42278f6508391a2f0b81c9a
    installs_libs       yes

    # these are used during the build but not linked to by the resulting libraries
    depends_build-append \
                        port:libedit \
                        port:libffi \
                        port:ncurses \
                        port:libxml2 \
                        port:zlib

    patch.pre_args      -Np1
    patchfiles-append   3002-Fix-missing-long-long-math-prototypes-when-using-the.patch \
                        patch-accept-build_types.diff \
                        patch-install_location_version_and_name.diff
    # don't selectively hide symbols (new in 9.0.x); see patch-prune-exported-cxxabi-symbols.diff
    # for a list of symbols not known on OS X 10.9.
    patchfiles-append   patch-dont-selectively-export-cxxabi-symbols.diff
    # allow the tests to build
    patchfiles-append   patch-fix-test-empty-SDKROOT.diff
    # make the benchmarks build

    if {[variant_isset macports_libcxx]} {
        patchfiles-append \
            patch-config-availability+ABIhiding.diff
    }

    post-patch {
        reinplace "s|@PREFIX@|${prefix}|g" ${worksrcpath}/projects/libcxx/benchmarks/CMakeLists.txt
    }

    configure.args-append \
                        -DLLVM_PATH=${worksrcpath} \
                        -DLIBCXX_ENABLE_ASSERTIONS=OFF \
                        -DLIBCXXABI_ENABLE_STATIC=OFF \
                        -DLIBCXX_ENABLE_STATIC=OFF \
                        -DLIBCXX_BENCHMARK_NATIVE_STDLIB=libc++
    if {${os.major} >= 18} {
        configure.args-append -DLLVM_TARGETS_TO_BUILD="X86\;PowerPC\;AMDGPU\;arm64"
    } else {
        configure.args-append -DLLVM_TARGETS_TO_BUILD="X86\;PowerPC\;AMDGPU"
    }
    # Testing:
    configure.args-append \
                        -DVERSION_ACCORDING_TO_MACPORTS=${version4macports}

    if {[info proc cmake.save_configure_cmd] ne ""} {
        cmake.save_configure_cmd "log too"
    }

    set libcxxabi_worksrcpath \
                        ${build.dir}
    set libcxx_worksrcpath \
                        ${build.dir}

    build.target        cxx

    test.run            yes
    test.dir            ${build.dir}
    test.target         check-cxxabi check-cxx check-cxx-benchmarks
    test.post_args-append -wk
    pre-test {
        # this doesn't seem to have any effect?!"
        test.env-append "SDKROOT=macosx${macosx_deployment_target}"
        set SDKPATH [exec xcrun -sdk macosx${macosx_deployment_target} --show-sdk-path]
        test.env-append "SDKPATH=${SDKPATH}"
        # don't set LIBRARY_PATH (we don't want unexpected linking to $prefix/lib/libc++)!
        test.env-append "LIBRARY_PATH="
    }

    post-build {
        file delete -force ${libcxxabi_worksrcpath}/lib/libc++abi.dylib ${libcxxabi_worksrcpath}/lib/libc++abi.1.dylib
        file rename ${libcxxabi_worksrcpath}/lib/libc++abi.${version4macports}.dylib ${libcxxabi_worksrcpath}/lib/libc++abi.dylib
        file delete -force ${libcxx_worksrcpath}/lib/libc++.dylib ${libcxx_worksrcpath}/lib/libc++.1.dylib
        file rename ${libcxx_worksrcpath}/lib/libc++.${version4macports}.dylib ${libcxx_worksrcpath}/lib/libc++.1.dylib
    }
}

variant universal {}
default_variants +universal

set roots_path ${prefix}/var/system_roots/
set root_name  ${name}-${version}-${revision}

platform darwin {
    if {${os.major} < 9} {
        pre-fetch {
            ui_error "${name} is not supported on Tiger or earlier."
            error "unsupported platform"
        }
    }

    if {${os.major} < 11} {
        post-activate {
            set dirs /
            if {${os.subplatform} eq "macosx"} {
                lappend dirs ${developer_dir}/SDKs/MacOSX[join [lrange [split ${macosx_version} .] 0 1] .].sdk
            }
            foreach d ${dirs} {
                system -W ${d} "tar xzf ${roots_path}/${root_name}.tgz"
            }
        }
    }
}

variant runtime description "EXPERTS ONLY: Install the libcxx library so that it can be used with DYLD_INSERT_LIBRARIES (obsolete: use +macports_libcxx)" {
    ui_warn "The +runtime variant is obsolete, please use +macports_libcxx"
    default_variants-append +macports_libcxx
}
if {[variant_isset macports_libcxx]} {
    depends_build-append \
                        port:cctools
    notes-append "Install port:libcxx-dev and rebuild ports or start applications via ${prefix}/bin/optlibs to use libc++ v${version}, or\
         set DYLD_INSERT_LIBRARIES as illustrated in that script."
}

if {[variant_isset macports_libcxx]} {
    configure.args-append \
                    -DLIBCXX_INSTALL_PREFIX=${prefix}
} else {
    cmake.install_prefix \
                    /usr
}


if {![tbool is_stub]} {
    supported_archs i386 x86_64 ppc

    post-extract {
        ui_debug "moving ${libcxxabi_distname} and ${libcxx_distname} into place in ${worksrcpath}/projects"
        file rename ${workpath}/${libcxxabi_distname} ${worksrcpath}/projects/libcxxabi
        file rename ${workpath}/${libcxx_distname} ${worksrcpath}/projects/libcxx
    }

    # We want to use the host's libc++ everywhere because we want to ensure
    # that only *ONE* copy of this library is in any process's address space.
    # On Snow Leopard and earlier, this port provides this library in /usr for
    # binary compatibility with Lion and later.
    #
    # On newer OS version, this port does not install the content to /usr and
    # just leaves it to expert users who may want to replace their system
    # runtime.

    destroot {
        if {[variant_isset replacemnt_libcxx]} {
            xinstall -m 755 -d ${destroot}${roots_path}/${root_name}/usr/lib

            xinstall -m 755 ${libcxxabi_worksrcpath}/lib/libc++abi.dylib ${destroot}${roots_path}/${root_name}/usr/lib

            xinstall -m 755 ${libcxx_worksrcpath}/lib/libc++.1.dylib ${destroot}${roots_path}/${root_name}/usr/lib
            ln -s libc++.1.dylib ${destroot}${roots_path}/${root_name}/usr/lib/libc++.dylib

            if {[variant_isset macports_libcxx]} {
                system "install_name_tool -id /usr/lib/libc++abi.dylib ${destroot}${roots_path}/${root_name}/usr/lib/libc++abi.dylib"
                system "install_name_tool -id /usr/lib/libc++.1.dylib ${destroot}${roots_path}/${root_name}/usr/lib/libc++.1.dylib"
                system "install_name_tool -change ${prefix}/lib/libc++abi.1.dylib /usr/lib/libc++abi.dylib ${destroot}${roots_path}/${root_name}/usr/lib/libc++.1.dylib"
            }

            system -W ${destroot}${roots_path}/${root_name} "tar czf ../${root_name}.tgz ."
            delete ${destroot}${roots_path}/${root_name}
        }
        if {[variant_isset macports_libcxx]} {
            xinstall -m 755 ${libcxxabi_worksrcpath}/lib/libc++abi.dylib ${destroot}${prefix}/lib/libc++abi.1.dylib
            xinstall -m 755 ${libcxx_worksrcpath}/lib/libc++.1.dylib ${destroot}${prefix}/lib/
            ln -s libc++abi.1.dylib  ${destroot}${prefix}/lib/libc++abi.dylib
            ln -s libc++.1.dylib  ${destroot}${prefix}/lib/libc++.dylib
            xinstall -m 755 ${filespath}/optlibs.sh ${destroot}${prefix}/bin/optlibs
            reinplace "s|@PREFIX@|${prefix}|g" ${destroot}${prefix}/bin/optlibs
        }
    }
    if {[variant_isset macports_libcxx]} {
        post-destroot {
            register_devport_standard_content
            create_devport_content_archive
        }
    }
} else {
    long_description-append \n>>> This is a stub port unless you set +replacemnt_libcxx or +macports_libcxx
    distfiles
    patchfiles
    fetch {}
    configure {}
    build {}
    destroot {
        xinstall -d ${destroot}${prefix}/share/doc/${name}
        system "echo ${name} is an empty port on this OS version because the functionality is already provided by the OS. > ${destroot}${prefix}/share/doc/${name}/README.txt"
    }
}

livecheck.type none
