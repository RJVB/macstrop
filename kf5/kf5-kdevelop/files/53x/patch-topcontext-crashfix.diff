diff --git kdevplatform/language/duchain/duchain.cpp kdevplatform/language/duchain/duchain.cpp
index d9d1700ddf8dd2cd18b838a48c5b0a9841acf69c..4630d0fc54949eb348ab35f4ec8c135421f6a2a2 100644
--- kdevplatform/language/duchain/duchain.cpp
+++ kdevplatform/language/duchain/duchain.cpp
@@ -1489,9 +1489,11 @@ void DUChain::documentClosed(IDocument* document)
 
   IndexedString url(document->url());
 
-  foreach(const ReferencedTopDUContext &top, sdDUChainPrivate->m_openDocumentContexts)
-    if(top->url() == url)
+  foreach(const ReferencedTopDUContext &top, sdDUChainPrivate->m_openDocumentContexts) {
+    if(!top || (sdDUChainPrivate->m_referenceCounts[top] == 0 || top->url() == url)) {
       sdDUChainPrivate->m_openDocumentContexts.remove(top);
+    }
+  }
 }
 
 void DUChain::documentLoadedPrepare(KDevelop::IDocument* doc)
@@ -1669,6 +1676,19 @@ void DUChain::refCountDown(TopDUContext* top) {
   }
 }
 
+void DUChain::releaseReference(ReferencedTopDUContext* top) {
+  {
+      QMutexLocker l(&sdDUChainPrivate->m_referenceCountsMutex);
+      auto it = sdDUChainPrivate->m_referenceCounts.find(top->data());
+      if (it == sdDUChainPrivate->m_referenceCounts.end()) {
+        return;
+      }
+      sdDUChainPrivate->m_referenceCounts.erase(it);
+  }
+  const ReferencedTopDUContext ref = *top;
+  sdDUChainPrivate->m_openDocumentContexts.remove(ref);
+}
+
 void DUChain::emitDeclarationSelected(const DeclarationPointer& decl)
 {
   if(sdDUChainPrivate->m_destroyed)
diff --git kdevplatform/language/duchain/duchain.h kdevplatform/language/duchain/duchain.h
index 1004a6a8dc885dad3ba4665a49ddae3449fe37d9..c4c639c6cbd6a8c78506fda0e1e4606413b4efe2 100644
--- kdevplatform/language/duchain/duchain.h
+++ kdevplatform/language/duchain/duchain.h
@@ -290,6 +290,7 @@ private Q_SLOTS:
   void documentClosed(KDevelop::IDocument*);
 
 private:
+  void releaseReference(ReferencedTopDUContext* top);
   TopDUContext* loadChain(uint index);
   //These two are exported here so that the extremely frequently called chainForIndex(..) can be inlined
   static bool m_deleted;
diff --git kdevplatform/language/duchain/topducontext.h kdevplatform/language/duchain/topducontext.h
index 74ab8d94fbac3bdc1bf3110003509d5a0eed5649..60a40a1969eb6ef5cf3097598e2f159cffa0667d 100644
--- kdevplatform/language/duchain/topducontext.h
+++ kdevplatform/language/duchain/topducontext.h
@@ -90,6 +90,7 @@ class KDEVPLATFORMLANGUAGE_EXPORT ReferencedTopDUContext {
     
   private:
   TopDUContext* m_topContext;
+  friend class TopDUContext;
 };
 
 /**
@@ -355,10 +356,12 @@ protected:
   friend class LocalIndexedProblem;
   friend class DeclarationId;
   friend class ParsingEnvironmentFile;
+  friend class ReferencedTopDUContext;
   
   TopDUContextLocalPrivate* m_local;
   
   class TopDUContextDynamicData* m_dynamicData;
+  QSet<ReferencedTopDUContext*> m_references;
 };
 
 /**
diff --git kdevplatform/language/duchain/topducontext.cpp kdevplatform/language/duchain/topducontext.cpp
index a72d6b4ce9942ab69cd762e407306250f84c8608..59de9ebe292794dc0fa7802d94c97e5777de95b0 100644
--- kdevplatform/language/duchain/topducontext.cpp
+++ kdevplatform/language/duchain/topducontext.cpp
@@ -53,31 +53,44 @@ Utils::BasicSetRepository* RecursiveImportRepository::repository() {
 }
 
 ReferencedTopDUContext::ReferencedTopDUContext(TopDUContext* context) : m_topContext(context) {
-  if(m_topContext)
+  if(m_topContext) {
+    m_topContext->m_references.insert(this);
     DUChain::self()->refCountUp(m_topContext);
+  }
 }
 
 ReferencedTopDUContext::ReferencedTopDUContext(const ReferencedTopDUContext& rhs) : m_topContext(rhs.m_topContext) {
-  if(m_topContext)
+  if(m_topContext) {
+    m_topContext->m_references.insert(this);
     DUChain::self()->refCountUp(m_topContext);
+  }
 }
 
 ReferencedTopDUContext::~ReferencedTopDUContext() {
-  if(m_topContext && !DUChain::deleted())
-    DUChain::self()->refCountDown(m_topContext);
+  if(m_topContext && !DUChain::deleted()) {
+    auto topContext = m_topContext;
+    m_topContext = nullptr;
+    topContext->m_references.remove(this);
+    DUChain::self()->refCountDown(topContext);
+    DUChain::self()->releaseReference(this);
+  }
 }
 
 ReferencedTopDUContext& ReferencedTopDUContext::operator=(const ReferencedTopDUContext& rhs) {
   if(m_topContext == rhs.m_topContext)
     return *this;
 
-  if(m_topContext)
+  if(m_topContext) {
     DUChain::self()->refCountDown(m_topContext);
+    m_topContext->m_references.remove(this);
+  }
 
   m_topContext = rhs.m_topContext;
 
-  if(m_topContext)
+  if(m_topContext) {
     DUChain::self()->refCountUp(m_topContext);
+    m_topContext->m_references.insert(this);
+  }
   return *this;
 }
 
@@ -544,6 +557,11 @@ QExplicitlySharedDataPointer<ParsingEnvironmentFile> TopDUContext::parsingEnviro
 TopDUContext::~TopDUContext( )
 {
   m_dynamicData->m_deleting = true;
+  foreach(ReferencedTopDUContext *ref, m_references) {
+    // ref may not be dynamically allocated so just "unregister" the topContext
+    ref->m_topContext = nullptr;
+  }
+  m_references.clear();
 
   //Clear the AST, so that the 'feature satisfaction' cache is eventually updated
   clearAst();
