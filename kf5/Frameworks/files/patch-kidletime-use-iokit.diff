diff --git src/plugins/osx/CMakeLists.txt src/plugins/osx/CMakeLists.txt
index e1b50b8..12ea1e0 100644
--- src/plugins/osx/CMakeLists.txt
+++ src/plugins/osx/CMakeLists.txt
@@ -1,11 +1,13 @@
 set(osx_plugin_SRCS
     macpoller.cpp
+    macpoller_helper.mm
 )
 
 add_library(KF5IdleTimeOsxPlugin MODULE ${osx_plugin_SRCS})
 target_link_libraries(KF5IdleTimeOsxPlugin
     KF5IdleTime
-    "-framework CoreFoundation -framework Carbon"
+    Qt5::Widgets
+    "-framework CoreFoundation -framework IOKit -framework AppKit"
 )
 
 install(
diff --git src/plugins/osx/macpoller.cpp src/plugins/osx/macpoller.cpp
index ad9c10f..e3336fa 100644
--- src/plugins/osx/macpoller.cpp
+++ src/plugins/osx/macpoller.cpp
@@ -1,4 +1,5 @@
 /* This file is part of the KDE libraries
+   Copyright (C) 2015 René J.V. Bertin <rjvbertin at gmail.com>
    Copyright (C) 2009 Dario Freddi <drf at kde.org>
    Copyright (C) 2003 Tarkvara Design Inc.  (from KVIrc source code)
    Copyright (c) 2008 Roman Jarosz          <kedgedev at centrum.cz>
@@ -20,111 +21,59 @@
 */
 
 #include "macpoller.h"
+#include <CoreServices/CoreServices.h>
 
-// Why does Apple have to make this so complicated?
-static OSStatus LoadFrameworkBundle(CFStringRef framework, CFBundleRef *bundlePtr)
-{
-    OSStatus  err;
-    FSRef   frameworksFolderRef;
-    CFURLRef baseURL;
-    CFURLRef bundleURL;
-
-    if (bundlePtr == nil) {
-        return (-1);
-    }
-
-    *bundlePtr = nil;
-
-    baseURL = nil;
-    bundleURL = nil;
-
-    err = FSFindFolder(kOnAppropriateDisk, kFrameworksFolderType, true, &frameworksFolderRef);
-    if (err == noErr) {
-        baseURL = CFURLCreateFromFSRef(kCFAllocatorSystemDefault, &frameworksFolderRef);
-        if (baseURL == nil) {
-            err = coreFoundationUnknownErr;
-        }
-    }
-
-    if (err == noErr) {
-        bundleURL = CFURLCreateCopyAppendingPathComponent(kCFAllocatorSystemDefault, baseURL, framework, false);
-        if (bundleURL == nil) {
-            err = coreFoundationUnknownErr;
-        }
-    }
-
-    if (err == noErr) {
-        *bundlePtr = CFBundleCreate(kCFAllocatorSystemDefault, bundleURL);
-        if (*bundlePtr == nil) {
-            err = coreFoundationUnknownErr;
-        }
-    }
-
-    if (err == noErr) {
-        if (!CFBundleLoadExecutable(*bundlePtr)) {
-            err = coreFoundationUnknownErr;
-        }
-    }
-
-    // Clean up.
-    if (err != noErr && *bundlePtr != nil) {
-        CFRelease(*bundlePtr);
-        *bundlePtr = nil;
-    }
-
-    if (bundleURL != nil) {
-        CFRelease(bundleURL);
-    }
-
-    if (baseURL != nil) {
-        CFRelease(baseURL);
-    }
+#include <QDebug>
+#include <QTimer>
 
-    return err;
-}
+// See http://stackoverflow.com/questions/19229777/how-to-detect-global-mouse-button-events for 
+// background relative to using an approach based on WidgetBasedPoller.
 
-pascal void MacPoller::IdleTimerAction(EventLoopTimerRef, EventLoopIdleTimerMessage inState, void *inUserData)
-{
-    Q_ASSERT(inUserData);
-    switch (inState) {
-    case kEventLoopIdleTimerStarted:
-    case kEventLoopIdleTimerStopped:
-        // Get invoked with this constant at the start of the idle period,
-        // or whenever user activity cancels the idle.
-        ((MacPoller *)inUserData)->m_secondsIdle = 0;
-        ((MacPoller *)inUserData)->triggerResume();
-        break;
-    case kEventLoopIdleTimerIdling:
-        // Called every time the timer fires (i.e. every second).
-        ((MacPoller *)inUserData)->m_secondsIdle++;
-        ((MacPoller *)inUserData)->poll();
-        break;
-    }
-}
+#include <algorithm>
 
-// Typedef for the function we're getting back from CFBundleGetFunctionPointerForName.
-typedef OSStatus(*InstallEventLoopIdleTimerPtr)(EventLoopRef inEventLoop,
-        EventTimerInterval   inFireDelay,
-        EventTimerInterval   inInterval,
-        EventLoopIdleTimerUPP    inTimerProc,
-        void                *inTimerData,
-        EventLoopTimerRef   *outTimer);
+typedef OSErr(*UpdateSystemActivityPtr)(UInt8 activity);
+static UpdateSystemActivityPtr updateSystemActivity;
 
 MacPoller::MacPoller(QObject *parent)
     : AbstractSystemPoller(parent)
-    , m_timerRef(0)
-    , m_secondsIdle(0)
+    , ioPort(0)
+    , ioIterator(0)
+    , ioObject(0)
+    , m_idleTimer(0)
+    , m_minTimeout(-1)
+    , m_maxTimeout(-1)
+    , m_lastTimeout(-1)
+    , m_nextTimeout(-1)
+    , m_NTimeouts(0)
+    , m_pollResolution(-1)
     , m_catch(false)
 {
 }
 
 MacPoller::~MacPoller()
 {
+    unloadPoller();
+    delete m_idleTimer;
 }
 
 void MacPoller::unloadPoller()
 {
-    RemoveEventLoopTimer(m_timerRef);
+    if (m_idleTimer) {
+        m_idleTimer->stop();
+        m_idleTimer->deleteLater();
+        m_idleTimer = 0;
+    }
+    additionalUnload();
+    if (ioObject) {
+        IOObjectRelease( ioObject );
+        ioObject = 0;
+    }
+    if (ioIterator) {
+        IOObjectRelease( ioIterator );
+        ioIterator = 0;
+    }
+    m_lastTimeout = -1;
+    m_nextTimeout = -1;
 }
 
 bool MacPoller::isAvailable()
@@ -135,37 +84,84 @@ bool MacPoller::isAvailable()
 bool MacPoller::setUpPoller()
 {
     // May already be init'ed.
-    if (m_timerRef) {
+    if (ioObject) {
         return true;
     }
 
-    // According to the docs, InstallEventLoopIdleTimer is new in 10.2.
-    // According to the headers, it has been around since 10.0.
-    // One of them is lying.  We'll play it safe and weak-link the function.
-
-    // Load the "Carbon.framework" bundle.
-    CFBundleRef carbonBundle;
+    // The easiest way to simulate user activity is to call UpdateSystemActivity(), but that function has
+    // sadly been deprecated. Hence the attempt to load it dynamically from the framework that provides/d it.
+    static CFBundleRef csBundle = 0;
+    if (!csBundle) {
+        csBundle = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.CoreServices"));
+    }
+    if (csBundle) {
+        updateSystemActivity = (UpdateSystemActivityPtr) CFBundleGetFunctionPointerForName(csBundle, CFSTR("UpdateSystemActivity"));
+        if (!updateSystemActivity) {
+            qWarning() << "failed to load UpdateSystemActivity from CoreServices.framework";
+        }
+    }
+    else{
+        updateSystemActivity = 0;
+        qWarning() << "failed to load CoreServices.framework: UpdateSystemActivity not available";
+    }
 
-    if (LoadFrameworkBundle(CFSTR("Carbon.framework"), &carbonBundle) != noErr) {
+    kern_return_t status;
+    // establish the connection with I/O Kit, on the default port (MACH_PORT_NULL).
+    status = IOMasterPort( MACH_PORT_NULL, &ioPort );
+    if (status != KERN_SUCCESS) {
+        qWarning() << "could not establish a connection with I/O Kit on the default port";
         return false;
     }
-
-    // Load the Mach-O function pointers for the routine we will be using.
-    InstallEventLoopIdleTimerPtr myInstallEventLoopIdleTimer =
-        (InstallEventLoopIdleTimerPtr)CFBundleGetFunctionPointerForName(carbonBundle, CFSTR("InstallEventLoopIdleTimer"));
-
-    if (myInstallEventLoopIdleTimer == 0) {
+    // We will use the IOHID service which will allow us to know about user interaction.
+    // Get an iterator on the I/O Kit services, so we can access IOHID:
+    status = IOServiceGetMatchingServices( ioPort, IOServiceMatching("IOHIDSystem"), &ioIterator );
+    if (status != KERN_SUCCESS) {
+        ioIterator = 0;
+        qWarning() << "could not get an iterator on the I/O Kit services, to access IOHID";
+        return false;
+    }
+    // get the actual IOHID service object:
+    ioObject = IOIteratorNext(ioIterator);
+    if (!ioObject) {
+        qWarning() << "could not get the actual IOHID service object";
         return false;
     }
+    IOObjectRetain(ioObject);
+    IOObjectRetain(ioIterator);
+
+    m_idleTimer = new QTimer(this);
+    connect(m_idleTimer, SIGNAL(timeout()), this, SLOT(checkForIdle()));
+
+    additionalSetUp();
 
-    EventLoopIdleTimerUPP timerUPP = NewEventLoopIdleTimerUPP(IdleTimerAction);
-    if ((*myInstallEventLoopIdleTimer)(GetMainEventLoop(), kEventDurationSecond, kEventDurationSecond, timerUPP, this, &m_timerRef)) {
+    return false;
+}
+
+bool MacPoller::setPollerResolution(int msecs)
+{
+    if (msecs >= 0) {
+        m_pollResolution = msecs;
+        if (m_pollResolution < 5) {
+            m_idleTimer->setTimerType(Qt::PreciseTimer);
+        }
+        else {
+            m_idleTimer->setTimerType(Qt::CoarseTimer);
+        }
+        if (m_idleTimer->isActive()) {
+            m_idleTimer->setInterval(msecs);
+        }
         return true;
     }
-
     return false;
 }
 
+bool MacPoller::getPollerResolution(int &msecs)
+{
+    msecs = m_pollResolution;
+    // this plugin supports setting the polling resolution so we return true
+    return true;
+}
+
 QList<int> MacPoller::timeouts() const
 {
     return m_timeouts;
@@ -173,34 +169,149 @@ QList<int> MacPoller::timeouts() const
 
 void MacPoller::addTimeout(int nextTimeout)
 {
-    m_timeouts.append(nextTimeout);
-    poll();
+    if (!m_timeouts.contains(nextTimeout)) {
+        m_timeouts.append(nextTimeout);
+        std::sort(m_timeouts.begin(), m_timeouts.end());
+        if (nextTimeout < m_minTimeout || m_minTimeout < 0) {
+            m_minTimeout = nextTimeout;
+        }
+        if (nextTimeout > m_maxTimeout) {
+            m_maxTimeout = nextTimeout;
+        }
+        poll(false);
+    }
+    m_NTimeouts = m_timeouts.count();
 }
 
-int MacPoller::poll()
+void MacPoller::removeTimeout(int timeout)
 {
-    int idle = m_secondsIdle * 1000;
-
-    // Check if we reached a timeout..
+    m_timeouts.removeOne(timeout);
+    std::sort(m_timeouts.begin(), m_timeouts.end());
+    m_minTimeout = -1, m_maxTimeout = -1;
     Q_FOREACH (int i, m_timeouts) {
-        if ((i - idle < 1000 && i > idle) || (idle - i < 1000 && idle > i)) {
-            // Bingo!
-            emit timeoutReached(i);
+        if (i < m_minTimeout || m_minTimeout < 0) {
+            m_minTimeout = i;
+        }
+        if (i > m_maxTimeout) {
+            m_maxTimeout = i;
         }
     }
+    if (m_lastTimeout == timeout) {
+        m_lastTimeout = -1;
+        m_nextTimeout = -1;
+    }
+    m_NTimeouts = m_timeouts.count();
+    poll(false);
+}
 
-    return idle;
+int MacPoller::kickTimer(int64_t idle)
+{
+    if (!m_NTimeouts) {
+        if (m_idleTimer->isActive()) {
+            m_idleTimer->setInterval(0);
+        }
+        else {
+            m_idleTimer->start(0);
+        }
+    }
+    else {
+        int64_t currentMinTimeout = (m_nextTimeout >= 0)? m_nextTimeout : m_minTimeout;
+        if (idle < currentMinTimeout || m_pollResolution >= 0) {
+            int interval = (m_pollResolution < 0)? (currentMinTimeout - idle) / 2 : m_pollResolution;
+//             fprintf( stderr, "idleTimer interval set to (%lld-%lld)/2=%d, next timeout=%d\n",
+//                      currentMinTimeout, idle, interval, m_nextTimeout);
+            if (m_idleTimer->isActive()) {
+                m_idleTimer->setInterval(interval);
+            }
+            else {
+                m_idleTimer->start(interval);
+            }
+            return interval;
+        }
+    }
+    return m_idleTimer->interval();
+}
+
+int64_t MacPoller::poll(bool allowEmit, int64_t &idle)
+{
+    kern_return_t status;
+    CFTypeRef cfIdle;
+    CFTypeID type;
+    uint64_t time = 0;
+    CFMutableDictionaryRef properties = 0;
+    status = IORegistryEntryCreateCFProperties( ioObject, &properties, kCFAllocatorDefault, 0 );
+    if (status == KERN_SUCCESS && properties) {
+        cfIdle = CFDictionaryGetValue( properties, CFSTR("HIDIdleTime") );
+        if (cfIdle) {
+            CFRetain(cfIdle);
+            // cfIdle can have different types: handle them properly:
+            type = CFGetTypeID(cfIdle);
+            if (type == CFDataGetTypeID()) {
+                CFDataGetBytes( (CFDataRef)cfIdle, CFRangeMake( 0, sizeof(time) ), (UInt8*)&time );
+            }
+            else if (type == CFNumberGetTypeID()) {
+                CFNumberGetValue( (CFNumberRef)cfIdle, kCFNumberSInt64Type, &time );
+            }
+            CFRelease(cfIdle);
+        }
+        CFRelease( (CFTypeRef)properties );
+        // convert nanoseconds to milliseconds:
+        idle = int64_t(time / 1000000);
+        if (idle < m_idleOffset) {
+            // reset the idle offset if the idle time dropped below it
+            m_idleOffset = 0;
+        }
+    }
+
+    int64_t offsetIdle = idle - m_idleOffset;
+    if (allowEmit) {
+        // we don't use Q_FOREACH because we want an easy access to the timeout value after the current one
+        QList<int>::const_iterator iter;
+        for (iter = m_timeouts.constBegin(); iter != m_timeouts.constEnd(); ++iter) {
+            int i = *iter;
+            // m_timeouts is sorted so we can simply check for offsetIdle>=i
+            if (i != m_lastTimeout && i > m_lastTimeout && offsetIdle >= i) {
+                // Bingo!
+//                 qDebug() << "lastTimeOut=" << m_lastTimeout;
+                m_lastTimeout = i;
+                if (i < m_maxTimeout) {
+                    m_nextTimeout = iter[1];
+                }
+//                 qDebug() << "timeout" << i << "hit at idle" << offsetIdle << "(offset,real idle=="
+//                     << m_idleOffset << idle << "); next timeout:" << m_nextTimeout;
+                emit timeoutReached(i);
+                return idle;
+            }
+        }
+    }
+    if (m_minTimeout > 0) {
+        kickTimer(offsetIdle);
+    } else {
+        m_idleTimer->stop();
+    }
+
+    // return the "virtual" idle i.e. the time since the last simulateUserActivity(),
+    // not the actual idle time!
+    return offsetIdle;
+}
+
+int64_t MacPoller::poll(bool allowEmits)
+{
+    int64_t idle;
+    return poll(allowEmits, idle);
 }
 
 int MacPoller::forcePollRequest()
 {
-    return poll();
+    return int(poll(false));
 }
 
-void MacPoller::removeTimeout(int timeout)
+void MacPoller::detectedActivity()
 {
-    m_timeouts.removeOne(timeout);
-    poll();
+    if (m_catch) {
+        emit resumingFromIdle();
+    }
+    stopCatchingIdleEvents();
 }
 
 void MacPoller::catchIdleEvent()
@@ -210,19 +321,47 @@ void MacPoller::catchIdleEvent()
 
 void MacPoller::stopCatchingIdleEvents()
 {
+    // this slot is called after resumingFromIdle, and thus should not stop the poll timer
+    // because that also drives the timeout detection. Unsetting m_catch is enough
     m_catch = false;
+    m_lastTimeout = -1;
 }
 
-void MacPoller::triggerResume()
+void MacPoller::checkForIdle()
 {
-    if (m_catch) {
-        emit resumingFromIdle();
-        stopCatchingIdleEvents();
+    if (m_NTimeouts || m_catch) {
+        int64_t idle = poll(true);
+        if (idle == 0 && m_catch) {
+            m_idleOffset = 0;
+            emit resumingFromIdle();
+        }
     }
 }
 
 void MacPoller::simulateUserActivity()
 {
-    // TODO
+    // The alternative is to disable sleep using 
+    //     IOReturn success = IOPMAssertionCreateWithName(kIOPMAssertionTypeNoDisplaySleep,
+    //                                                    kIOPMAssertionLevelOn, CFSTR("simulated user activity"), &assertionID);
+    // coupled with a timer to re-allow sleep, but there are reports that isn't very reliable.
+    if (updateSystemActivity) {
+        (*updateSystemActivity)(UsrActivity);
+    }
+//  this doesn't reset the HIDIdleTime property (and requires ApplicationServices)
+//     CGEventRef event = CGEventCreate(nil);
+//     CGPoint loc = CGEventGetLocation(event);
+//     CGEventRef move1 = CGEventCreateMouseEvent(0, kCGEventMouseMoved,
+//         CGPointMake(loc.x+1, loc.y+1), kCGMouseButtonLeft /*ignored*/ );
+//     CGEventRef move2 = CGEventCreateMouseEvent(0, kCGEventMouseMoved,
+//         loc, kCGMouseButtonLeft /*ignored*/ );
+//     CGEventPost(kCGHIDEventTap, move1);
+//     CGEventPost(kCGHIDEventTap, move2);
+//     CFRelease(move2);
+//     CFRelease(move1);
+//     CFRelease(event);
+    // store an idle offset in order to simulate a (software) reset
+    m_lastTimeout = -1;
+    m_nextTimeout = -1;
+    poll(false, m_idleOffset);
 }
 
diff --git src/plugins/osx/macpoller.h src/plugins/osx/macpoller.h
index ef51ea5..007b5d8 100644
--- src/plugins/osx/macpoller.h
+++ src/plugins/osx/macpoller.h
@@ -21,7 +21,14 @@
 
 #include "abstractsystempoller.h"
 
-#include <Carbon/Carbon.h>
+#include <QTimer>
+
+// Use IOKIT instead of the deprecated Carbon interface
+#include <IOKit/IOKitLib.h>
+
+#include <QAbstractNativeEventFilter>
+
+class QWidget;
 
 class MacPoller: public AbstractSystemPoller
 {
@@ -37,7 +44,8 @@ public:
     bool setUpPoller();
     void unloadPoller();
 
-    static pascal void IdleTimerAction(EventLoopTimerRef, EventLoopIdleTimerMessage inState, void *inUserData);
+    bool setPollerResolution(int msecs);
+    bool getPollerResolution(int &msecs);
 
 public Q_SLOTS:
     void addTimeout(int nextTimeout);
@@ -47,16 +55,29 @@ public Q_SLOTS:
     void catchIdleEvent();
     void stopCatchingIdleEvents();
     void simulateUserActivity();
-    void triggerResume();
 
 private Q_SLOTS:
-    int poll();
+    void checkForIdle();
+    void detectedActivity();
 
 private:
+    int64_t poll(bool allowEmits, int64_t &idle);
+    int64_t poll(bool allowEmits);
+    int kickTimer(int64_t idle);
+    bool additionalSetUp();
+    void additionalUnload();
     QList<int> m_timeouts;
-    EventLoopTimerRef m_timerRef;
-    int m_secondsIdle;
+    mach_port_t ioPort;
+    io_iterator_t ioIterator;
+    io_object_t ioObject;
+    QTimer *m_idleTimer;
+    int m_pollResolution;
+    int m_minTimeout, m_maxTimeout, m_NTimeouts;
+    int m_lastTimeout, m_nextTimeout;
+    int64_t m_idleOffset;
     bool m_catch;
+    QAbstractNativeEventFilter *m_nativeGrabber;
+    friend class CocoaEventFilter;
 };
 
 #endif /* MACPOLLER_H */
diff --git src/plugins/osx/macpoller_helper.mm src/plugins/osx/macpoller_helper.mm
new file mode 100644
index 0000000..1145070
--- /dev/null
+++ src/plugins/osx/macpoller_helper.mm
@@ -0,0 +1,83 @@
+/* This file is part of the KDE libraries
+   Copyright (C) 2015 René J.V. Bertin <rjvbertin at gmail.com>
+   Copyright (C) 2009 Dario Freddi <drf at kde.org>
+   Copyright (C) 2003 Tarkvara Design Inc.  (from KVIrc source code)
+   Copyright (c) 2008 Roman Jarosz          <kedgedev at centrum.cz>
+   Copyright (c) 2008 the Kopete developers <kopete-devel at kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License version 2 as published by the Free Software Foundation.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#include "macpoller.h"
+#include <CoreServices/CoreServices.h>
+
+#include <QDebug>
+#include <QApplication>
+
+// See http://stackoverflow.com/questions/19229777/how-to-detect-global-mouse-button-events for 
+// background relative to using an approach based on WidgetBasedPoller.
+
+#import <AppKit/AppKit.h>
+
+class CocoaEventFilter : public QAbstractNativeEventFilter
+{
+public:
+    const static int mask = NSLeftMouseDownMask | NSLeftMouseUpMask | NSRightMouseDownMask
+                    | NSRightMouseUpMask | NSOtherMouseDownMask | NSOtherMouseUpMask
+                    | NSLeftMouseDraggedMask | NSRightMouseDraggedMask | NSOtherMouseDraggedMask
+                    | NSMouseMovedMask | NSScrollWheelMask | NSTabletPointMask | NSKeyDownMask;
+    bool nativeEventFilter(const QByteArray &eventType, void *message, long *result) {
+        Q_UNUSED(result) Q_UNUSED(message)
+        qDebug() << "Global" << eventType << "detected natively";
+        poller->detectedActivity();
+        return false;
+    };
+    MacPoller *poller;
+    id m_monitorId;
+};
+
+bool MacPoller::additionalSetUp()
+{
+    CocoaEventFilter *nativeGrabber = new CocoaEventFilter;
+    if (nativeGrabber) {
+        // quick and dirty, no real point in going through a setter
+        nativeGrabber->poller = this;
+        m_nativeGrabber = nativeGrabber;
+        QCoreApplication::processEvents();
+        @autoreleasepool {
+            nativeGrabber->m_monitorId = [NSEvent addGlobalMonitorForEventsMatchingMask:CocoaEventFilter::mask
+                handler:^(NSEvent* event) { m_nativeGrabber->nativeEventFilter("NSEventFromGlobalMonitor", event, 0); }];
+        }
+        qApp->installNativeEventFilter(m_nativeGrabber);
+        QCoreApplication::processEvents();
+    }
+    return true;
+}
+
+void MacPoller::additionalUnload()
+{
+    if (m_nativeGrabber) {
+        CocoaEventFilter *nativeGrabber = static_cast<CocoaEventFilter*>(m_nativeGrabber);
+        qApp->removeNativeEventFilter(m_nativeGrabber);
+        if (nativeGrabber->m_monitorId) {
+            @autoreleasepool {
+                 [NSEvent removeMonitor:nativeGrabber->m_monitorId];
+            }
+            nativeGrabber->m_monitorId = 0;
+        }
+        delete nativeGrabber;
+    }
+    m_nativeGrabber = 0;
+}
