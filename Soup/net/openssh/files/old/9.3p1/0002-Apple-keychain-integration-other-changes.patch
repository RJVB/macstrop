diff --git a/Makefile.in b/Makefile.in
index 70287f5..8543386 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -46,6 +46,7 @@ CC=@CC@
 LD=@LD@
 CFLAGS=@CFLAGS@
 CFLAGS_NOPIE=@CFLAGS_NOPIE@
+OBJCFLAGS=@OBJCFLAGS@
 CPPFLAGS=-I. -I$(srcdir) @CPPFLAGS@ $(PATHS) @DEFS@
 PICFLAG=@PICFLAG@
 LIBS=@LIBS@
@@ -63,6 +64,7 @@ SED=@SED@
 XAUTH_PATH=@XAUTH_PATH@
 LDFLAGS=-L. -Lopenbsd-compat/ @LDFLAGS@
 LDFLAGS_NOPIE=-L. -Lopenbsd-compat/ @LDFLAGS_NOPIE@
+KEYCHAIN_LDFLAGS=@KEYCHAIN_LDFLAGS@
 EXEEXT=@EXEEXT@
 MANFMT=@MANFMT@
 MKDIR_P=@MKDIR_P@
@@ -155,6 +157,8 @@ SFTPSERVER_OBJS=sftp-common.o sftp-server.o sftp-server-main.o
 
 SFTP_OBJS=	sftp.o sftp-usergroup.o progressmeter.o $(SFTP_CLIENT_OBJS)
 
+KEYCHAINOBJS=keychain.o
+
 MANPAGES	= moduli.5.out scp.1.out ssh-add.1.out ssh-agent.1.out ssh-keygen.1.out ssh-keyscan.1.out ssh.1.out sshd.8.out sftp-server.8.out sftp.1.out ssh-keysign.8.out ssh-pkcs11-helper.8.out ssh-sk-helper.8.out sshd_config.5.out ssh_config.5.out
 MANPAGES_IN	= moduli.5 scp.1 ssh-add.1 ssh-agent.1 ssh-keygen.1 ssh-keyscan.1 ssh.1 sshd.8 sftp-server.8 sftp.1 ssh-keysign.8 ssh-pkcs11-helper.8 ssh-sk-helper.8 sshd_config.5 ssh_config.5
 MANTYPE		= @MANTYPE@
@@ -190,9 +194,12 @@ all: $(CONFIGFILES) $(MANPAGES) $(TARGETS)
 $(LIBSSH_OBJS): Makefile.in config.h
 $(SSHOBJS): Makefile.in config.h
 $(SSHDOBJS): Makefile.in config.h
+$(KEYCHAINOBJS): Makefile.in config.h
 
 .c.o:
 	$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@
+.m.o:
+	$(CC) $(OBJCFLAGS) $(CFLAGS) $(CPPFLAGS) -c $< -o $@
 
 LIBCOMPAT=openbsd-compat/libopenbsd-compat.a
 $(LIBCOMPAT): always
@@ -203,8 +210,8 @@ libssh.a: $(LIBSSH_OBJS)
 	$(AR) rv $@ $(LIBSSH_OBJS)
 	$(RANLIB) $@
 
-ssh$(EXEEXT): $(LIBCOMPAT) libssh.a $(SSHOBJS)
-	$(LD) -o $@ $(SSHOBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(GSSLIBS) $(CHANNELLIBS)
+ssh$(EXEEXT): $(LIBCOMPAT) libssh.a $(SSHOBJS) $(KEYCHAINOBJS)
+	$(LD) -o $@ $(SSHOBJS) $(KEYCHAINOBJS) $(LDFLAGS) $(KEYCHAIN_LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(GSSLIBS) $(CHANNELLIBS)
 
 sshd$(EXEEXT): libssh.a	$(LIBCOMPAT) $(SSHDOBJS)
 	$(LD) -o $@ $(SSHDOBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(SSHDLIBS) $(LIBS) $(GSSLIBS) $(K5LIBS) $(CHANNELLIBS)
@@ -212,11 +219,11 @@ sshd$(EXEEXT): libssh.a	$(LIBCOMPAT) $(SSHDOBJS)
 scp$(EXEEXT): $(LIBCOMPAT) libssh.a $(SCP_OBJS)
 	$(LD) -o $@ $(SCP_OBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
 
-ssh-add$(EXEEXT): $(LIBCOMPAT) libssh.a $(SSHADD_OBJS)
-	$(LD) -o $@ $(SSHADD_OBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(CHANNELLIBS)
+ssh-add$(EXEEXT): $(LIBCOMPAT) libssh.a $(SSHADD_OBJS) $(KEYCHAINOBJS)
+	$(LD) -o $@ $(SSHADD_OBJS) $(KEYCHAINOBJS) $(LDFLAGS) $(KEYCHAIN_LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(CHANNELLIBS)
 
-ssh-agent$(EXEEXT): $(LIBCOMPAT) libssh.a $(SSHAGENT_OBJS)
-	$(LD) -o $@ $(SSHAGENT_OBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(CHANNELLIBS)
+ssh-agent$(EXEEXT): $(LIBCOMPAT) libssh.a $(SSHAGENT_OBJS) $(KEYCHAINOBJS)
+	$(LD) -o $@ $(SSHAGENT_OBJS) $(KEYCHAINOBJS) $(LDFLAGS) $(KEYCHAIN_LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(CHANNELLIBS)
 
 ssh-keygen$(EXEEXT): $(LIBCOMPAT) libssh.a $(SSHKEYGEN_OBJS)
 	$(LD) -o $@ $(SSHKEYGEN_OBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(CHANNELLIBS)
diff --git a/SecItemPriv-shim.h b/SecItemPriv-shim.h
new file mode 100644
index 0000000..966c6c5
--- /dev/null
+++ b/SecItemPriv-shim.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2006-2013 Apple Inc. All Rights Reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_LICENSE_HEADER_END@
+ */
+
+/*
+    @header SecItemPriv
+    SecItemPriv defines private constants and SPI functions for access to
+    Security items (certificates, identities, keys, and keychain items.)
+
+    ====== MACPORTS NOTICE ======
+    Apple uses this private header file for building its OpenSSH keychain
+    integration. They are able to do this because they have either converted
+    all (or most?) upstream projects into Xcode projects and can then use
+    private headers, but our users can't.
+
+    Private header files are never installed onto user systems and there
+    aren't any SDKs that users could install to get them.
+
+    Luckily, the Security Framework *is* (currently) free software, so we do
+    have access to it via https://opensource.apple.com
+
+    We can, hence, take a look at it and copy relevant parts/declarations.
+
+    We cannot, however, make sure that the declarations in here are actually
+    defined in the Security Framework binaries/libraries themselves, so
+    building this part, especially on older systems, might still fail.
+    ====== MACPORTS NOTICE ======
+*/
+
+#ifndef _SECURITY_SECITEMPRIV_H_
+#define _SECURITY_SECITEMPRIV_H_
+
+#include <CoreFoundation/CFDictionary.h>
+#include <CoreFoundation/CFData.h>
+#include <CoreFoundation/CFError.h>
+#include <TargetConditionals.h>
+#include <Security/SecBase.h>
+
+#if ((defined (MAC_OS_X_VERSION_10_7)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7))
+#include <xpc/xpc.h>
+
+#if (TARGET_OS_MAC && !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE))
+#include <Security/SecTask.h>
+#endif
+#endif /* ((defined (MAC_OS_X_VERSION_10_7)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7)) */
+
+__BEGIN_DECLS
+
+/*
+    @enum Attribute Key Constants (Private)
+    @discussion Predefined item attribute keys used to get or set values in a
+        dictionary. Not all attributes apply to each item class. The table
+        below lists the currently defined attributes for each item class:
+
+        @constant kSecAttrNoLegacy Specifies a dictionary key whose
+        value is a CFBooleanRef indicating that the query must be run on the
+        syncable backend even for non syncable items.
+        @constant kSecAttrAccessGroup Specifies a dictionary key whole value is
+        a CFStringRef indicating which access group a item is in.  The access
+        groups that a particular application has access to are determined by
+        an entitlement in that application.
+*/
+
+#if ((defined (MAC_OS_X_VERSION_10_11)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11))
+extern const CFStringRef kSecAttrNoLegacy
+    __OSX_AVAILABLE(10.11) __IOS_AVAILABLE(9.3) __TVOS_AVAILABLE(9.3) __WATCHOS_AVAILABLE(2.3);
+#endif /* ((defined (MAC_OS_X_VERSION_10_11)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11)) */
+
+#if ((!(defined (MAC_OS_X_VERSION_10_8))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_8))
+extern CFTypeRef kSecAttrAccessGroup;
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_8))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_8)) */
+
+#if ((!(defined (MAC_OS_X_VERSION_10_6))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_6))
+/*
+ @enum Class Value Constants (Private)
+ @discussion Predefined item class constants used to get or set values in
+ a dictionary. The kSecClass constant is the key and its value is one
+ of the constants defined here.
+ @constant kSecClassGenericPassword Specifies generic password items.
+ */
+extern const CFTypeRef kSecClassGenericPassword;
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_6))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)) */
+
+__END_DECLS
+
+#endif /* !_SECURITY_SECITEMPRIV_H_ */
diff --git a/audit-bsm.c b/audit-bsm.c
index ccfcf6f..b731402 100644
--- a/audit-bsm.c
+++ b/audit-bsm.c
@@ -62,6 +62,18 @@
 #include <bsm/audit_record.h>
 #include <locale.h>
 
+#ifdef __APPLE__
+#include <AvailabilityMacros.h>
+#if ((defined (MAC_OS_X_VERSION_10_7)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7))
+#include <bsm/audit_session.h>
+#endif /* ((defined (MAC_OS_X_VERSION_10_7)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7)) */
+#include "auth-options.h"
+#include "misc.h"
+#include "servconf.h"
+extern ServerOptions options;
+extern struct sshauthopt *auth_opts;
+#endif
+
 #if defined(HAVE_GETAUDIT_ADDR)
 #define	AuditInfoStruct		auditinfo_addr
 #define AuditInfoTermID		au_tid_addr_t
@@ -306,6 +318,19 @@ bsm_audit_session_setup(void)
 		return;
 	}
 
+#ifdef __APPLE__
+	bzero(&info, sizeof (info));
+#if ((defined (MAC_OS_X_VERSION_10_7)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7))
+	info.ai_flags = AU_SESSION_FLAG_IS_REMOTE;
+	if (the_authctxt->valid)  {
+	    info.ai_flags |=  AU_SESSION_FLAG_HAS_AUTHENTICATED;
+	}
+	if (auth_opts->permit_pty_flag && options.permit_tty) {
+		info.ai_flags |=  AU_SESSION_FLAG_HAS_TTY;
+	}
+#endif /* ((defined (MAC_OS_X_VERSION_10_7)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7)) */
+#endif
+
 	if (the_authctxt->valid)
 		info.ai_auid = the_authctxt->pw->pw_uid;
 	else
diff --git a/configure.ac b/configure.ac
index 22fee70..70e5cb3 100644
--- a/configure.ac
+++ b/configure.ac
@@ -28,6 +28,7 @@ AC_LANG([C])
 
 AC_CONFIG_HEADERS([config.h])
 AC_PROG_CC([cc gcc clang])
+AC_PROG_OBJC([cc clang gcc])
 
 # XXX relax this after reimplementing logit() etc.
 AC_MSG_CHECKING([if $CC supports C99-style variadic macros])
@@ -757,11 +758,11 @@ int main(void) { if (NSVersionOfRunTimeLibrary("System") >= (60 << 16))
 	AC_DEFINE([SSH_TUN_PREPEND_AF], [1],
 	    [Prepend the address family to IP tunnel traffic])
 	m4_pattern_allow([AU_IPv])
-	AC_CHECK_DECL([AU_IPv4], [],
-	    AC_DEFINE([AU_IPv4], [0], [System only supports IPv4 audit records])
-	    [#include <bsm/audit.h>]
-	AC_DEFINE([LASTLOG_WRITE_PUTUTXLINE], [1],
-	    [Define if pututxline updates lastlog too])
+	AC_CHECK_DECL([AU_IPv4],
+	    AC_DEFINE([LASTLOG_WRITE_PUTUTXLINE], [1],
+		[Define if pututxline updates lastlog too]),
+	    AC_DEFINE([AU_IPv4], [0], [System only supports IPv4 audit records]),
+	    [[#include <bsm/audit.h>]]
 	)
 	AC_DEFINE([SPT_TYPE], [SPT_REUSEARGV],
 		[Define to a Set Process Title type if your system is
@@ -5557,6 +5558,34 @@ AC_CHECK_MEMBER([struct utmp.ut_line], [], [
 #endif
 	])
 
+dnl Keychain support
+AC_ARG_WITH(keychain,
+	[  --with-keychain=apple   Use macOS Keychain],
+	[
+		case "$withval" in
+		apple|no)
+			KEYCHAIN=$withval
+			;;
+		*)
+			AC_MSG_ERROR(invalid keychain type: $withval)
+			;;
+		esac
+	]
+)
+if test ! -z "$KEYCHAIN" -a "$KEYCHAIN" != "no"; then
+	case "$KEYCHAIN" in
+	apple)
+		AC_CHECK_HEADERS(Security/Security.h, [
+				CPPFLAGS="$CPPFLAGS -D__APPLE_KEYCHAIN__ -D__APPLE_MEMBERSHIP__ -D__APPLE_TMPDIR__ -D__APPLE_LAUNCHD__"
+				OBJCFLAGS="$OBJCFLAGS -F/System/Library/Frameworks/Security.framework -F/System/Library/Frameworks/DirectoryService.framework -F/System/Library/Frameworks/CoreFoundation.framework"
+				KEYCHAIN_LDFLAGS="-framework Security -framework CoreFoundation -framework Foundation -lobjc"
+				AC_SUBST(KEYCHAIN_LDFLAGS)
+				],
+				AC_MSG_WARN([Security framework not found. Disabling macOS Keychain support.]))
+		;;
+	esac
+fi
+
 dnl Adding -Werror to CFLAGS early prevents configure tests from running.
 dnl Add now.
 CFLAGS="$CFLAGS $werror_flags"
diff --git a/groupaccess.c b/groupaccess.c
index 80d3019..4f62871 100644
--- a/groupaccess.c
+++ b/groupaccess.c
@@ -39,6 +39,10 @@
 #include "match.h"
 #include "log.h"
 
+#ifdef __APPLE_MEMBERSHIP__
+int32_t getgrouplist_2(const char *, gid_t, gid_t **);
+#endif
+
 static int ngroups;
 static char **groups_byname;
 
@@ -56,6 +60,18 @@ ga_init(const char *user, gid_t base)
 	if (ngroups > 0)
 		ga_free();
 
+#ifdef __APPLE_MEMBERSHIP__
+	(void)retry;
+	if ((ngroups = getgrouplist_2(user, base, &groups_bygid)) == -1) {
+		logit("getgrouplist_2 failed");
+		/*
+		 * getgrouplist_2 only fails on memory error; in which case
+		 * groups_bygid will be left NULL so no need to free.
+		 */
+		return 0;
+	}
+	groups_byname = xcalloc(ngroups, sizeof(*groups_byname));
+#else
 	ngroups = NGROUPS_MAX;
 #if defined(HAVE_SYSCONF) && defined(_SC_NGROUPS_MAX)
 	ngroups = MAX(NGROUPS_MAX, sysconf(_SC_NGROUPS_MAX));
@@ -69,6 +85,7 @@ ga_init(const char *user, gid_t base)
 		    sizeof(*groups_bygid));
 	}
 	groups_byname = xcalloc(ngroups, sizeof(*groups_byname));
+#endif /* __APPLE_MEMBERSHIP__ */
 
 	for (i = 0, j = 0; i < ngroups; i++)
 		if ((gr = getgrgid(groups_bygid[i])) != NULL)
diff --git a/keychain.h b/keychain.h
new file mode 100644
index 0000000..b19e382
--- /dev/null
+++ b/keychain.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2007-2016 Apple Inc. All rights reserved.
+ *
+ * @APPLE_BSD_LICENSE_HEADER_START@
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
+ *     contributors may be used to endorse or promote products derived from
+ *     this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * @APPLE_BSD_LICENSE_HEADER_END@
+ */
+
+void	store_in_keychain(const char *filename, const char *passphrase);
+void	remove_from_keychain(const char *filename);
+char	*keychain_read_passphrase(const char *filename);
+int 	load_identities_from_keychain(int (^add_identity)(const char *identity));
diff --git a/keychain.m b/keychain.m
new file mode 100644
index 0000000..c79c8da
--- /dev/null
+++ b/keychain.m
@@ -0,0 +1,444 @@
+/*
+ * Copyright (c) 2007-2016 Apple Inc. All rights reserved.
+ *
+ * @APPLE_BSD_LICENSE_HEADER_START@
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ * 3.  Neither the name of Apple Inc. ("Apple") nor the names of its
+ *     contributors may be used to endorse or promote products derived from
+ *     this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * @APPLE_BSD_LICENSE_HEADER_END@
+ */
+
+#include <AvailabilityMacros.h>
+
+#if ((!(defined (MAC_OS_X_VERSION_10_6))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_6))
+/*
+ * Older versions of sys/acl.h are (arguably) buggy in that the
+ * __APPLE_API_STRICT_CONFORMANCE macro - that we need for proper sandbox code
+ * compilation on older systems (10.7-) - affects (or rather restricts) the
+ * inclusion of macros in sys/kauth.h.
+ *
+ * These macros are then used unconditionally and everything blows up if the
+ * former is set.
+ *
+ * This is not a problem with newer sys/acl.h versions, since these define
+ * internal macros and hence don't rely on the KAUTH_* macros any longer (even
+ * though they still include sys/kauth.h, which strictly speaking is redundant
+ * in such a case).
+ *
+ * Since we don't need to work around any sandbox header bugs in the keychain
+ * integration, let's just drop the former macro.
+ */
+#  ifdef __APPLE_API_STRICT_CONFORMANCE
+#    undef __APPLE_API_STRICT_CONFORMANCE
+#  endif /* defined (__APPLE_API_STRICT_CONFORMANCE) */
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_6))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)) */
+
+#import <Foundation/Foundation.h>
+#import <Security/Security.h>
+#if ((!(defined (MAC_OS_X_VERSION_10_6))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_6))
+/*
+ * On 10.7+, Security.h pulls in SecItem.h.
+ *
+ * Not so on 10.6-, for some reason.
+ */
+#  import <Security/SecItem.h>
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_6))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6)) */
+#import "SecItemPriv-shim.h"
+#include <sys/stat.h>
+#include <stdio.h>
+
+#include "xmalloc.h"
+#include "sshkey.h"
+#include "ssherr.h"
+#include "authfile.h"
+#include "openbsd-compat/openbsd-compat.h"
+#include "log.h"
+
+/*
+ * This code uses Object Subscripting, a new ObjC feature requiring explicit
+ * compiler and library support.
+ *
+ * OS X 10.7- don't support that out of the box, but it's possible to
+ * emulate the behavior on older systems by providing an implementation and
+ * a more recent clang compiler.
+ *
+ * We can provide the implementation directly and will do that, MacPorts'
+ * compiler selection will have to do the second part.
+ *
+ * Yes, importing an implementation is weird, but I'd rather keep the emulation
+ * layer separate.
+ */
+#import "macos-object-subscripting.m"
+
+char *keychain_read_passphrase(const char *filename)
+{
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+	/*
+	 * This NSAutoreleasePool business probably looks weird.
+	 *
+	 * It's actually a workaround for an issue seen on older OS X versions
+	 * (10.7-) when running ssh-add: on those systems, CoreFoundation does
+	 * not generate an automatic global autorelease pool and objects are
+	 * just leaked later on.
+	 * Incidentally, this happens with a nasty message on stderr that
+	 * confuses users.
+	 * libobjc is (probably) right to complain and issue such a warning,
+	 * but then again it doesn't really matter. ssh-add is a simple
+	 * program that is only executed once, does its magic and terminates
+	 * rather quickly. It's improbable, though not impossible, that memory
+	 * leaks would ever create problems for this application.
+	 *
+	 * This said, I'd still like to get rid of the nasty messages and in
+	 * order to do so, I'm creating local NSAutoreleasePool objects in
+	 * each affected function.
+	 *
+	 * Creating them is easy - draining the pool is more complicated,
+	 * because it has to be done before each branching point out of the
+	 * function, i.e., essentially before any return call.
+	 * This makes the code look ugly, but frankly there is no better way
+	 * to achieve the goal. Another option would be to refactor the code
+	 * to only ever use one return statement, but that would blow it up
+	 * and let it diverge from the upstream (Apple) code considerably.
+	 * The second option would be to use local gotos, which, again, does
+	 * not sound like a particularly elegant solution.
+	 *
+	 * We'll just bite the bullet here.
+	 */
+	NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+
+	OSStatus	ret = errSecSuccess;
+	NSString	*accountString = [NSString stringWithUTF8String: filename];
+	NSData		*passphraseData = NULL;
+
+	if (accountString == nil) {
+		debug2("Cannot retrieve identity passphrase from the keychain since the path is not UTF8.");
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+		/*
+		 * For a description of what this block does, refer to the first
+		 * NSAutoreleasePool block in this file.
+		 */
+		[pool drain];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+		return NULL;
+	}
+
+	NSDictionary	*searchQuery = @{
+			       (id)kSecClass: (id)kSecClassGenericPassword,
+			       (id)kSecAttrAccount: accountString,
+			       (id)kSecAttrLabel: [NSString stringWithFormat: @"SSH: %@", accountString],
+			       (id)kSecAttrService: @"OpenSSH",
+#if ((defined (MAC_OS_X_VERSION_10_11)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11))
+			       (id)kSecAttrNoLegacy: @YES,
+			       (id)kSecUseAuthenticationUI: (id)kSecUseAuthenticationUIFail,
+#endif /* ((defined (MAC_OS_X_VERSION_10_11)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11)) */
+			       (id)kSecAttrAccessGroup: @"com.apple.ssh.passphrases",
+			       (id)kSecReturnData: @(YES)};
+	debug3("Search for item with query: %s", [[searchQuery description] UTF8String]);
+	ret = SecItemCopyMatching((CFDictionaryRef)searchQuery, (CFTypeRef *)&passphraseData);
+	if (ret == errSecItemNotFound) {
+		debug2("Passphrase not found in the keychain.");
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+		/*
+		 * For a description of what this block does, refer to the first
+		 * NSAutoreleasePool block in this file.
+		 */
+		[pool drain];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+		return NULL;
+	} else if (ret != errSecSuccess) {
+		NSString *errorString = (NSString *)SecCopyErrorMessageString(ret, NULL);
+		debug2("Unexpected keychain error while searching for an item: %s", [errorString UTF8String]);
+		[errorString release];
+		[passphraseData release];
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+		/*
+		 * For a description of what this block does, refer to the first
+		 * NSAutoreleasePool block in this file.
+		 */
+		[pool drain];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+		return NULL;
+	}
+
+	if (![passphraseData isKindOfClass: [NSData class]]) {
+		debug2("Malformed result returned from the keychain");
+		[passphraseData release];
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+		/*
+		 * For a description of what this block does, refer to the first
+		 * NSAutoreleasePool block in this file.
+		 */
+		[pool drain];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+		return NULL;
+	}
+
+	char *passphrase = xcalloc([passphraseData length] + 1, sizeof(char));
+	[passphraseData getBytes: passphrase length: [passphraseData length]];
+	[passphraseData release];
+
+	// Try to load the key first and only return the passphrase if we know it's the right one
+	struct sshkey *private = NULL;
+	int r = sshkey_load_private_type(KEY_UNSPEC, filename, passphrase, &private, NULL);
+	if (r != SSH_ERR_SUCCESS) {
+		debug2("Could not unlock key with the passphrase retrieved from the keychain.");
+		freezero(passphrase, strlen(passphrase));
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+		/*
+		 * For a description of what this block does, refer to the first
+		 * NSAutoreleasePool block in this file.
+		 */
+		[pool drain];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+		return NULL;
+	}
+	sshkey_free(private);
+
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+	/*
+	 * For a description of what this block does, refer to the first
+	 * NSAutoreleasePool block in this file.
+	 */
+	[pool drain];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+
+	return passphrase;
+}
+
+void store_in_keychain(const char *filename, const char *passphrase)
+{
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+	/*
+	 * For a description of what this block does, refer to the first
+	 * NSAutoreleasePool block in this file.
+	 */
+	NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+
+	OSStatus	ret = errSecSuccess;
+	BOOL		updateExistingItem = NO;
+	NSString	*accountString = [NSString stringWithUTF8String: filename];
+
+	if (accountString == nil) {
+		debug2("Cannot store identity passphrase into the keychain since the path is not UTF8.");
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+		/*
+		 * For a description of what this block does, refer to the first
+		 * NSAutoreleasePool block in this file.
+		 */
+		[pool drain];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+		return;
+	}
+
+	NSDictionary	*defaultAttributes = @{
+				(id)kSecClass: (id)kSecClassGenericPassword,
+				(id)kSecAttrAccount: accountString,
+				(id)kSecAttrLabel: [NSString stringWithFormat: @"SSH: %@", accountString],
+				(id)kSecAttrService: @"OpenSSH",
+#if ((defined (MAC_OS_X_VERSION_10_11)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11))
+				(id)kSecAttrNoLegacy: @YES,
+				(id)kSecUseAuthenticationUI: (id)kSecUseAuthenticationUIFail,
+#endif /* ((defined (MAC_OS_X_VERSION_10_11)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11)) */
+				(id)kSecAttrAccessGroup: @"com.apple.ssh.passphrases"};
+
+	CFTypeRef searchResults = NULL;
+	NSMutableDictionary *searchQuery = [@{(id)kSecReturnRef: @(YES)} mutableCopy];
+	[searchQuery addEntriesFromDictionary: defaultAttributes];
+
+	debug3("Search for existing item with query: %s", [[searchQuery description] UTF8String]);
+	ret = SecItemCopyMatching((CFDictionaryRef)searchQuery, &searchResults);
+	[searchQuery release];
+	if (ret == errSecSuccess) {
+		debug3("Item already exists in the keychain, updating.");
+		updateExistingItem = YES;
+
+	} else if (ret == errSecItemNotFound) {
+		debug3("Item does not exist in the keychain, adding.");
+	} else {
+		NSString *errorString = (NSString *)SecCopyErrorMessageString(ret, NULL);
+		debug3("Unexpected keychain error while searching for an item: %s", [errorString UTF8String]);
+		[errorString release];
+	}
+
+	if (updateExistingItem) {
+		NSDictionary *updateQuery = defaultAttributes;
+		NSDictionary *changes = @{(id)kSecValueData: [NSData dataWithBytesNoCopy: (void *)passphrase length: strlen(passphrase) freeWhenDone: NO]};
+
+		ret = SecItemUpdate((CFDictionaryRef)updateQuery, (CFDictionaryRef)changes);
+		if (ret != errSecSuccess) {
+			NSString *errorString = (NSString *)SecCopyErrorMessageString(ret, NULL);
+			debug3("Unexpected keychain error while updating the item: %s", [errorString UTF8String]);
+			[errorString release];
+		}
+	} else {
+		NSMutableDictionary *addQuery = [@{(id)kSecValueData: [NSData dataWithBytesNoCopy: (void *)passphrase length: strlen(passphrase) freeWhenDone: NO]} mutableCopy];
+
+		[addQuery addEntriesFromDictionary: defaultAttributes];
+		ret = SecItemAdd((CFDictionaryRef)addQuery, NULL);
+		[addQuery release];
+		if (ret != errSecSuccess) {
+			NSString *errorString = (NSString *)SecCopyErrorMessageString(ret, NULL);
+			debug3("Unexpected keychain error while inserting the item: %s", [errorString UTF8String]);
+			[errorString release];
+		}
+	}
+
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+	/*
+	 * For a description of what this block does, refer to the first
+	 * NSAutoreleasePool block in this file.
+	 */
+	[pool drain];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+}
+
+/*
+ * Remove the passphrase for a given identity from the keychain.
+ */
+void
+remove_from_keychain(const char *filename)
+{
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+	/*
+	 * For a description of what this block does, refer to the first
+	 * NSAutoreleasePool block in this file.
+	 */
+	NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+
+	OSStatus	ret = errSecSuccess;
+	NSString	*accountString = [NSString stringWithUTF8String: filename];
+
+	if (accountString == nil) {
+		debug2("Cannot delete identity passphrase from the keychain since the path is not UTF8.");
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+		/*
+		 * For a description of what this block does, refer to the first
+		 * NSAutoreleasePool block in this file.
+		 */
+		[pool drain];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+		return;
+	}
+
+	NSDictionary	*searchQuery = @{
+			       (id)kSecClass: (id)kSecClassGenericPassword,
+			       (id)kSecAttrAccount: accountString,
+			       (id)kSecAttrService: @"OpenSSH",
+#if ((defined (MAC_OS_X_VERSION_10_11)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11))
+			       (id)kSecAttrNoLegacy: @YES,
+			       (id)kSecUseAuthenticationUI: (id)kSecUseAuthenticationUIFail,
+#endif /* ((defined (MAC_OS_X_VERSION_10_11)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11)) */
+			       (id)kSecAttrAccessGroup: @"com.apple.ssh.passphrases"};
+
+	ret = SecItemDelete((CFDictionaryRef)searchQuery);
+	if (ret == errSecSuccess) {
+		NSString *errorString = (NSString *)SecCopyErrorMessageString(ret, NULL);
+		debug3("Unexpected keychain error while deleting the item: %s", [errorString UTF8String]);
+		[errorString release];
+	}
+
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+	/*
+	 * For a description of what this block does, refer to the first
+	 * NSAutoreleasePool block in this file.
+	 */
+	[pool drain];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+}
+
+
+int
+load_identities_from_keychain(int (^add_identity)(const char *identity))
+{
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+	/*
+	 * For a description of what this block does, refer to the first
+	 * NSAutoreleasePool block in this file.
+	 */
+	NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+
+	int 		ret = 0;
+	OSStatus	err = errSecSuccess;
+
+	NSArray		*searchResults = nil;
+	NSDictionary	*searchQuery = @{
+				(id)kSecClass: (id)kSecClassGenericPassword,
+				(id)kSecAttrService: @"OpenSSH",
+#if ((defined (MAC_OS_X_VERSION_10_11)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11))
+				(id)kSecAttrNoLegacy: @YES,
+				(id)kSecUseAuthenticationUI: (id)kSecUseAuthenticationUIFail,
+#endif /* ((defined (MAC_OS_X_VERSION_10_11)) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_11)) */
+				(id)kSecAttrAccessGroup: @"com.apple.ssh.passphrases",
+				(id)kSecReturnAttributes: @(YES),
+				(id)kSecMatchLimit: (id)kSecMatchLimitAll};
+
+	err = SecItemCopyMatching((CFDictionaryRef)searchQuery, (CFTypeRef *)&searchResults);
+	if (err == errSecItemNotFound) {
+		fprintf(stderr, "No identity found in the keychain.\n");
+		[searchResults release];
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+		/*
+		 * For a description of what this block does, refer to the first
+		 * NSAutoreleasePool block in this file.
+		 */
+		[pool drain];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+		return 0;
+	} else if (err != errSecSuccess || ![searchResults isKindOfClass: [NSArray class]]) {
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+		/*
+		 * For a description of what this block does, refer to the first
+		 * NSAutoreleasePool block in this file.
+		 */
+		[pool drain];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+		return 1;
+	}
+
+	for (NSDictionary *itemAttributes in searchResults) {
+		NSString	*accountString = itemAttributes[(id)kSecAttrAccount];
+		struct stat	st;
+
+		if (stat([accountString UTF8String], &st) < 0)
+			continue;
+		if (add_identity([accountString UTF8String]))
+			ret = 1;
+	}
+	[searchResults release];
+
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+	/*
+	 * For a description of what this block does, refer to the first
+	 * NSAutoreleasePool block in this file.
+	 */
+	[pool drain];
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
+
+	return ret;
+}
diff --git a/macos-object-subscripting.m b/macos-object-subscripting.m
new file mode 100644
index 0000000..20cdf5d
--- /dev/null
+++ b/macos-object-subscripting.m
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2017-2019 Mihai Moldovan <ionic@ionic.de>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ * 3.  Neither the name of the copyright holder nor the names of its
+ *     contributors may be used to endorse or promote products derived from
+ *     this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND ITS CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <AvailabilityMacros.h>
+
+#if ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_7))
+
+@implementation NSArray (SubscriptingAdditions)
+- (id)objectAtIndexedSubscript:(NSUInteger)index
+{
+    return [self objectAtIndex:index];
+}
+@end
+
+@implementation NSMutableArray (SubscriptingAdditions)
+- (void)setObject:(id)object atIndexedSubscript:(NSUInteger)index
+{
+    if (index == [self count])
+        [self addObject:object];
+    else
+        [self replaceObjectAtIndex:index withObject:object];
+}
+@end
+
+@implementation  NSDictionary (SubscriptingAdditions)
+- (id)objectForKeyedSubscript:(id)key
+{
+    return [self objectForKey:key];
+}
+@end
+
+@implementation  NSMutableDictionary (SubscriptingAdditions)
+- (void)setObject:(id)object forKeyedSubscript:(id)key
+{
+    [self setObject:object forKey:key];
+}
+@end
+
+#endif /* ((!(defined (MAC_OS_X_VERSION_10_7))) || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)) */
diff --git a/readconf.c b/readconf.c
index 6ded231..44595af 100644
--- a/readconf.c
+++ b/readconf.c
@@ -165,6 +165,9 @@ typedef enum {
 	oHashKnownHosts,
 	oTunnel, oTunnelDevice,
 	oLocalCommand, oPermitLocalCommand, oRemoteCommand,
+#ifdef __APPLE_KEYCHAIN__
+	oUseKeychain,
+#endif
 	oVisualHostKey,
 	oKexAlgorithms, oIPQoS, oRequestTTY, oSessionType, oStdinNull,
 	oForkAfterAuthentication, oIgnoreUnknown, oProxyUseFdpass,
@@ -294,6 +297,9 @@ static struct {
 	{ "localcommand", oLocalCommand },
 	{ "permitlocalcommand", oPermitLocalCommand },
 	{ "remotecommand", oRemoteCommand },
+#ifdef __APPLE_KEYCHAIN__
+	{ "usekeychain", oUseKeychain},
+#endif
 	{ "visualhostkey", oVisualHostKey },
 	{ "kexalgorithms", oKexAlgorithms },
 	{ "ipqos", oIPQoS },
@@ -1845,6 +1851,12 @@ parse_pubkey_algos:
 		charptr = &options->remote_command;
 		goto parse_command;
 
+#ifdef __APPLE_KEYCHAIN__
+	case oUseKeychain:
+		intptr = &options->use_keychain;
+		goto parse_flag;
+#endif
+
 	case oVisualHostKey:
 		intptr = &options->visual_host_key;
 		goto parse_flag;
@@ -2413,6 +2425,9 @@ initialize_options(Options * options)
 	options->local_command = NULL;
 	options->permit_local_command = -1;
 	options->remote_command = NULL;
+#ifdef __APPLE_KEYCHAIN__
+	options->use_keychain = -1;
+#endif
 	options->add_keys_to_agent = -1;
 	options->add_keys_to_agent_lifespan = -1;
 	options->identity_agent = NULL;
@@ -2702,6 +2717,10 @@ fill_default_options(Options * options)
 	/* options->hostname will be set in the main program if appropriate */
 	/* options->host_key_alias should not be set by default */
 	/* options->preferred_authentications will be set in ssh */
+#ifdef __APPLE_KEYCHAIN__
+	if (options->use_keychain == -1)
+		options->use_keychain = 0;
+#endif
 
 	/* success */
 	ret = 0;
diff --git a/readconf.h b/readconf.h
index 2ce1b4c..46362de 100644
--- a/readconf.h
+++ b/readconf.h
@@ -144,6 +144,9 @@ typedef struct {
 	char	*local_command;
 	int	permit_local_command;
 	char	*remote_command;
+#ifdef __APPLE_KEYCHAIN__
+	int	use_keychain;
+#endif
 	int	visual_host_key;
 
 	int	request_tty;
diff --git a/session.c b/session.c
index 89dcfda..968aa17 100644
--- a/session.c
+++ b/session.c
@@ -1184,6 +1184,21 @@ do_setup_env(struct ssh *ssh, Session *s, const char *shell)
 		child_set_env(&env, &envsize, "SSH_ORIGINAL_COMMAND",
 		    original_command);
 
+#ifdef __APPLE_TMPDIR__
+	char tmpdir[MAXPATHLEN] = {0};
+	size_t len = 0;
+
+	len = confstr(_CS_DARWIN_USER_TEMP_DIR, tmpdir, sizeof(tmpdir));
+	if (len > 0) {
+		child_set_env(&env, &envsize, "TMPDIR", tmpdir);
+		debug2("%s: set TMPDIR", __func__);
+	} else {
+		// errno is set by confstr
+		errno = 0;
+		debug2("%s: unable to set TMPDIR", __func__);
+	}
+#endif /* __APPLE_TMPDIR__ */
+
 	if (debug_flag) {
 		/* dump the environment */
 		fprintf(stderr, "Environment:\n");
diff --git a/ssh-add.0
--- a/ssh-add.0	2023-03-15 22:32:25.000000000 +0100
+++ b/ssh-add.0	2023-04-16 21:28:21.000000000 +0200
@@ -4,7 +4,7 @@
      ssh-add M-bM-^@M-^S adds private key identities to the OpenSSH authentication agent
 
 SYNOPSIS
-     ssh-add [-cDdKkLlqvXx] [-E fingerprint_hash] [-H hostkey_file]
+     ssh-add [-AacDdKkLlqvXx] [-E fingerprint_hash] [-H hostkey_file]
              [-h destination_constraint] [-S provider] [-t life] [file ...]
      ssh-add -s pkcs11
      ssh-add -e pkcs11
@@ -29,6 +29,13 @@
 
      The options are as follows:
 
+     -A      Add identities to the agent using any passphrases stored in your
+             macOS keychain.
+
+     -a      When adding identities, each passphrase will also be stored in
+             your macOS keychain.  When removing identities with -d, each
+             passphrase will be removed from your macOS keychain.
+
      -c      Indicates that added identities should be subject to confirmation
              before being used for authentication.  Confirmation is performed
              by ssh-askpass(1).  Successful confirmation is signaled by a zero
diff --git a/ssh-add.1 b/ssh-add.1
index 4601f59..bb55938 100644
--- a/ssh-add.1
+++ b/ssh-add.1
@@ -43,7 +43,7 @@
 .Nd adds private key identities to the OpenSSH authentication agent
 .Sh SYNOPSIS
 .Nm ssh-add
-.Op Fl cDdKkLlqvXx
+.Op Fl AacDdKkLlqvXx
 .Op Fl E Ar fingerprint_hash
 .Op Fl H Ar hostkey_file
 .Op Fl h Ar destination_constraint
@@ -92,6 +92,13 @@ to work.
 .Pp
 The options are as follows:
 .Bl -tag -width Ds
+.It Fl A
+Add identities to the agent using any passphrases stored in your macOS
+keychain.
+.It Fl a
+When adding identities, each passphrase will also be stored in your macOS
+keychain.  When removing identities with -d, each passphrase will be removed
+from your macOS keychain.
 .It Fl c
 Indicates that added identities should be subject to confirmation before
 being used for authentication.
diff --git a/ssh-add.c b/ssh-add.c
index 752b86dfcd8eefa34042de8ad82e0a032d72687c..47e8eb04b547659bd927ce633e8a91c162f8f8f9 100644
--- a/ssh-add.c
+++ b/ssh-add.c
@@ -70,6 +70,11 @@
 #include "sk-api.h"
 #include "hostfile.h"
 
+#ifdef __APPLE_KEYCHAIN__
+#include "keychain.h"
+static int use_keychain = 0;
+#endif
+
 /* argv0 */
 extern char *__progname;
 
@@ -170,6 +175,11 @@ delete_file(int agent_fd, const char *filename, int key_only, int qflag)
 	if (strcmp(filename, "-") == 0)
 		return delete_stdin(agent_fd, qflag);
 
+#ifdef __APPLE_KEYCHAIN__
+	if (use_keychain)
+		remove_from_keychain(filename);
+#endif
+
 	if ((r = sshkey_load_public(filename, &public,  &comment)) != 0) {
 		printf("Bad key file %s: %s\n", filename, ssh_err(r));
 		return -1;
@@ -247,6 +257,11 @@ add_file(int agent_fd, const char *filename, int key_only, int qflag,
 	if (strcmp(filename, "-") == 0) {
 		fd = STDIN_FILENO;
 		filename = "(stdin)";
+#ifdef __APPLE_KEYCHAIN__
+        if (use_keychain) {
+            fprintf(stderr, "Warning: cannot store keys read from stdin in the Keychain\n");
+        }
+#endif
 	} else if ((fd = open(filename, O_RDONLY)) == -1) {
 		perror(filename);
 		return -1;
@@ -286,7 +301,22 @@ add_file(int agent_fd, const char *filename, int key_only, int qflag,
 			    filename, ssh_err(r));
 			goto fail_load;
 		}
+#ifdef __APPLE_KEYCHAIN__
+		if (use_keychain && private != NULL && fd != STDIN_FILENO)
+			store_in_keychain(filename, pass);
+#endif
+	}
+
+#ifdef __APPLE_KEYCHAIN__
+	// try the keychain
+	if (private == NULL && use_keychain) {
+		clear_pass();
+		pass = keychain_read_passphrase(filename);
+		if (pass != NULL)
+			sshkey_parse_private_fileblob(keyblob, pass, &private, &comment);
 	}
+#endif
+
 	if (private == NULL) {
 		/* clear passphrase since it did not work */
 		clear_pass();
@@ -298,7 +328,15 @@ add_file(int agent_fd, const char *filename, int key_only, int qflag,
 				goto fail_load;
 			if ((r = sshkey_parse_private_fileblob(keyblob, pass,
 			    &private, &comment)) == 0)
+#ifdef __APPLE_KEYCHAIN__
+			{
+				if (use_keychain && private != NULL && fd != STDIN_FILENO)
+					store_in_keychain(filename, pass);
 				break;
+			}
+#else
+				break;
+#endif
 			else if (r != SSH_ERR_KEY_WRONG_PASSPHRASE) {
 				fprintf(stderr,
 				    "Error loading key \"%s\": %s\n",
@@ -770,7 +808,7 @@ static void
 usage(void)
 {
 	fprintf(stderr,
-"usage: ssh-add [-cDdKkLlqvXx] [-E fingerprint_hash] [-H hostkey_file]\n"
+"usage: ssh-add [-AacDdKkLlqvXx] [-E fingerprint_hash] [-H hostkey_file]\n"
 "               [-h destination_constraint] [-S provider] [-t life]\n"
 #ifdef WITH_XMSS
 "               [-M maxsign] [-m minleft]\n"
@@ -822,7 +860,11 @@ main(int argc, char **argv)
 
 	skprovider = getenv("SSH_SK_PROVIDER");
 
+#ifdef __APPLE_KEYCHAIN__
+	while ((ch = getopt(argc, argv, "vkKlLcdDTxXE:e:h:H:M:m:qs:S:t:Aa:")) != -1) {
+#else
 	while ((ch = getopt(argc, argv, "vkKlLcdDTxXE:e:h:H:M:m:qs:S:t:")) != -1) {
+#endif
 		switch (ch) {
 		case 'v':
 			if (log_level == SYSLOG_LEVEL_INFO)
@@ -908,6 +950,14 @@ main(int argc, char **argv)
 		case 'T':
 			Tflag = 1;
 			break;
+#ifdef __APPLE_KEYCHAIN__
+		case 'A':
+			use_keychain = 2;
+            break;
+		case 'a':
+			use_keychain = 1;
+			break;
+#endif
 		default:
 			usage();
 			ret = 1;
@@ -950,6 +1000,19 @@ main(int argc, char **argv)
 			  &dest_constraints, &ndest_constraints, hostkey_files);
 		}
 	}
+#ifdef __APPLE_KEYCHAIN__
+    if (use_keychain == 2) {
+        if (load_identities_from_keychain(
+            ^(const char *filename){
+                return do_file(agent_fd, 0, key_only, filename,
+                    qflag, skprovider,
+                    dest_constraints, ndest_constraints); } ) )
+        {
+            ret = 1;
+        }
+        goto done;
+    }
+#endif
 
 	argc -= optind;
 	argv += optind;
diff --git a/sshconnect2.c b/sshconnect2.c
index bc05f02..4951906 100644
--- a/sshconnect2.c
+++ b/sshconnect2.c
@@ -75,6 +75,11 @@
 #include "ssh-sk.h"
 #include "sk-api.h"
 
+#ifdef __APPLE_KEYCHAIN__
+#include "keychain.h"
+int found_in_keychain = 0;
+#endif
+
 #ifdef GSSAPI
 #include "ssh-gss.h"
 #endif
@@ -1543,6 +1548,12 @@ load_identity_file(Identity *id)
 	snprintf(prompt, sizeof prompt,
 	    "Enter passphrase for key '%.100s': ", id->filename);
 	for (i = 0; i <= options.number_of_password_prompts; i++) {
+#ifdef __APPLE_KEYCHAIN__
+		if (i == 0 && options.use_keychain && (passphrase = keychain_read_passphrase(id->filename)) != NULL) {
+			found_in_keychain = 1;
+			debug2("using passphrase from keychain");
+		} else
+#endif
 		if (i == 0)
 			passphrase = "";
 		else {
@@ -1592,6 +1603,14 @@ load_identity_file(Identity *id)
 			private = NULL;
 			quit = 1;
 		}
+
+#ifdef __APPLE_KEYCHAIN__
+		if (!quit && private != NULL && !(id->key && id->isprivate) && options.use_keychain && !found_in_keychain) {
+			debug2("storing passphrase in keychain");
+			store_in_keychain(id->filename, passphrase);
+		}
+#endif
+
 		if (!quit && private != NULL && id->agent_fd == -1 &&
 		    !(id->key && id->isprivate))
 			maybe_add_key_to_agent(id->filename, private, comment,
