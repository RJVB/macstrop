From cabc0eedcbd5c1aa3e09c56968ecdc8b47317c37 Mon Sep 17 00:00:00 2001
From: Simon Wilkinson <simon@sxw.org.uk>
Date: Sun, 9 Feb 2014 16:09:48 +0000
Subject: GSSAPI key exchange support

This patch has been rejected upstream: "None of the OpenSSH developers are
in favour of adding this, and this situation has not changed for several
years.  This is not a slight on Simon's patch, which is of fine quality, but
just that a) we don't trust GSSAPI implementations that much and b) we don't
like adding new KEX since they are pre-auth attack surface.  This one is
particularly scary, since it requires hooks out to typically root-owned
system resources."

However, quite a lot of people rely on this in Debian, and it's better to
have it merged into the main openssh package rather than having separate
-krb5 packages (as we used to have).  It seems to have a generally good
security history.

Author: Simon Wilkinson <simon@sxw.org.uk>
Author: Colin Watson <cjwatson@debian.org>
Author: Jakub Jelen <jjelen@redhat.com>
Origin: other, https://github.com/openssh-gsskex/openssh-gsskex/pull/23
Bug: https://bugzilla.mindrot.org/show_bug.cgi?id=1242
Last-Updated: 2023-12-18

Patch-Name: gssapi.patch
---
 Makefile.in     |   5 +-
 README.md       |  36 +++
 auth.c          |  94 +-------
 auth2-gss.c     |  56 ++++-
 auth2.c         |   2 +
 canohost.c      |  91 ++++++++
 canohost.h      |   3 +
 clientloop.c    |  13 ++
 configure.ac    |  24 ++
 gss-genr.c      | 297 +++++++++++++++++++++++-
 gss-serv-krb5.c |  87 ++++++-
 gss-serv.c      | 205 +++++++++++++++--
 kex.c           |  66 +++++-
 kex.h           |  29 +++
 kexdh.c         |  10 +
 kexgen.c        |   2 +-
 kexgssc.c       | 602 ++++++++++++++++++++++++++++++++++++++++++++++++
 kexgsss.c       | 478 ++++++++++++++++++++++++++++++++++++++
 monitor.c       | 139 ++++++++++-
 monitor.h       |   2 +
 monitor_wrap.c  |  57 ++++-
 monitor_wrap.h  |   4 +-
 readconf.c      |  74 ++++++
 readconf.h      |   6 +
 servconf.c      |  47 ++++
 servconf.h      |   3 +
 session.c       |  10 +-
 ssh-gss.h       |  54 ++++-
 ssh-null.c      | 108 +++++++++
 ssh.1           |   8 +
 ssh.c           |   6 +-
 ssh_config      |   2 +
 ssh_config.5    |  57 +++++
 sshconnect2.c   | 156 ++++++++++++-
 sshd.c          |  62 ++++-
 sshd_config     |   2 +
 sshd_config.5   |  30 +++
 sshkey.c        |   8 +-
 sshkey.h        |   1 +
 39 files changed, 2772 insertions(+), 164 deletions(-)
 create mode 100644 kexgssc.c
 create mode 100644 kexgsss.c
 create mode 100644 ssh-null.c

diff --git a/Makefile.in b/Makefile.in
index 1efe11f6f..f9488099a 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -101,7 +101,7 @@ LIBSSH_OBJS=${LIBOPENSSH_OBJS} \
 	readpass.o ttymodes.o xmalloc.o addr.o addrmatch.o \
 	atomicio.o dispatch.o mac.o misc.o utf8.o \
 	monitor_fdpass.o rijndael.o ssh-dss.o ssh-ecdsa.o ssh-ecdsa-sk.o \
-	ssh-ed25519-sk.o ssh-rsa.o dh.o \
+	ssh-ed25519-sk.o ssh-rsa.o ssh-null.o dh.o \
 	msg.o progressmeter.o dns.o entropy.o gss-genr.o umac.o umac128.o \
 	ssh-pkcs11.o smult_curve25519_ref.o \
 	poly1305.o chacha.o cipher-chachapoly.o cipher-chachapoly-libcrypto.o \
@@ -110,6 +110,7 @@ LIBSSH_OBJS=${LIBOPENSSH_OBJS} \
 	kex.o kexdh.o kexgex.o kexecdh.o kexc25519.o \
 	kexgexc.o kexgexs.o \
 	kexsntrup761x25519.o sntrup761.o kexgen.o \
+	kexgssc.o \
 	sftp-realpath.o platform-pledge.o platform-tracing.o platform-misc.o \
 	sshbuf-io.o
 
@@ -126,7 +127,7 @@ SSHDOBJS=sshd.o auth-rhosts.o auth-passwd.o \
 	auth-bsdauth.o auth2-hostbased.o auth2-kbdint.o \
 	auth2-none.o auth2-passwd.o auth2-pubkey.o auth2-pubkeyfile.o \
 	monitor.o monitor_wrap.o auth-krb5.o \
-	auth2-gss.o gss-serv.o gss-serv-krb5.o \
+	auth2-gss.o gss-serv.o gss-serv-krb5.o kexgsss.o \
 	loginrec.o auth-pam.o auth-shadow.o auth-sia.o \
 	srclimit.o sftp-server.o sftp-common.o \
 	sandbox-null.o sandbox-rlimit.o sandbox-systrace.o sandbox-darwin.o \
diff --git a/README.md b/README.md
index 9431b0ffd..e5051828c 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,39 @@
+Portable OpenSSH with GSSAPI Key Exchange patches
+=================================================
+
+[![Language grade: C/C++](https://img.shields.io/lgtm/grade/cpp/g/openssh-gsskex/openssh-gsskex.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/openssh-gsskex/openssh-gsskex/context:cpp)
+
+Currently, there are two branches with gssapi key exchange related
+patches:
+
+ * fedora/master: Changes that are shipped in Fedora [![Build Status](https://travis-ci.org/openssh-gsskex/openssh-gsskex.svg?branch=fedora%2Fmaster)](https://travis-ci.org/openssh-gsskex/openssh-gsskex)
+ * debian/master: Changes that are shipped in Debian [![Build Status](https://travis-ci.org/openssh-gsskex/openssh-gsskex.svg?branch=debian%2Fmaster)](https://travis-ci.org/openssh-gsskex/openssh-gsskex)
+
+The target is to converge to a shared repository with single master
+branch from where we could build releases for both OSes.
+
+
+What is in:
+
+ * The original patch implementing missing parts of RFC4462 by Simon Wilkinson
+   adapted to the current OpenSSH versions and with several fixes
+ * New methods for GSSAPI Kex from IETF draft [1] from Jakub Jelen
+
+
+Missing kerberos-related parts:
+
+ * .k5login and .kusers support available in Fedora [2] [3].
+ * Improved handling of kerberos ccache location [4]
+
+
+
+[1] https://tools.ietf.org/html/draft-ietf-curdle-gss-keyex-sha2-08
+[2] https://src.fedoraproject.org/rpms/openssh/blob/master/f/openssh-6.6p1-kuserok.patch
+[3] https://src.fedoraproject.org/rpms/openssh/blob/master/f/openssh-6.6p1-GSSAPIEnablek5users.patch
+[4] https://bugzilla.mindrot.org/show_bug.cgi?id=2775
+
+-------------------------------------------------------------------------------
+
 # Portable OpenSSH
 
 [![C/C++ CI](https://github.com/openssh/openssh-portable/actions/workflows/c-cpp.yml/badge.svg)](https://github.com/openssh/openssh-portable/actions/workflows/c-cpp.yml)
diff --git a/auth.c b/auth.c
index 3b380d9bb..8ccf06370 100644
--- a/auth.c
+++ b/auth.c
@@ -357,7 +357,8 @@ auth_root_allowed(struct ssh *ssh, const char *method)
 	case PERMIT_NO_PASSWD:
 		if (strcmp(method, "publickey") == 0 ||
 		    strcmp(method, "hostbased") == 0 ||
-		    strcmp(method, "gssapi-with-mic") == 0)
+		    strcmp(method, "gssapi-with-mic") == 0 ||
+		    strcmp(method, "gssapi-keyex") == 0)
 			return 1;
 		break;
 	case PERMIT_FORCED_ONLY:
@@ -637,97 +638,6 @@ fakepw(void)
 	return (&fake);
 }
 
-/*
- * Returns the remote DNS hostname as a string. The returned string must not
- * be freed. NB. this will usually trigger a DNS query the first time it is
- * called.
- * This function does additional checks on the hostname to mitigate some
- * attacks on based on conflation of hostnames and IP addresses.
- */
-
-static char *
-remote_hostname(struct ssh *ssh)
-{
-	struct sockaddr_storage from;
-	socklen_t fromlen;
-	struct addrinfo hints, *ai, *aitop;
-	char name[NI_MAXHOST], ntop2[NI_MAXHOST];
-	const char *ntop = ssh_remote_ipaddr(ssh);
-
-	/* Get IP address of client. */
-	fromlen = sizeof(from);
-	memset(&from, 0, sizeof(from));
-	if (getpeername(ssh_packet_get_connection_in(ssh),
-	    (struct sockaddr *)&from, &fromlen) == -1) {
-		debug("getpeername failed: %.100s", strerror(errno));
-		return xstrdup(ntop);
-	}
-
-	ipv64_normalise_mapped(&from, &fromlen);
-	if (from.ss_family == AF_INET6)
-		fromlen = sizeof(struct sockaddr_in6);
-
-	debug3("Trying to reverse map address %.100s.", ntop);
-	/* Map the IP address to a host name. */
-	if (getnameinfo((struct sockaddr *)&from, fromlen, name, sizeof(name),
-	    NULL, 0, NI_NAMEREQD) != 0) {
-		/* Host name not found.  Use ip address. */
-		return xstrdup(ntop);
-	}
-
-	/*
-	 * if reverse lookup result looks like a numeric hostname,
-	 * someone is trying to trick us by PTR record like following:
-	 *	1.1.1.10.in-addr.arpa.	IN PTR	2.3.4.5
-	 */
-	memset(&hints, 0, sizeof(hints));
-	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
-	hints.ai_flags = AI_NUMERICHOST;
-	if (getaddrinfo(name, NULL, &hints, &ai) == 0) {
-		logit("Nasty PTR record \"%s\" is set up for %s, ignoring",
-		    name, ntop);
-		freeaddrinfo(ai);
-		return xstrdup(ntop);
-	}
-
-	/* Names are stored in lowercase. */
-	lowercase(name);
-
-	/*
-	 * Map it back to an IP address and check that the given
-	 * address actually is an address of this host.  This is
-	 * necessary because anyone with access to a name server can
-	 * define arbitrary names for an IP address. Mapping from
-	 * name to IP address can be trusted better (but can still be
-	 * fooled if the intruder has access to the name server of
-	 * the domain).
-	 */
-	memset(&hints, 0, sizeof(hints));
-	hints.ai_family = from.ss_family;
-	hints.ai_socktype = SOCK_STREAM;
-	if (getaddrinfo(name, NULL, &hints, &aitop) != 0) {
-		logit("reverse mapping checking getaddrinfo for %.700s "
-		    "[%s] failed.", name, ntop);
-		return xstrdup(ntop);
-	}
-	/* Look for the address from the list of addresses. */
-	for (ai = aitop; ai; ai = ai->ai_next) {
-		if (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop2,
-		    sizeof(ntop2), NULL, 0, NI_NUMERICHOST) == 0 &&
-		    (strcmp(ntop, ntop2) == 0))
-				break;
-	}
-	freeaddrinfo(aitop);
-	/* If we reached the end of the list, the address was not there. */
-	if (ai == NULL) {
-		/* Address not found for the host name. */
-		logit("Address %.100s maps to %.600s, but this does not "
-		    "map back to the address.", ntop, name);
-		return xstrdup(ntop);
-	}
-	return xstrdup(name);
-}
-
 /*
  * Return the canonical name of the host in the other side of the current
  * connection.  The host name is cached, so it is efficient to call this
diff --git a/auth2-gss.c b/auth2-gss.c
index f72a38998..da3bf99c1 100644
--- a/auth2-gss.c
+++ b/auth2-gss.c
@@ -1,7 +1,7 @@
 /* $OpenBSD: auth2-gss.c,v 1.34 2023/03/31 04:22:27 djm Exp $ */
 
 /*
- * Copyright (c) 2001-2003 Simon Wilkinson. All rights reserved.
+ * Copyright (c) 2001-2007 Simon Wilkinson. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -57,6 +57,48 @@ static int input_gssapi_mic(int type, u_int32_t plen, struct ssh *ssh);
 static int input_gssapi_exchange_complete(int type, u_int32_t plen, struct ssh *ssh);
 static int input_gssapi_errtok(int, u_int32_t, struct ssh *);
 
+/*
+ * The 'gssapi_keyex' userauth mechanism.
+ */
+static int
+userauth_gsskeyex(struct ssh *ssh)
+{
+	Authctxt *authctxt = ssh->authctxt;
+	int r, authenticated = 0;
+	struct sshbuf *b = NULL;
+	gss_buffer_desc mic, gssbuf;
+	u_char *p;
+	size_t len;
+
+	if ((r = sshpkt_get_string(ssh, &p, &len)) != 0 ||
+	    (r = sshpkt_get_end(ssh)) != 0)
+		fatal_fr(r, "parsing");
+
+	if ((b = sshbuf_new()) == NULL)
+		fatal_f("sshbuf_new failed");
+
+	mic.value = p;
+	mic.length = len;
+
+	ssh_gssapi_buildmic(b, authctxt->user, authctxt->service,
+	    "gssapi-keyex", ssh->kex->session_id);
+
+	if ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)
+		fatal_f("sshbuf_mutable_ptr failed");
+	gssbuf.length = sshbuf_len(b);
+
+	/* gss_kex_context is NULL with privsep, so we can't check it here */
+	if (!GSS_ERROR(PRIVSEP(ssh_gssapi_checkmic(gss_kex_context,
+	    &gssbuf, &mic))))
+		authenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user,
+		    authctxt->pw, 1));
+
+	sshbuf_free(b);
+	free(mic.value);
+
+	return (authenticated);
+}
+
 /*
  * We only support those mechanisms that we know about (ie ones that we know
  * how to check local user kuserok and the like)
@@ -267,7 +309,8 @@ input_gssapi_exchange_complete(int type, u_int32_t plen, struct ssh *ssh)
 	if ((r = sshpkt_get_end(ssh)) != 0)
 		fatal_fr(r, "parse packet");
 
-	authenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user));
+	authenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user,
+	    authctxt->pw, 1));
 
 	if ((!use_privsep || mm_is_monitor()) &&
 	    (displayname = ssh_gssapi_displayname()) != NULL)
@@ -313,7 +356,8 @@ input_gssapi_mic(int type, u_int32_t plen, struct ssh *ssh)
 	gssbuf.length = sshbuf_len(b);
 
 	if (!GSS_ERROR(PRIVSEP(ssh_gssapi_checkmic(gssctxt, &gssbuf, &mic))))
-		authenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user));
+		authenticated = PRIVSEP(ssh_gssapi_userok(authctxt->user,
+		    authctxt->pw, 0));
 	else
 		logit("GSSAPI MIC check failed");
 
@@ -333,6 +377,12 @@ input_gssapi_mic(int type, u_int32_t plen, struct ssh *ssh)
 	return 0;
 }
 
+Authmethod method_gsskeyex = {
+	"gssapi-keyex",
+	userauth_gsskeyex,
+	&options.gss_authentication
+};
+
 Authmethod method_gssapi = {
 	"gssapi-with-mic",
 	NULL,
diff --git a/auth2.c b/auth2.c
index 271789a77..514a697ca 100644
--- a/auth2.c
+++ b/auth2.c
@@ -71,6 +71,7 @@ extern Authmethod method_passwd;
 extern Authmethod method_kbdint;
 extern Authmethod method_hostbased;
 #ifdef GSSAPI
+extern Authmethod method_gsskeyex;
 extern Authmethod method_gssapi;
 #endif
 
@@ -78,6 +79,7 @@ Authmethod *authmethods[] = {
 	&method_none,
 	&method_pubkey,
 #ifdef GSSAPI
+	&method_gsskeyex,
 	&method_gssapi,
 #endif
 	&method_passwd,
diff --git a/canohost.c b/canohost.c
index 28f086e5a..33213ab05 100644
--- a/canohost.c
+++ b/canohost.c
@@ -35,6 +35,97 @@
 #include "canohost.h"
 #include "misc.h"
 
+/*
+ * Returns the remote DNS hostname as a string. The returned string must not
+ * be freed. NB. this will usually trigger a DNS query the first time it is
+ * called.
+ * This function does additional checks on the hostname to mitigate some
+ * attacks on legacy rhosts-style authentication.
+ */
+
+char *
+remote_hostname(struct ssh *ssh)
+{
+	struct sockaddr_storage from;
+	socklen_t fromlen;
+	struct addrinfo hints, *ai, *aitop;
+	char name[NI_MAXHOST], ntop2[NI_MAXHOST];
+	const char *ntop = ssh_remote_ipaddr(ssh);
+
+	/* Get IP address of client. */
+	fromlen = sizeof(from);
+	memset(&from, 0, sizeof(from));
+	if (getpeername(ssh_packet_get_connection_in(ssh),
+	    (struct sockaddr *)&from, &fromlen) == -1) {
+		debug("getpeername failed: %.100s", strerror(errno));
+		return xstrdup(ntop);
+	}
+
+	ipv64_normalise_mapped(&from, &fromlen);
+	if (from.ss_family == AF_INET6)
+		fromlen = sizeof(struct sockaddr_in6);
+
+	debug3("Trying to reverse map address %.100s.", ntop);
+	/* Map the IP address to a host name. */
+	if (getnameinfo((struct sockaddr *)&from, fromlen, name, sizeof(name),
+	    NULL, 0, NI_NAMEREQD) != 0) {
+		/* Host name not found.  Use ip address. */
+		return xstrdup(ntop);
+	}
+
+	/*
+	 * if reverse lookup result looks like a numeric hostname,
+	 * someone is trying to trick us by PTR record like following:
+	 *	1.1.1.10.in-addr.arpa.	IN PTR	2.3.4.5
+	 */
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
+	hints.ai_flags = AI_NUMERICHOST;
+	if (getaddrinfo(name, NULL, &hints, &ai) == 0) {
+		logit("Nasty PTR record \"%s\" is set up for %s, ignoring",
+		    name, ntop);
+		freeaddrinfo(ai);
+		return xstrdup(ntop);
+	}
+
+	/* Names are stored in lowercase. */
+	lowercase(name);
+
+	/*
+	 * Map it back to an IP address and check that the given
+	 * address actually is an address of this host.  This is
+	 * necessary because anyone with access to a name server can
+	 * define arbitrary names for an IP address. Mapping from
+	 * name to IP address can be trusted better (but can still be
+	 * fooled if the intruder has access to the name server of
+	 * the domain).
+	 */
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = from.ss_family;
+	hints.ai_socktype = SOCK_STREAM;
+	if (getaddrinfo(name, NULL, &hints, &aitop) != 0) {
+		logit("reverse mapping checking getaddrinfo for %.700s "
+		    "[%s] failed.", name, ntop);
+		return xstrdup(ntop);
+	}
+	/* Look for the address from the list of addresses. */
+	for (ai = aitop; ai; ai = ai->ai_next) {
+		if (getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop2,
+		    sizeof(ntop2), NULL, 0, NI_NUMERICHOST) == 0 &&
+		    (strcmp(ntop, ntop2) == 0))
+				break;
+	}
+	freeaddrinfo(aitop);
+	/* If we reached the end of the list, the address was not there. */
+	if (ai == NULL) {
+		/* Address not found for the host name. */
+		logit("Address %.100s maps to %.600s, but this does not "
+		    "map back to the address.", ntop, name);
+		return xstrdup(ntop);
+	}
+	return xstrdup(name);
+}
+
 void
 ipv64_normalise_mapped(struct sockaddr_storage *addr, socklen_t *len)
 {
diff --git a/canohost.h b/canohost.h
index 26d62855a..0cadc9f18 100644
--- a/canohost.h
+++ b/canohost.h
@@ -15,6 +15,9 @@
 #ifndef _CANOHOST_H
 #define _CANOHOST_H
 
+struct ssh;
+
+char		*remote_hostname(struct ssh *);
 char		*get_peer_ipaddr(int);
 int		 get_peer_port(int);
 char		*get_local_ipaddr(int);
diff --git a/clientloop.c b/clientloop.c
index eb4902905..1ffe685a3 100644
--- a/clientloop.c
+++ b/clientloop.c
@@ -115,6 +115,10 @@
 #include "ssherr.h"
 #include "hostfile.h"
 
+#ifdef GSSAPI
+#include "ssh-gss.h"
+#endif
+
 /* Permitted RSA signature algorithms for UpdateHostkeys proofs */
 #define HOSTKEY_PROOF_RSA_ALGS	"rsa-sha2-512,rsa-sha2-256"
 
@@ -1594,6 +1598,15 @@ client_loop(struct ssh *ssh, int have_pty, int escape_char_arg,
 		/* Do channel operations. */
 		channel_after_poll(ssh, pfd, npfd_active);
 
+#ifdef GSSAPI
+		if (!ssh_packet_is_rekeying(ssh) &&
+		    options.gss_renewal_rekey &&
+		    ssh_gssapi_credentials_updated(NULL)) {
+			debug("credentials updated - forcing rekey");
+			need_rekeying = 1;
+		}
+#endif
+
 		/* Buffer input from the connection.  */
 		if (conn_in_ready)
 			client_process_net_input(ssh);
diff --git a/configure.ac b/configure.ac
index 379cd746b..2aeab040c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -766,6 +766,30 @@ int main(void) { if (NSVersionOfRunTimeLibrary("System") >= (60 << 16))
 	    [Use tunnel device compatibility to OpenBSD])
 	AC_DEFINE([SSH_TUN_PREPEND_AF], [1],
 	    [Prepend the address family to IP tunnel traffic])
+	AC_MSG_CHECKING([if we have the Security Authorization Session API])
+	AC_TRY_COMPILE([#include <Security/AuthSession.h>],
+		[SessionCreate(0, 0);],
+		[ac_cv_use_security_session_api="yes"
+		 AC_DEFINE([USE_SECURITY_SESSION_API], [1],
+			[platform has the Security Authorization Session API])
+		 LIBS="$LIBS -framework Security"
+		 AC_MSG_RESULT([yes])],
+		[ac_cv_use_security_session_api="no"
+		 AC_MSG_RESULT([no])])
+	AC_MSG_CHECKING([if we have an in-memory credentials cache])
+	AC_TRY_COMPILE(
+		[#include <Kerberos/Kerberos.h>],
+		[cc_context_t c;
+		 (void) cc_initialize (&c, 0, NULL, NULL);],
+		[AC_DEFINE([USE_CCAPI], [1],
+			[platform uses an in-memory credentials cache])
+		 LIBS="$LIBS -framework Security"
+		 AC_MSG_RESULT([yes])
+		 if test "x$ac_cv_use_security_session_api" = "xno"; then
+			AC_MSG_ERROR([*** Need a security framework to use the credentials cache API ***])
+		fi],
+		[AC_MSG_RESULT([no])]
+	)
 	m4_pattern_allow([AU_IPv])
 	AC_CHECK_DECL([AU_IPv4], [],
 	    AC_DEFINE([AU_IPv4], [0], [System only supports IPv4 audit records])
diff --git a/gss-genr.c b/gss-genr.c
index 2cd695e54..9f9745b7f 100644
--- a/gss-genr.c
+++ b/gss-genr.c
@@ -1,7 +1,7 @@
 /* $OpenBSD: gss-genr.c,v 1.28 2021/01/27 10:05:28 djm Exp $ */
 
 /*
- * Copyright (c) 2001-2007 Simon Wilkinson. All rights reserved.
+ * Copyright (c) 2001-2009 Simon Wilkinson. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -42,9 +42,33 @@
 #include "sshbuf.h"
 #include "log.h"
 #include "ssh2.h"
+#include "cipher.h"
+#include "sshkey.h"
+#include "kex.h"
+#include "digest.h"
+#include "packet.h"
 
 #include "ssh-gss.h"
 
+typedef struct {
+	char *encoded;
+	gss_OID oid;
+} ssh_gss_kex_mapping;
+
+/*
+ * XXX - It would be nice to find a more elegant way of handling the
+ * XXX   passing of the key exchange context to the userauth routines
+ */
+
+Gssctxt *gss_kex_context = NULL;
+
+static ssh_gss_kex_mapping *gss_enc2oid = NULL;
+
+int
+ssh_gssapi_oid_table_ok(void) {
+	return (gss_enc2oid != NULL);
+}
+
 /* sshbuf_get for gss_buffer_desc */
 int
 ssh_gssapi_get_buffer_desc(struct sshbuf *b, gss_buffer_desc *g)
@@ -60,6 +84,159 @@ ssh_gssapi_get_buffer_desc(struct sshbuf *b, gss_buffer_desc *g)
 	return 0;
 }
 
+/* sshpkt_get of gss_buffer_desc */
+int
+ssh_gssapi_sshpkt_get_buffer_desc(struct ssh *ssh, gss_buffer_desc *g)
+{
+	int r;
+	u_char *p;
+	size_t len;
+
+	if ((r = sshpkt_get_string(ssh, &p, &len)) != 0)
+		return r;
+	g->value = p;
+	g->length = len;
+	return 0;
+}
+
+/*
+ * Return a list of the gss-group1-sha1 mechanisms supported by this program
+ *
+ * We test mechanisms to ensure that we can use them, to avoid starting
+ * a key exchange with a bad mechanism
+ */
+
+char *
+ssh_gssapi_client_mechanisms(const char *host, const char *client,
+    const char *kex) {
+	gss_OID_set gss_supported = NULL;
+	OM_uint32 min_status;
+
+	if (GSS_ERROR(gss_indicate_mechs(&min_status, &gss_supported)))
+		return NULL;
+
+	return ssh_gssapi_kex_mechs(gss_supported, ssh_gssapi_check_mechanism,
+	    host, client, kex);
+}
+
+char *
+ssh_gssapi_kex_mechs(gss_OID_set gss_supported, ssh_gssapi_check_fn *check,
+    const char *host, const char *client, const char *kex) {
+	struct sshbuf *buf = NULL;
+	size_t i;
+	int r = SSH_ERR_ALLOC_FAIL;
+	int oidpos, enclen;
+	char *mechs, *encoded;
+	u_char digest[SSH_DIGEST_MAX_LENGTH];
+	char deroid[2];
+	struct ssh_digest_ctx *md = NULL;
+	char *s, *cp, *p;
+
+	if (gss_enc2oid != NULL) {
+		for (i = 0; gss_enc2oid[i].encoded != NULL; i++)
+			free(gss_enc2oid[i].encoded);
+		free(gss_enc2oid);
+	}
+
+	gss_enc2oid = xmalloc(sizeof(ssh_gss_kex_mapping) *
+	    (gss_supported->count + 1));
+
+	if ((buf = sshbuf_new()) == NULL)
+		fatal_f("sshbuf_new failed");
+
+	oidpos = 0;
+	s = cp = xstrdup(kex);
+	for (i = 0; i < gss_supported->count; i++) {
+		if (gss_supported->elements[i].length < 128 &&
+		    (*check)(NULL, &(gss_supported->elements[i]), host, client)) {
+
+			deroid[0] = SSH_GSS_OIDTYPE;
+			deroid[1] = gss_supported->elements[i].length;
+
+			if ((md = ssh_digest_start(SSH_DIGEST_MD5)) == NULL ||
+			    (r = ssh_digest_update(md, deroid, 2)) != 0 ||
+			    (r = ssh_digest_update(md,
+			        gss_supported->elements[i].elements,
+			        gss_supported->elements[i].length)) != 0 ||
+			    (r = ssh_digest_final(md, digest, sizeof(digest))) != 0)
+				fatal_fr(r, "digest failed");
+			ssh_digest_free(md);
+			md = NULL;
+
+			encoded = xmalloc(ssh_digest_bytes(SSH_DIGEST_MD5)
+			    * 2);
+			enclen = __b64_ntop(digest,
+			    ssh_digest_bytes(SSH_DIGEST_MD5), encoded,
+			    ssh_digest_bytes(SSH_DIGEST_MD5) * 2);
+
+			cp = strncpy(s, kex, strlen(kex));
+			for ((p = strsep(&cp, ",")); p && *p != '\0';
+				(p = strsep(&cp, ","))) {
+				if (sshbuf_len(buf) != 0 &&
+				    (r = sshbuf_put_u8(buf, ',')) != 0)
+					fatal_fr(r, "sshbuf_put_u8 error");
+				if ((r = sshbuf_put(buf, p, strlen(p))) != 0 ||
+				    (r = sshbuf_put(buf, encoded, enclen)) != 0)
+					fatal_fr(r, "sshbuf_put error");
+			}
+
+			gss_enc2oid[oidpos].oid = &(gss_supported->elements[i]);
+			gss_enc2oid[oidpos].encoded = encoded;
+			oidpos++;
+		}
+	}
+	free(s);
+	gss_enc2oid[oidpos].oid = NULL;
+	gss_enc2oid[oidpos].encoded = NULL;
+
+	if ((mechs = sshbuf_dup_string(buf)) == NULL)
+		fatal_f("sshbuf_dup_string failed");
+
+	sshbuf_free(buf);
+
+	if (strlen(mechs) == 0) {
+		free(mechs);
+		mechs = NULL;
+	}
+
+	return (mechs);
+}
+
+gss_OID
+ssh_gssapi_id_kex(Gssctxt *ctx, char *name, int kex_type) {
+	int i = 0;
+
+#define SKIP_KEX_NAME(type) \
+	case type: \
+		if (strlen(name) < sizeof(type##_ID)) \
+			return GSS_C_NO_OID; \
+		name += sizeof(type##_ID) - 1; \
+		break;
+
+	switch (kex_type) {
+	SKIP_KEX_NAME(KEX_GSS_GRP1_SHA1)
+	SKIP_KEX_NAME(KEX_GSS_GRP14_SHA1)
+	SKIP_KEX_NAME(KEX_GSS_GRP14_SHA256)
+	SKIP_KEX_NAME(KEX_GSS_GRP16_SHA512)
+	SKIP_KEX_NAME(KEX_GSS_GEX_SHA1)
+	SKIP_KEX_NAME(KEX_GSS_NISTP256_SHA256)
+	SKIP_KEX_NAME(KEX_GSS_C25519_SHA256)
+	default:
+		return GSS_C_NO_OID;
+	}
+
+#undef SKIP_KEX_NAME
+
+	while (gss_enc2oid[i].encoded != NULL &&
+	    strcmp(name, gss_enc2oid[i].encoded) != 0)
+		i++;
+
+	if (gss_enc2oid[i].oid != NULL && ctx != NULL)
+		ssh_gssapi_set_oid(ctx, gss_enc2oid[i].oid);
+
+	return gss_enc2oid[i].oid;
+}
+
 /* Check that the OID in a data stream matches that in the context */
 int
 ssh_gssapi_check_oid(Gssctxt *ctx, void *data, size_t len)
@@ -216,7 +393,7 @@ ssh_gssapi_init_ctx(Gssctxt *ctx, int deleg_creds, gss_buffer_desc *recv_tok,
 	}
 
 	ctx->major = gss_init_sec_context(&ctx->minor,
-	    GSS_C_NO_CREDENTIAL, &ctx->context, ctx->name, ctx->oid,
+	    ctx->client_creds, &ctx->context, ctx->name, ctx->oid,
 	    GSS_C_MUTUAL_FLAG | GSS_C_INTEG_FLAG | deleg_flag,
 	    0, NULL, recv_tok, NULL, send_tok, flags, NULL);
 
@@ -245,9 +422,43 @@ ssh_gssapi_import_name(Gssctxt *ctx, const char *host)
 	return (ctx->major);
 }
 
+OM_uint32
+ssh_gssapi_client_identity(Gssctxt *ctx, const char *name)
+{
+	gss_buffer_desc gssbuf;
+	gss_name_t gssname;
+	OM_uint32 status;
+	gss_OID_set oidset;
+
+	gssbuf.value = (void *) name;
+	gssbuf.length = strlen(gssbuf.value);
+
+	gss_create_empty_oid_set(&status, &oidset);
+	gss_add_oid_set_member(&status, ctx->oid, &oidset);
+
+	ctx->major = gss_import_name(&ctx->minor, &gssbuf,
+	    GSS_C_NT_USER_NAME, &gssname);
+
+	if (!ctx->major)
+		ctx->major = gss_acquire_cred(&ctx->minor,
+		    gssname, 0, oidset, GSS_C_INITIATE,
+		    &ctx->client_creds, NULL, NULL);
+
+	gss_release_name(&status, &gssname);
+	gss_release_oid_set(&status, &oidset);
+
+	if (ctx->major)
+		ssh_gssapi_error(ctx);
+
+	return(ctx->major);
+}
+
 OM_uint32
 ssh_gssapi_sign(Gssctxt *ctx, gss_buffer_t buffer, gss_buffer_t hash)
 {
+	if (ctx == NULL)
+		return -1;
+
 	if ((ctx->major = gss_get_mic(&ctx->minor, ctx->context,
 	    GSS_C_QOP_DEFAULT, buffer, hash)))
 		ssh_gssapi_error(ctx);
@@ -255,6 +466,19 @@ ssh_gssapi_sign(Gssctxt *ctx, gss_buffer_t buffer, gss_buffer_t hash)
 	return (ctx->major);
 }
 
+/* Priviledged when used by server */
+OM_uint32
+ssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)
+{
+	if (ctx == NULL)
+		return -1;
+
+	ctx->major = gss_verify_mic(&ctx->minor, ctx->context,
+	    gssbuf, gssmic, NULL);
+
+	return (ctx->major);
+}
+
 void
 ssh_gssapi_buildmic(struct sshbuf *b, const char *user, const char *service,
     const char *context, const struct sshbuf *session_id)
@@ -271,11 +495,16 @@ ssh_gssapi_buildmic(struct sshbuf *b, const char *user, const char *service,
 }
 
 int
-ssh_gssapi_check_mechanism(Gssctxt **ctx, gss_OID oid, const char *host)
+ssh_gssapi_check_mechanism(Gssctxt **ctx, gss_OID oid, const char *host,
+    const char *client)
 {
 	gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
 	OM_uint32 major, minor;
 	gss_OID_desc spnego_oid = {6, (void *)"\x2B\x06\x01\x05\x05\x02"};
+	Gssctxt *intctx = NULL;
+
+	if (ctx == NULL)
+		ctx = &intctx;
 
 	/* RFC 4462 says we MUST NOT do SPNEGO */
 	if (oid->length == spnego_oid.length && 
@@ -285,6 +514,10 @@ ssh_gssapi_check_mechanism(Gssctxt **ctx, gss_OID oid, const char *host)
 	ssh_gssapi_build_ctx(ctx);
 	ssh_gssapi_set_oid(*ctx, oid);
 	major = ssh_gssapi_import_name(*ctx, host);
+
+	if (!GSS_ERROR(major) && client)
+		major = ssh_gssapi_client_identity(*ctx, client);
+
 	if (!GSS_ERROR(major)) {
 		major = ssh_gssapi_init_ctx(*ctx, 0, GSS_C_NO_BUFFER, &token, 
 		    NULL);
@@ -294,10 +527,66 @@ ssh_gssapi_check_mechanism(Gssctxt **ctx, gss_OID oid, const char *host)
 			    GSS_C_NO_BUFFER);
 	}
 
-	if (GSS_ERROR(major)) 
+	if (GSS_ERROR(major) || intctx != NULL)
 		ssh_gssapi_delete_ctx(ctx);
 
 	return (!GSS_ERROR(major));
 }
 
+int
+ssh_gssapi_credentials_updated(Gssctxt *ctxt) {
+	static gss_name_t saved_name = GSS_C_NO_NAME;
+	static OM_uint32 saved_lifetime = 0;
+	static gss_OID saved_mech = GSS_C_NO_OID;
+	static gss_name_t name;
+	static OM_uint32 last_call = 0;
+	OM_uint32 lifetime, now, major, minor;
+	int equal;
+
+	now = time(NULL);
+
+	if (ctxt) {
+		debug("Rekey has happened - updating saved versions");
+
+		if (saved_name != GSS_C_NO_NAME)
+			gss_release_name(&minor, &saved_name);
+
+		major = gss_inquire_cred(&minor, GSS_C_NO_CREDENTIAL,
+		    &saved_name, &saved_lifetime, NULL, NULL);
+
+		if (!GSS_ERROR(major)) {
+			saved_mech = ctxt->oid;
+		        saved_lifetime+= now;
+		} else {
+			/* Handle the error */
+		}
+		return 0;
+	}
+
+	if (now - last_call < 10)
+		return 0;
+
+	last_call = now;
+
+	if (saved_mech == GSS_C_NO_OID)
+		return 0;
+
+	major = gss_inquire_cred(&minor, GSS_C_NO_CREDENTIAL,
+	    &name, &lifetime, NULL, NULL);
+	if (major == GSS_S_CREDENTIALS_EXPIRED)
+		return 0;
+	else if (GSS_ERROR(major))
+		return 0;
+
+	major = gss_compare_name(&minor, saved_name, name, &equal);
+	gss_release_name(&minor, &name);
+	if (GSS_ERROR(major))
+		return 0;
+
+	if (equal && (saved_lifetime < lifetime + now - 10))
+		return 1;
+
+	return 0;
+}
+
 #endif /* GSSAPI */
diff --git a/gss-serv-krb5.c b/gss-serv-krb5.c
index a151bc1e4..ef20401ec 100644
--- a/gss-serv-krb5.c
+++ b/gss-serv-krb5.c
@@ -1,7 +1,7 @@
 /* $OpenBSD: gss-serv-krb5.c,v 1.9 2018/07/09 21:37:55 markus Exp $ */
 
 /*
- * Copyright (c) 2001-2003 Simon Wilkinson. All rights reserved.
+ * Copyright (c) 2001-2007 Simon Wilkinson. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -120,7 +120,7 @@ ssh_gssapi_krb5_storecreds(ssh_gssapi_client *client)
 	krb5_error_code problem;
 	krb5_principal princ;
 	OM_uint32 maj_status, min_status;
-	int len;
+	const char *new_ccname;
 	const char *errmsg;
 
 	if (client->creds == NULL) {
@@ -180,11 +180,16 @@ ssh_gssapi_krb5_storecreds(ssh_gssapi_client *client)
 		return;
 	}
 
-	client->store.filename = xstrdup(krb5_cc_get_name(krb_context, ccache));
+	new_ccname = krb5_cc_get_name(krb_context, ccache);
+
 	client->store.envvar = "KRB5CCNAME";
-	len = strlen(client->store.filename) + 6;
-	client->store.envval = xmalloc(len);
-	snprintf(client->store.envval, len, "FILE:%s", client->store.filename);
+#ifdef USE_CCAPI
+	xasprintf(&client->store.envval, "API:%s", new_ccname);
+	client->store.filename = NULL;
+#else
+	xasprintf(&client->store.envval, "FILE:%s", new_ccname);
+	client->store.filename = xstrdup(new_ccname);
+#endif
 
 #ifdef USE_PAM
 	if (options.use_pam)
@@ -193,9 +198,76 @@ ssh_gssapi_krb5_storecreds(ssh_gssapi_client *client)
 
 	krb5_cc_close(krb_context, ccache);
 
+	client->store.data = krb_context;
+
 	return;
 }
 
+int
+ssh_gssapi_krb5_updatecreds(ssh_gssapi_ccache *store,
+    ssh_gssapi_client *client)
+{
+	krb5_ccache ccache = NULL;
+	krb5_principal principal = NULL;
+	char *name = NULL;
+	krb5_error_code problem;
+	OM_uint32 maj_status, min_status;
+
+	if ((problem = krb5_cc_resolve(krb_context, store->envval, &ccache))) {
+                logit("krb5_cc_resolve(): %.100s",
+                    krb5_get_err_text(krb_context, problem));
+                return 0;
+	}
+
+	/* Find out who the principal in this cache is */
+	if ((problem = krb5_cc_get_principal(krb_context, ccache,
+	    &principal))) {
+		logit("krb5_cc_get_principal(): %.100s",
+		    krb5_get_err_text(krb_context, problem));
+		krb5_cc_close(krb_context, ccache);
+		return 0;
+	}
+
+	if ((problem = krb5_unparse_name(krb_context, principal, &name))) {
+		logit("krb5_unparse_name(): %.100s",
+		    krb5_get_err_text(krb_context, problem));
+		krb5_free_principal(krb_context, principal);
+		krb5_cc_close(krb_context, ccache);
+		return 0;
+	}
+
+
+	if (strcmp(name,client->exportedname.value)!=0) {
+		debug("Name in local credentials cache differs. Not storing");
+		krb5_free_principal(krb_context, principal);
+		krb5_cc_close(krb_context, ccache);
+		krb5_free_unparsed_name(krb_context, name);
+		return 0;
+	}
+	krb5_free_unparsed_name(krb_context, name);
+
+	/* Name matches, so lets get on with it! */
+
+	if ((problem = krb5_cc_initialize(krb_context, ccache, principal))) {
+		logit("krb5_cc_initialize(): %.100s",
+		    krb5_get_err_text(krb_context, problem));
+		krb5_free_principal(krb_context, principal);
+		krb5_cc_close(krb_context, ccache);
+		return 0;
+	}
+
+	krb5_free_principal(krb_context, principal);
+
+	if ((maj_status = gss_krb5_copy_ccache(&min_status, client->creds,
+	    ccache))) {
+		logit("gss_krb5_copy_ccache() failed. Sorry!");
+		krb5_cc_close(krb_context, ccache);
+		return 0;
+	}
+
+	return 1;
+}
+
 ssh_gssapi_mech gssapi_kerberos_mech = {
 	"toWM5Slw5Ew8Mqkay+al2g==",
 	"Kerberos",
@@ -203,7 +275,8 @@ ssh_gssapi_mech gssapi_kerberos_mech = {
 	NULL,
 	&ssh_gssapi_krb5_userok,
 	NULL,
-	&ssh_gssapi_krb5_storecreds
+	&ssh_gssapi_krb5_storecreds,
+	&ssh_gssapi_krb5_updatecreds
 };
 
 #endif /* KRB5 */
diff --git a/gss-serv.c b/gss-serv.c
index 00e3d118b..162fec447 100644
--- a/gss-serv.c
+++ b/gss-serv.c
@@ -1,7 +1,7 @@
 /* $OpenBSD: gss-serv.c,v 1.32 2020/03/13 03:17:07 djm Exp $ */
 
 /*
- * Copyright (c) 2001-2003 Simon Wilkinson. All rights reserved.
+ * Copyright (c) 2001-2009 Simon Wilkinson. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -44,17 +44,19 @@
 #include "session.h"
 #include "misc.h"
 #include "servconf.h"
+#include "uidswap.h"
 
 #include "ssh-gss.h"
+#include "monitor_wrap.h"
 
 extern ServerOptions options;
 
 static ssh_gssapi_client gssapi_client =
-    { GSS_C_EMPTY_BUFFER, GSS_C_EMPTY_BUFFER,
-    GSS_C_NO_CREDENTIAL, NULL, {NULL, NULL, NULL, NULL}};
+    { GSS_C_EMPTY_BUFFER, GSS_C_EMPTY_BUFFER, GSS_C_NO_CREDENTIAL,
+    GSS_C_NO_NAME, NULL, {NULL, NULL, NULL, NULL, NULL}, 0, 0};
 
 ssh_gssapi_mech gssapi_null_mech =
-    { NULL, NULL, {0, NULL}, NULL, NULL, NULL, NULL};
+    { NULL, NULL, {0, NULL}, NULL, NULL, NULL, NULL, NULL};
 
 #ifdef KRB5
 extern ssh_gssapi_mech gssapi_kerberos_mech;
@@ -140,6 +142,29 @@ ssh_gssapi_server_ctx(Gssctxt **ctx, gss_OID oid)
 	return (ssh_gssapi_acquire_cred(*ctx));
 }
 
+/* Unprivileged */
+char *
+ssh_gssapi_server_mechanisms(void) {
+	if (supported_oids == NULL)
+		ssh_gssapi_prepare_supported_oids();
+	return (ssh_gssapi_kex_mechs(supported_oids,
+	    &ssh_gssapi_server_check_mech, NULL, NULL,
+	    options.gss_kex_algorithms));
+}
+
+/* Unprivileged */
+int
+ssh_gssapi_server_check_mech(Gssctxt **dum, gss_OID oid, const char *data,
+    const char *dummy) {
+	Gssctxt *ctx = NULL;
+	int res;
+
+	res = !GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctx, oid)));
+	ssh_gssapi_delete_ctx(&ctx);
+
+	return (res);
+}
+
 /* Unprivileged */
 void
 ssh_gssapi_supported_oids(gss_OID_set *oidset)
@@ -150,7 +175,9 @@ ssh_gssapi_supported_oids(gss_OID_set *oidset)
 	gss_OID_set supported;
 
 	gss_create_empty_oid_set(&min_status, oidset);
-	gss_indicate_mechs(&min_status, &supported);
+
+	if (GSS_ERROR(gss_indicate_mechs(&min_status, &supported)))
+		return;
 
 	while (supported_mechs[i]->name != NULL) {
 		if (GSS_ERROR(gss_test_oid_set_member(&min_status,
@@ -276,8 +303,48 @@ OM_uint32
 ssh_gssapi_getclient(Gssctxt *ctx, ssh_gssapi_client *client)
 {
 	int i = 0;
+	int equal = 0;
+	gss_name_t new_name = GSS_C_NO_NAME;
+	gss_buffer_desc ename = GSS_C_EMPTY_BUFFER;
+
+	if (options.gss_store_rekey && client->used && ctx->client_creds) {
+		if (client->mech->oid.length != ctx->oid->length ||
+		    (memcmp(client->mech->oid.elements,
+		     ctx->oid->elements, ctx->oid->length) !=0)) {
+			debug("Rekeyed credentials have different mechanism");
+			return GSS_S_COMPLETE;
+		}
+
+		if ((ctx->major = gss_inquire_cred_by_mech(&ctx->minor,
+		    ctx->client_creds, ctx->oid, &new_name,
+		    NULL, NULL, NULL))) {
+			ssh_gssapi_error(ctx);
+			return (ctx->major);
+		}
 
-	gss_buffer_desc ename;
+		ctx->major = gss_compare_name(&ctx->minor, client->name,
+		    new_name, &equal);
+
+		if (GSS_ERROR(ctx->major)) {
+			ssh_gssapi_error(ctx);
+			return (ctx->major);
+		}
+
+		if (!equal) {
+			debug("Rekeyed credentials have different name");
+			return GSS_S_COMPLETE;
+		}
+
+		debug("Marking rekeyed credentials for export");
+
+		gss_release_name(&ctx->minor, &client->name);
+		gss_release_cred(&ctx->minor, &client->creds);
+		client->name = new_name;
+		client->creds = ctx->client_creds;
+		ctx->client_creds = GSS_C_NO_CREDENTIAL;
+		client->updated = 1;
+		return GSS_S_COMPLETE;
+	}
 
 	client->mech = NULL;
 
@@ -292,6 +359,13 @@ ssh_gssapi_getclient(Gssctxt *ctx, ssh_gssapi_client *client)
 	if (client->mech == NULL)
 		return GSS_S_FAILURE;
 
+	if (ctx->client_creds &&
+	    (ctx->major = gss_inquire_cred_by_mech(&ctx->minor,
+	     ctx->client_creds, ctx->oid, &client->name, NULL, NULL, NULL))) {
+		ssh_gssapi_error(ctx);
+		return (ctx->major);
+	}
+
 	if ((ctx->major = gss_display_name(&ctx->minor, ctx->client,
 	    &client->displayname, NULL))) {
 		ssh_gssapi_error(ctx);
@@ -309,6 +383,8 @@ ssh_gssapi_getclient(Gssctxt *ctx, ssh_gssapi_client *client)
 		return (ctx->major);
 	}
 
+	gss_release_buffer(&ctx->minor, &ename);
+
 	/* We can't copy this structure, so we just move the pointer to it */
 	client->creds = ctx->client_creds;
 	ctx->client_creds = GSS_C_NO_CREDENTIAL;
@@ -319,11 +395,20 @@ ssh_gssapi_getclient(Gssctxt *ctx, ssh_gssapi_client *client)
 void
 ssh_gssapi_cleanup_creds(void)
 {
-	if (gssapi_client.store.filename != NULL) {
-		/* Unlink probably isn't sufficient */
-		debug("removing gssapi cred file\"%s\"",
-		    gssapi_client.store.filename);
-		unlink(gssapi_client.store.filename);
+	krb5_ccache ccache = NULL;
+	krb5_error_code problem;
+
+	if (gssapi_client.store.data != NULL) {
+		if ((problem = krb5_cc_resolve(gssapi_client.store.data, gssapi_client.store.envval, &ccache))) {
+			debug_f("krb5_cc_resolve(): %.100s",
+				krb5_get_err_text(gssapi_client.store.data, problem));
+		} else if ((problem = krb5_cc_destroy(gssapi_client.store.data, ccache))) {
+			debug_f("krb5_cc_destroy(): %.100s",
+				krb5_get_err_text(gssapi_client.store.data, problem));
+		} else {
+			krb5_free_context(gssapi_client.store.data);
+			gssapi_client.store.data = NULL;
+		}
 	}
 }
 
@@ -356,19 +441,23 @@ ssh_gssapi_do_child(char ***envp, u_int *envsizep)
 
 /* Privileged */
 int
-ssh_gssapi_userok(char *user)
+ssh_gssapi_userok(char *user, struct passwd *pw, int kex)
 {
 	OM_uint32 lmin;
 
+	(void) kex; /* used in privilege separation */
+
 	if (gssapi_client.exportedname.length == 0 ||
 	    gssapi_client.exportedname.value == NULL) {
 		debug("No suitable client data");
 		return 0;
 	}
 	if (gssapi_client.mech && gssapi_client.mech->userok)
-		if ((*gssapi_client.mech->userok)(&gssapi_client, user))
+		if ((*gssapi_client.mech->userok)(&gssapi_client, user)) {
+			gssapi_client.used = 1;
+			gssapi_client.store.owner = pw;
 			return 1;
-		else {
+		} else {
 			/* Destroy delegated credentials if userok fails */
 			gss_release_buffer(&lmin, &gssapi_client.displayname);
 			gss_release_buffer(&lmin, &gssapi_client.exportedname);
@@ -382,14 +471,90 @@ ssh_gssapi_userok(char *user)
 	return (0);
 }
 
-/* Privileged */
-OM_uint32
-ssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)
+/* These bits are only used for rekeying. The unpriviledged child is running
+ * as the user, the monitor is root.
+ *
+ * In the child, we want to :
+ *    *) Ask the monitor to store our credentials into the store we specify
+ *    *) If it succeeds, maybe do a PAM update
+ */
+
+/* Stuff for PAM */
+
+#ifdef USE_PAM
+static int ssh_gssapi_simple_conv(int n, const struct pam_message **msg,
+    struct pam_response **resp, void *data)
 {
-	ctx->major = gss_verify_mic(&ctx->minor, ctx->context,
-	    gssbuf, gssmic, NULL);
+	return (PAM_CONV_ERR);
+}
+#endif
 
-	return (ctx->major);
+void
+ssh_gssapi_rekey_creds(void) {
+	int ok;
+#ifdef USE_PAM
+	int ret;
+	pam_handle_t *pamh = NULL;
+	struct pam_conv pamconv = {ssh_gssapi_simple_conv, NULL};
+	char *envstr;
+#endif
+
+	if (gssapi_client.store.filename == NULL &&
+	    gssapi_client.store.envval == NULL &&
+	    gssapi_client.store.envvar == NULL)
+		return;
+
+	ok = PRIVSEP(ssh_gssapi_update_creds(&gssapi_client.store));
+
+	if (!ok)
+		return;
+
+	debug("Rekeyed credentials stored successfully");
+
+	/* Actually managing to play with the ssh pam stack from here will
+	 * be next to impossible. In any case, we may want different options
+	 * for rekeying. So, use our own :)
+	 */
+#ifdef USE_PAM	
+	if (!use_privsep) {
+		debug("Not even going to try and do PAM with privsep disabled");
+		return;
+	}
+
+	ret = pam_start("sshd-rekey", gssapi_client.store.owner->pw_name,
+ 	    &pamconv, &pamh);
+	if (ret)
+		return;
+
+	xasprintf(&envstr, "%s=%s", gssapi_client.store.envvar,
+	    gssapi_client.store.envval);
+
+	ret = pam_putenv(pamh, envstr);
+	if (!ret)
+		pam_setcred(pamh, PAM_REINITIALIZE_CRED);
+	pam_end(pamh, PAM_SUCCESS);
+#endif
+}
+
+int
+ssh_gssapi_update_creds(ssh_gssapi_ccache *store) {
+	int ok = 0;
+
+	/* Check we've got credentials to store */
+	if (!gssapi_client.updated)
+		return 0;
+
+	gssapi_client.updated = 0;
+
+	temporarily_use_uid(gssapi_client.store.owner);
+	if (gssapi_client.mech && gssapi_client.mech->updatecreds)
+		ok = (*gssapi_client.mech->updatecreds)(store, &gssapi_client);
+	else
+		debug("No update function for this mechanism");
+
+	restore_uid();
+
+	return ok;
 }
 
 /* Privileged */
diff --git a/kex.c b/kex.c
index cbb2af596..acab53195 100644
--- a/kex.c
+++ b/kex.c
@@ -58,12 +58,17 @@
 #include "dispatch.h"
 #include "monitor.h"
 #include "myproposal.h"
+#include "xmalloc.h"
 
 #include "ssherr.h"
 #include "sshbuf.h"
 #include "digest.h"
 #include "xmalloc.h"
 
+#ifdef GSSAPI
+#include "ssh-gss.h"
+#endif
+
 /* prototype */
 static int kex_choose_conf(struct ssh *, uint32_t seq);
 static int kex_input_newkeys(int, u_int32_t, struct ssh *);
@@ -119,15 +124,28 @@ static const struct kexalg kexalgs[] = {
 #endif /* HAVE_EVP_SHA256 || !WITH_OPENSSL */
 	{ NULL, 0, -1, -1},
 };
+static const struct kexalg gss_kexalgs[] = {
+#ifdef GSSAPI
+	{ KEX_GSS_GEX_SHA1_ID, KEX_GSS_GEX_SHA1, 0, SSH_DIGEST_SHA1 },
+	{ KEX_GSS_GRP1_SHA1_ID, KEX_GSS_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },
+	{ KEX_GSS_GRP14_SHA1_ID, KEX_GSS_GRP14_SHA1, 0, SSH_DIGEST_SHA1 },
+	{ KEX_GSS_GRP14_SHA256_ID, KEX_GSS_GRP14_SHA256, 0, SSH_DIGEST_SHA256 },
+	{ KEX_GSS_GRP16_SHA512_ID, KEX_GSS_GRP16_SHA512, 0, SSH_DIGEST_SHA512 },
+	{ KEX_GSS_NISTP256_SHA256_ID, KEX_GSS_NISTP256_SHA256,
+	    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },
+	{ KEX_GSS_C25519_SHA256_ID, KEX_GSS_C25519_SHA256, 0, SSH_DIGEST_SHA256 },
+#endif
+	{ NULL, 0, -1, -1},
+};
 
-char *
-kex_alg_list(char sep)
+static char *
+kex_alg_list_internal(char sep, const struct kexalg *algs)
 {
 	char *ret = NULL, *tmp;
 	size_t nlen, rlen = 0;
 	const struct kexalg *k;
 
-	for (k = kexalgs; k->name != NULL; k++) {
+	for (k = algs; k->name != NULL; k++) {
 		if (ret != NULL)
 			ret[rlen++] = sep;
 		nlen = strlen(k->name);
@@ -142,6 +160,18 @@ kex_alg_list(char sep)
 	return ret;
 }
 
+char *
+kex_alg_list(char sep)
+{
+	return kex_alg_list_internal(sep, kexalgs);
+}
+
+char *
+kex_gss_alg_list(char sep)
+{
+	return kex_alg_list_internal(sep, gss_kexalgs);
+}
+
 static const struct kexalg *
 kex_alg_by_name(const char *name)
 {
@@ -151,6 +181,10 @@ kex_alg_by_name(const char *name)
 		if (strcmp(k->name, name) == 0)
 			return k;
 	}
+	for (k = gss_kexalgs; k->name != NULL; k++) {
+		if (strncmp(k->name, name, strlen(k->name)) == 0)
+			return k;
+	}
 	return NULL;
 }
 
@@ -393,6 +427,29 @@ kex_proposal_free_entries(char *prop[PROPOSAL_MAX])
 		free(prop[i]);
 }
 
+/* Validate GSS KEX method name list */
+int
+kex_gss_names_valid(const char *names)
+{
+	char *s, *cp, *p;
+
+	if (names == NULL || *names == '\0')
+		return 0;
+	s = cp = xstrdup(names);
+	for ((p = strsep(&cp, ",")); p && *p != '\0';
+	    (p = strsep(&cp, ","))) {
+		if (strncmp(p, "gss-", 4) != 0
+		  || kex_alg_by_name(p) == NULL) {
+			error("Unsupported KEX algorithm \"%.100s\"", p);
+			free(s);
+			return 0;
+		}
+	}
+	debug3("gss kex names ok: [%s]", names);
+	free(s);
+	return 1;
+}
+
 /* put algorithm proposal into buffer */
 int
 kex_prop2buf(struct sshbuf *b, char *proposal[PROPOSAL_MAX])
@@ -964,6 +1021,9 @@ kex_free(struct kex *kex)
 	sshbuf_free(kex->session_id);
 	sshbuf_free(kex->initial_sig);
 	sshkey_free(kex->initial_hostkey);
+#ifdef GSSAPI
+	free(kex->gss_host);
+#endif /* GSSAPI */
 	free(kex->failed_choice);
 	free(kex->hostkey_alg);
 	free(kex->name);
diff --git a/kex.h b/kex.h
index ba3a6a4ea..faee60f16 100644
--- a/kex.h
+++ b/kex.h
@@ -102,6 +102,15 @@ enum kex_exchange {
 	KEX_ECDH_SHA2,
 	KEX_C25519_SHA256,
 	KEX_KEM_SNTRUP761X25519_SHA512,
+#ifdef GSSAPI
+	KEX_GSS_GRP1_SHA1,
+	KEX_GSS_GRP14_SHA1,
+	KEX_GSS_GRP14_SHA256,
+	KEX_GSS_GRP16_SHA512,
+	KEX_GSS_GEX_SHA1,
+	KEX_GSS_NISTP256_SHA256,
+	KEX_GSS_C25519_SHA256,
+#endif
 	KEX_MAX
 };
 
@@ -164,6 +173,12 @@ struct kex {
 	u_int	flags;
 	int	hash_alg;
 	int	ec_nid;
+#ifdef GSSAPI
+	int	gss_deleg_creds;
+	int	gss_trust_dns;
+	char    *gss_host;
+	char	*gss_client;
+#endif
 	char	*failed_choice;
 	int	(*verify_host_key)(struct sshkey *, struct ssh *);
 	struct sshkey *(*load_host_public_key)(int, int, struct ssh *);
@@ -185,11 +200,13 @@ struct kex {
 
 int	 kex_names_valid(const char *);
 char	*kex_alg_list(char);
+char	*kex_gss_alg_list(char);
 char	*kex_names_cat(const char *, const char *);
 int	 kex_assemble_names(char **, const char *, const char *);
 void	 kex_proposal_populate_entries(struct ssh *, char *prop[PROPOSAL_MAX],
     const char *, const char *, const char *, const char *, const char *);
 void	 kex_proposal_free_entries(char *prop[PROPOSAL_MAX]);
+int	 kex_gss_names_valid(const char *);
 
 int	 kex_exchange_identification(struct ssh *, int, const char *);
 
@@ -219,6 +236,12 @@ int	 kexgex_client(struct ssh *);
 int	 kexgex_server(struct ssh *);
 int	 kex_gen_client(struct ssh *);
 int	 kex_gen_server(struct ssh *);
+#if defined(GSSAPI) && defined(WITH_OPENSSL)
+int	 kexgssgex_client(struct ssh *);
+int	 kexgssgex_server(struct ssh *);
+int	 kexgss_client(struct ssh *);
+int	 kexgss_server(struct ssh *);
+#endif
 
 int	 kex_dh_keypair(struct kex *);
 int	 kex_dh_enc(struct kex *, const struct sshbuf *, struct sshbuf **,
@@ -251,6 +274,12 @@ int	 kexgex_hash(int, const struct sshbuf *, const struct sshbuf *,
     const BIGNUM *, const u_char *, size_t,
     u_char *, size_t *);
 
+int	 kex_gen_hash(int hash_alg, const struct sshbuf *client_version,
+    const struct sshbuf *server_version, const struct sshbuf *client_kexinit,
+    const struct sshbuf *server_kexinit, const struct sshbuf *server_host_key_blob,
+    const struct sshbuf *client_pub, const struct sshbuf *server_pub,
+    const struct sshbuf *shared_secret, u_char *hash, size_t *hashlen);
+
 void	kexc25519_keygen(u_char key[CURVE25519_SIZE], u_char pub[CURVE25519_SIZE])
 	__attribute__((__bounded__(__minbytes__, 1, CURVE25519_SIZE)))
 	__attribute__((__bounded__(__minbytes__, 2, CURVE25519_SIZE)));
diff --git a/kexdh.c b/kexdh.c
index c1084f214..0faab21b0 100644
--- a/kexdh.c
+++ b/kexdh.c
@@ -49,13 +49,23 @@ kex_dh_keygen(struct kex *kex)
 {
 	switch (kex->kex_type) {
 	case KEX_DH_GRP1_SHA1:
+#ifdef GSSAPI
+	case KEX_GSS_GRP1_SHA1:
+#endif
 		kex->dh = dh_new_group1();
 		break;
 	case KEX_DH_GRP14_SHA1:
 	case KEX_DH_GRP14_SHA256:
+#ifdef GSSAPI
+	case KEX_GSS_GRP14_SHA1:
+	case KEX_GSS_GRP14_SHA256:
+#endif
 		kex->dh = dh_new_group14();
 		break;
 	case KEX_DH_GRP16_SHA512:
+#ifdef GSSAPI
+	case KEX_GSS_GRP16_SHA512:
+#endif
 		kex->dh = dh_new_group16();
 		break;
 	case KEX_DH_GRP18_SHA512:
diff --git a/kexgen.c b/kexgen.c
index 20f3c5711..ca704844e 100644
--- a/kexgen.c
+++ b/kexgen.c
@@ -44,7 +44,7 @@
 static int input_kex_gen_init(int, u_int32_t, struct ssh *);
 static int input_kex_gen_reply(int type, u_int32_t seq, struct ssh *ssh);
 
-static int
+int
 kex_gen_hash(
     int hash_alg,
     const struct sshbuf *client_version,
diff --git a/kexgssc.c b/kexgssc.c
new file mode 100644
index 000000000..2da431428
--- /dev/null
+++ b/kexgssc.c
@@ -0,0 +1,602 @@
+/*
+ * Copyright (c) 2001-2009 Simon Wilkinson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "includes.h"
+
+#if defined(GSSAPI) && defined(WITH_OPENSSL)
+
+#include "includes.h"
+
+#include <openssl/crypto.h>
+#include <openssl/bn.h>
+
+#include <string.h>
+
+#include "xmalloc.h"
+#include "sshbuf.h"
+#include "ssh2.h"
+#include "sshkey.h"
+#include "cipher.h"
+#include "kex.h"
+#include "log.h"
+#include "packet.h"
+#include "dh.h"
+#include "digest.h"
+#include "ssherr.h"
+
+#include "ssh-gss.h"
+
+int
+kexgss_client(struct ssh *ssh)
+{
+	struct kex *kex = ssh->kex;
+	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER,
+	    recv_tok = GSS_C_EMPTY_BUFFER,
+	    gssbuf, msg_tok = GSS_C_EMPTY_BUFFER, *token_ptr;
+	Gssctxt *ctxt;
+	OM_uint32 maj_status, min_status, ret_flags;
+	struct sshbuf *server_blob = NULL;
+	struct sshbuf *shared_secret = NULL;
+	struct sshbuf *server_host_key_blob = NULL;
+	struct sshbuf *empty = NULL;
+	u_char *msg;
+	int type = 0;
+	int first = 1;
+	u_char hash[SSH_DIGEST_MAX_LENGTH];
+	size_t hashlen;
+	u_char c;
+	int r;
+
+	/* Initialise our GSSAPI world */
+	ssh_gssapi_build_ctx(&ctxt);
+	if (ssh_gssapi_id_kex(ctxt, kex->name, kex->kex_type)
+	    == GSS_C_NO_OID)
+		fatal("Couldn't identify host exchange");
+
+	if (ssh_gssapi_import_name(ctxt, kex->gss_host))
+		fatal("Couldn't import hostname");
+
+	if (kex->gss_client &&
+	    ssh_gssapi_client_identity(ctxt, kex->gss_client))
+		fatal("Couldn't acquire client credentials");
+
+	/* Step 1 */
+	switch (kex->kex_type) {
+	case KEX_GSS_GRP1_SHA1:
+	case KEX_GSS_GRP14_SHA1:
+	case KEX_GSS_GRP14_SHA256:
+	case KEX_GSS_GRP16_SHA512:
+		r = kex_dh_keypair(kex);
+		break;
+	case KEX_GSS_NISTP256_SHA256:
+		r = kex_ecdh_keypair(kex);
+		break;
+	case KEX_GSS_C25519_SHA256:
+		r = kex_c25519_keypair(kex);
+		break;
+	default:
+		fatal_f("Unexpected KEX type %d", kex->kex_type);
+	}
+	if (r != 0)
+		return r;
+
+	token_ptr = GSS_C_NO_BUFFER;
+
+	do {
+		debug("Calling gss_init_sec_context");
+
+		maj_status = ssh_gssapi_init_ctx(ctxt,
+		    kex->gss_deleg_creds, token_ptr, &send_tok,
+		    &ret_flags);
+
+		if (GSS_ERROR(maj_status)) {
+			/* XXX Useles code: Missing send? */
+			if (send_tok.length != 0) {
+				if ((r = sshpkt_start(ssh,
+				        SSH2_MSG_KEXGSS_CONTINUE)) != 0 ||
+				    (r = sshpkt_put_string(ssh, send_tok.value,
+				        send_tok.length)) != 0)
+					fatal("sshpkt failed: %s", ssh_err(r));
+			}
+			fatal("gss_init_context failed");
+		}
+
+		/* If we've got an old receive buffer get rid of it */
+		if (token_ptr != GSS_C_NO_BUFFER)
+			gss_release_buffer(&min_status, &recv_tok);
+
+		if (maj_status == GSS_S_COMPLETE) {
+			/* If mutual state flag is not true, kex fails */
+			if (!(ret_flags & GSS_C_MUTUAL_FLAG))
+				fatal("Mutual authentication failed");
+
+			/* If integ avail flag is not true kex fails */
+			if (!(ret_flags & GSS_C_INTEG_FLAG))
+				fatal("Integrity check failed");
+		}
+
+		/*
+		 * If we have data to send, then the last message that we
+		 * received cannot have been a 'complete'.
+		 */
+		if (send_tok.length != 0) {
+			if (first) {
+				if ((r = sshpkt_start(ssh, SSH2_MSG_KEXGSS_INIT)) != 0 ||
+				    (r = sshpkt_put_string(ssh, send_tok.value,
+				        send_tok.length)) != 0 ||
+				    (r = sshpkt_put_stringb(ssh, kex->client_pub)) != 0)
+					fatal("failed to construct packet: %s", ssh_err(r));
+				first = 0;
+			} else {
+				if ((r = sshpkt_start(ssh, SSH2_MSG_KEXGSS_CONTINUE)) != 0 ||
+				    (r = sshpkt_put_string(ssh, send_tok.value,
+				        send_tok.length)) != 0)
+					fatal("failed to construct packet: %s", ssh_err(r));
+			}
+			if ((r = sshpkt_send(ssh)) != 0)
+				fatal("failed to send packet: %s", ssh_err(r));
+			gss_release_buffer(&min_status, &send_tok);
+
+			/* If we've sent them data, they should reply */
+			do {
+				type = ssh_packet_read(ssh);
+				if (type == SSH2_MSG_KEXGSS_HOSTKEY) {
+					debug("Received KEXGSS_HOSTKEY");
+					if (server_host_key_blob)
+						fatal("Server host key received more than once");
+					if ((r = sshpkt_getb_froms(ssh, &server_host_key_blob)) != 0)
+						fatal("Failed to read server host key: %s", ssh_err(r));
+				}
+			} while (type == SSH2_MSG_KEXGSS_HOSTKEY);
+
+			switch (type) {
+			case SSH2_MSG_KEXGSS_CONTINUE:
+				debug("Received GSSAPI_CONTINUE");
+				if (maj_status == GSS_S_COMPLETE)
+					fatal("GSSAPI Continue received from server when complete");
+				if ((r = ssh_gssapi_sshpkt_get_buffer_desc(ssh,
+				        &recv_tok)) != 0 ||
+				    (r = sshpkt_get_end(ssh)) != 0)
+					fatal("Failed to read token: %s", ssh_err(r));
+				break;
+			case SSH2_MSG_KEXGSS_COMPLETE:
+				debug("Received GSSAPI_COMPLETE");
+				if (msg_tok.value != NULL)
+				        fatal("Received GSSAPI_COMPLETE twice?");
+				if ((r = sshpkt_getb_froms(ssh, &server_blob)) != 0 ||
+				    (r = ssh_gssapi_sshpkt_get_buffer_desc(ssh,
+				        &msg_tok)) != 0)
+					fatal("Failed to read message: %s", ssh_err(r));
+
+				/* Is there a token included? */
+				if ((r = sshpkt_get_u8(ssh, &c)) != 0)
+					fatal("sshpkt failed: %s", ssh_err(r));
+				if (c) {
+					if ((r = ssh_gssapi_sshpkt_get_buffer_desc(
+					    ssh, &recv_tok)) != 0)
+						fatal("Failed to read token: %s", ssh_err(r));
+					/* If we're already complete - protocol error */
+					if (maj_status == GSS_S_COMPLETE)
+						sshpkt_disconnect(ssh, "Protocol error: received token when complete");
+				} else {
+					/* No token included */
+					if (maj_status != GSS_S_COMPLETE)
+						sshpkt_disconnect(ssh, "Protocol error: did not receive final token");
+				}
+				if ((r = sshpkt_get_end(ssh)) != 0) {
+					fatal("Expecting end of packet.");
+				}
+				break;
+			case SSH2_MSG_KEXGSS_ERROR:
+				debug("Received Error");
+				if ((r = sshpkt_get_u32(ssh, &maj_status)) != 0 ||
+				    (r = sshpkt_get_u32(ssh, &min_status)) != 0 ||
+				    (r = sshpkt_get_string(ssh, &msg, NULL)) != 0 ||
+				    (r = sshpkt_get_string(ssh, NULL, NULL)) != 0 || /* lang tag */
+				    (r = sshpkt_get_end(ssh)) != 0)
+					fatal("sshpkt_get failed: %s", ssh_err(r));
+				fatal("GSSAPI Error: \n%.400s", msg);
+			default:
+				sshpkt_disconnect(ssh, "Protocol error: didn't expect packet type %d",
+				    type);
+			}
+			token_ptr = &recv_tok;
+		} else {
+			/* No data, and not complete */
+			if (maj_status != GSS_S_COMPLETE)
+				fatal("Not complete, and no token output");
+		}
+	} while (maj_status & GSS_S_CONTINUE_NEEDED);
+
+	/*
+	 * We _must_ have received a COMPLETE message in reply from the
+	 * server, which will have set server_blob and msg_tok
+	 */
+
+	if (type != SSH2_MSG_KEXGSS_COMPLETE)
+		fatal("Didn't receive a SSH2_MSG_KEXGSS_COMPLETE when I expected it");
+
+	/* compute shared secret */
+	switch (kex->kex_type) {
+	case KEX_GSS_GRP1_SHA1:
+	case KEX_GSS_GRP14_SHA1:
+	case KEX_GSS_GRP14_SHA256:
+	case KEX_GSS_GRP16_SHA512:
+		r = kex_dh_dec(kex, server_blob, &shared_secret);
+		break;
+	case KEX_GSS_C25519_SHA256:
+		if (sshbuf_ptr(server_blob)[sshbuf_len(server_blob)] & 0x80)
+			fatal("The received key has MSB of last octet set!");
+		r = kex_c25519_dec(kex, server_blob, &shared_secret);
+		break;
+	case KEX_GSS_NISTP256_SHA256:
+		if (sshbuf_len(server_blob) != 65)
+			fatal("The received NIST-P256 key did not match"
+			    "expected length (expected 65, got %zu)", sshbuf_len(server_blob));
+
+		if (sshbuf_ptr(server_blob)[0] != POINT_CONVERSION_UNCOMPRESSED)
+			fatal("The received NIST-P256 key does not have first octet 0x04");
+
+		r = kex_ecdh_dec(kex, server_blob, &shared_secret);
+		break;
+	default:
+		r = SSH_ERR_INVALID_ARGUMENT;
+		break;
+	}
+	if (r != 0)
+		goto out;
+
+	if ((empty = sshbuf_new()) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+
+	hashlen = sizeof(hash);
+	if ((r = kex_gen_hash(
+	    kex->hash_alg,
+	    kex->client_version,
+	    kex->server_version,
+	    kex->my,
+	    kex->peer,
+	    (server_host_key_blob ? server_host_key_blob : empty),
+	    kex->client_pub,
+	    server_blob,
+	    shared_secret,
+	    hash, &hashlen)) != 0)
+		fatal_f("Unexpected KEX type %d", kex->kex_type);
+
+	gssbuf.value = hash;
+	gssbuf.length = hashlen;
+
+	/* Verify that the hash matches the MIC we just got. */
+	if (GSS_ERROR(ssh_gssapi_checkmic(ctxt, &gssbuf, &msg_tok)))
+		sshpkt_disconnect(ssh, "Hash's MIC didn't verify");
+
+	gss_release_buffer(&min_status, &msg_tok);
+
+	if (kex->gss_deleg_creds)
+		ssh_gssapi_credentials_updated(ctxt);
+
+	if (gss_kex_context == NULL)
+		gss_kex_context = ctxt;
+	else
+		ssh_gssapi_delete_ctx(&ctxt);
+
+	if ((r = kex_derive_keys(ssh, hash, hashlen, shared_secret)) == 0)
+		r = kex_send_newkeys(ssh);
+
+out:
+	explicit_bzero(hash, sizeof(hash));
+	explicit_bzero(kex->c25519_client_key, sizeof(kex->c25519_client_key));
+	sshbuf_free(empty);
+	sshbuf_free(server_host_key_blob);
+	sshbuf_free(server_blob);
+	sshbuf_free(shared_secret);
+	sshbuf_free(kex->client_pub);
+	kex->client_pub = NULL;
+	return r;
+}
+
+int
+kexgssgex_client(struct ssh *ssh)
+{
+	struct kex *kex = ssh->kex;
+	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER,
+	    recv_tok = GSS_C_EMPTY_BUFFER, gssbuf,
+            msg_tok = GSS_C_EMPTY_BUFFER, *token_ptr;
+	Gssctxt *ctxt;
+	OM_uint32 maj_status, min_status, ret_flags;
+	struct sshbuf *shared_secret = NULL;
+	BIGNUM *p = NULL;
+	BIGNUM *g = NULL;
+	struct sshbuf *buf = NULL;
+	struct sshbuf *server_host_key_blob = NULL;
+	struct sshbuf *server_blob = NULL;
+	BIGNUM *dh_server_pub = NULL;
+	u_char *msg;
+	int type = 0;
+	int first = 1;
+	u_char hash[SSH_DIGEST_MAX_LENGTH];
+	size_t hashlen;
+	const BIGNUM *pub_key, *dh_p, *dh_g;
+	int nbits = 0, min = DH_GRP_MIN, max = DH_GRP_MAX;
+	struct sshbuf *empty = NULL;
+	u_char c;
+	int r;
+
+	/* Initialise our GSSAPI world */
+	ssh_gssapi_build_ctx(&ctxt);
+	if (ssh_gssapi_id_kex(ctxt, kex->name, kex->kex_type)
+	    == GSS_C_NO_OID)
+		fatal("Couldn't identify host exchange");
+
+	if (ssh_gssapi_import_name(ctxt, kex->gss_host))
+		fatal("Couldn't import hostname");
+
+	if (kex->gss_client &&
+	    ssh_gssapi_client_identity(ctxt, kex->gss_client))
+		fatal("Couldn't acquire client credentials");
+
+	debug("Doing group exchange");
+	nbits = dh_estimate(kex->dh_need * 8);
+
+	kex->min = DH_GRP_MIN;
+	kex->max = DH_GRP_MAX;
+	kex->nbits = nbits;
+	if ((r = sshpkt_start(ssh, SSH2_MSG_KEXGSS_GROUPREQ)) != 0 ||
+	    (r = sshpkt_put_u32(ssh, min)) != 0 ||
+	    (r = sshpkt_put_u32(ssh, nbits)) != 0 ||
+	    (r = sshpkt_put_u32(ssh, max)) != 0 ||
+	    (r = sshpkt_send(ssh)) != 0)
+		fatal("Failed to construct a packet: %s", ssh_err(r));
+
+	type = ssh_packet_read(ssh);
+	if (type != SSH2_MSG_KEXGSS_GROUP)
+		ssh_packet_disconnect(ssh,
+		    "Protocol error: expected packet type %d, got %d",
+		    SSH2_MSG_KEXGSS_GROUP, type);
+
+	if ((r = sshpkt_get_bignum2(ssh, &p)) != 0 ||
+	    (r = sshpkt_get_bignum2(ssh, &g)) != 0 ||
+	    (r = sshpkt_get_end(ssh)) != 0)
+		fatal("shpkt_get_bignum2 failed: %s", ssh_err(r));
+
+	if (BN_num_bits(p) < min || BN_num_bits(p) > max)
+		fatal("GSSGRP_GEX group out of range: %d !< %d !< %d",
+		    min, BN_num_bits(p), max);
+
+	if ((kex->dh = dh_new_group(g, p)) == NULL)
+		fatal("dn_new_group() failed");
+	p = g = NULL; /* belong to kex->dh now */
+
+	if ((r = dh_gen_key(kex->dh, kex->we_need * 8)) != 0)
+		goto out;
+	DH_get0_key(kex->dh, &pub_key, NULL);
+
+	token_ptr = GSS_C_NO_BUFFER;
+
+	do {
+		/* Step 2 - call GSS_Init_sec_context() */
+		debug("Calling gss_init_sec_context");
+
+		maj_status = ssh_gssapi_init_ctx(ctxt,
+		    kex->gss_deleg_creds, token_ptr, &send_tok,
+		    &ret_flags);
+
+		if (GSS_ERROR(maj_status)) {
+			/* XXX Useles code: Missing send? */
+			if (send_tok.length != 0) {
+				if ((r = sshpkt_start(ssh,
+				        SSH2_MSG_KEXGSS_CONTINUE)) != 0 ||
+				    (r = sshpkt_put_string(ssh, send_tok.value,
+				        send_tok.length)) != 0)
+					fatal("sshpkt failed: %s", ssh_err(r));
+			}
+			fatal("gss_init_context failed");
+		}
+
+		/* If we've got an old receive buffer get rid of it */
+		if (token_ptr != GSS_C_NO_BUFFER)
+			gss_release_buffer(&min_status, &recv_tok);
+
+		if (maj_status == GSS_S_COMPLETE) {
+			/* If mutual state flag is not true, kex fails */
+			if (!(ret_flags & GSS_C_MUTUAL_FLAG))
+				fatal("Mutual authentication failed");
+
+			/* If integ avail flag is not true kex fails */
+			if (!(ret_flags & GSS_C_INTEG_FLAG))
+				fatal("Integrity check failed");
+		}
+
+		/*
+		 * If we have data to send, then the last message that we
+		 * received cannot have been a 'complete'.
+		 */
+		if (send_tok.length != 0) {
+			if (first) {
+				if ((r = sshpkt_start(ssh, SSH2_MSG_KEXGSS_INIT)) != 0 ||
+				    (r = sshpkt_put_string(ssh, send_tok.value,
+				        send_tok.length)) != 0 ||
+				    (r = sshpkt_put_bignum2(ssh, pub_key)) != 0)
+					fatal("sshpkt failed: %s", ssh_err(r));
+				first = 0;
+			} else {
+				if ((r = sshpkt_start(ssh, SSH2_MSG_KEXGSS_CONTINUE)) != 0 ||
+				    (r = sshpkt_put_string(ssh,send_tok.value,
+				        send_tok.length)) != 0)
+					fatal("sshpkt failed: %s", ssh_err(r));
+			}
+			if ((r = sshpkt_send(ssh)) != 0)
+				fatal("sshpkt_send failed: %s", ssh_err(r));
+			gss_release_buffer(&min_status, &send_tok);
+
+			/* If we've sent them data, they should reply */
+			do {
+				type = ssh_packet_read(ssh);
+				if (type == SSH2_MSG_KEXGSS_HOSTKEY) {
+					debug("Received KEXGSS_HOSTKEY");
+					if (server_host_key_blob)
+						fatal("Server host key received more than once");
+					if ((r = sshpkt_getb_froms(ssh, &server_host_key_blob)) != 0)
+						fatal("sshpkt failed: %s", ssh_err(r));
+				}
+			} while (type == SSH2_MSG_KEXGSS_HOSTKEY);
+
+			switch (type) {
+			case SSH2_MSG_KEXGSS_CONTINUE:
+				debug("Received GSSAPI_CONTINUE");
+				if (maj_status == GSS_S_COMPLETE)
+					fatal("GSSAPI Continue received from server when complete");
+				if ((r = ssh_gssapi_sshpkt_get_buffer_desc(ssh,
+				        &recv_tok)) != 0 ||
+				    (r = sshpkt_get_end(ssh)) != 0)
+					fatal("sshpkt failed: %s", ssh_err(r));
+				break;
+			case SSH2_MSG_KEXGSS_COMPLETE:
+				debug("Received GSSAPI_COMPLETE");
+				if (msg_tok.value != NULL)
+				        fatal("Received GSSAPI_COMPLETE twice?");
+				if ((r = sshpkt_getb_froms(ssh, &server_blob)) != 0 ||
+				    (r = ssh_gssapi_sshpkt_get_buffer_desc(ssh,
+				        &msg_tok)) != 0)
+					fatal("sshpkt failed: %s", ssh_err(r));
+
+				/* Is there a token included? */
+				if ((r = sshpkt_get_u8(ssh, &c)) != 0)
+					fatal("sshpkt failed: %s", ssh_err(r));
+				if (c) {
+					if ((r = ssh_gssapi_sshpkt_get_buffer_desc(
+					        ssh, &recv_tok)) != 0 ||
+					    (r = sshpkt_get_end(ssh)) != 0)
+						fatal("sshpkt failed: %s", ssh_err(r));
+					/* If we're already complete - protocol error */
+					if (maj_status == GSS_S_COMPLETE)
+						sshpkt_disconnect(ssh, "Protocol error: received token when complete");
+				} else {
+					/* No token included */
+					if (maj_status != GSS_S_COMPLETE)
+						sshpkt_disconnect(ssh, "Protocol error: did not receive final token");
+				}
+				break;
+			case SSH2_MSG_KEXGSS_ERROR:
+				debug("Received Error");
+				if ((r = sshpkt_get_u32(ssh, &maj_status)) != 0 ||
+				    (r = sshpkt_get_u32(ssh, &min_status)) != 0 ||
+				    (r = sshpkt_get_string(ssh, &msg, NULL)) != 0 ||
+				    (r = sshpkt_get_string(ssh, NULL, NULL)) != 0 || /* lang tag */
+				    (r = sshpkt_get_end(ssh)) != 0)
+					fatal("sshpkt failed: %s", ssh_err(r));
+				fatal("GSSAPI Error: \n%.400s", msg);
+			default:
+				sshpkt_disconnect(ssh, "Protocol error: didn't expect packet type %d",
+				    type);
+			}
+			token_ptr = &recv_tok;
+		} else {
+			/* No data, and not complete */
+			if (maj_status != GSS_S_COMPLETE)
+				fatal("Not complete, and no token output");
+		}
+	} while (maj_status & GSS_S_CONTINUE_NEEDED);
+
+	/*
+	 * We _must_ have received a COMPLETE message in reply from the
+	 * server, which will have set dh_server_pub and msg_tok
+	 */
+
+	if (type != SSH2_MSG_KEXGSS_COMPLETE)
+		fatal("Didn't receive a SSH2_MSG_KEXGSS_COMPLETE when I expected it");
+
+	/* 7. C verifies that the key Q_S is valid */
+	/* 8. C computes shared secret */
+	if ((buf = sshbuf_new()) == NULL ||
+	    (r = sshbuf_put_stringb(buf, server_blob)) != 0 ||
+	    (r = sshbuf_get_bignum2(buf, &dh_server_pub)) != 0)
+		goto out;
+	sshbuf_free(buf);
+	buf = NULL;
+
+	if ((shared_secret = sshbuf_new()) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+
+	if ((r = kex_dh_compute_key(kex, dh_server_pub, shared_secret)) != 0)
+		goto out;
+	if ((empty = sshbuf_new()) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+
+	DH_get0_pqg(kex->dh, &dh_p, NULL, &dh_g);
+	hashlen = sizeof(hash);
+	if ((r = kexgex_hash(
+	    kex->hash_alg,
+	    kex->client_version,
+	    kex->server_version,
+	    kex->my,
+	    kex->peer,
+	    (server_host_key_blob ? server_host_key_blob : empty),
+ 	    kex->min, kex->nbits, kex->max,
+	    dh_p, dh_g,
+	    pub_key,
+	    dh_server_pub,
+	    sshbuf_ptr(shared_secret), sshbuf_len(shared_secret),
+	    hash, &hashlen)) != 0)
+		fatal("Failed to calculate hash: %s", ssh_err(r));
+
+	gssbuf.value = hash;
+	gssbuf.length = hashlen;
+
+	/* Verify that the hash matches the MIC we just got. */
+	if (GSS_ERROR(ssh_gssapi_checkmic(ctxt, &gssbuf, &msg_tok)))
+		sshpkt_disconnect(ssh, "Hash's MIC didn't verify");
+
+	gss_release_buffer(&min_status, &msg_tok);
+
+	if (kex->gss_deleg_creds)
+		ssh_gssapi_credentials_updated(ctxt);
+
+	if (gss_kex_context == NULL)
+		gss_kex_context = ctxt;
+	else
+		ssh_gssapi_delete_ctx(&ctxt);
+
+	/* Finally derive the keys and send them */
+	if ((r = kex_derive_keys(ssh, hash, hashlen, shared_secret)) == 0)
+		r = kex_send_newkeys(ssh);
+out:
+	sshbuf_free(buf);
+	sshbuf_free(server_blob);
+	sshbuf_free(empty);
+	explicit_bzero(hash, sizeof(hash));
+	DH_free(kex->dh);
+	kex->dh = NULL;
+	BN_clear_free(dh_server_pub);
+	sshbuf_free(shared_secret);
+	sshbuf_free(server_host_key_blob);
+	return r;
+}
+#endif /* defined(GSSAPI) && defined(WITH_OPENSSL) */
diff --git a/kexgsss.c b/kexgsss.c
new file mode 100644
index 000000000..40d184170
--- /dev/null
+++ b/kexgsss.c
@@ -0,0 +1,478 @@
+/*
+ * Copyright (c) 2001-2009 Simon Wilkinson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "includes.h"
+
+#if defined(GSSAPI) && defined(WITH_OPENSSL)
+
+#include <string.h>
+
+#include <openssl/crypto.h>
+#include <openssl/bn.h>
+
+#include "xmalloc.h"
+#include "sshbuf.h"
+#include "ssh2.h"
+#include "sshkey.h"
+#include "cipher.h"
+#include "kex.h"
+#include "log.h"
+#include "packet.h"
+#include "dh.h"
+#include "ssh-gss.h"
+#include "monitor_wrap.h"
+#include "misc.h"      /* servconf.h needs misc.h for struct ForwardOptions */
+#include "servconf.h"
+#include "ssh-gss.h"
+#include "digest.h"
+#include "ssherr.h"
+
+extern ServerOptions options;
+
+int
+kexgss_server(struct ssh *ssh)
+{
+	struct kex *kex = ssh->kex;
+	OM_uint32 maj_status, min_status;
+
+	/*
+	 * Some GSSAPI implementations use the input value of ret_flags (an
+	 * output variable) as a means of triggering mechanism specific
+	 * features. Initializing it to zero avoids inadvertently
+	 * activating this non-standard behaviour.
+	 */
+
+	OM_uint32 ret_flags = 0;
+	gss_buffer_desc gssbuf, recv_tok, msg_tok;
+	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;
+	Gssctxt *ctxt = NULL;
+	struct sshbuf *shared_secret = NULL;
+	struct sshbuf *client_pubkey = NULL;
+	struct sshbuf *server_pubkey = NULL;
+	struct sshbuf *empty = sshbuf_new();
+	int type = 0;
+	gss_OID oid;
+	char *mechs;
+	u_char hash[SSH_DIGEST_MAX_LENGTH];
+	size_t hashlen;
+	int r;
+
+	/* Initialise GSSAPI */
+
+	/* If we're rekeying, privsep means that some of the private structures
+	 * in the GSSAPI code are no longer available. This kludges them back
+	 * into life
+	 */
+	if (!ssh_gssapi_oid_table_ok()) {
+		mechs = ssh_gssapi_server_mechanisms();
+		free(mechs);
+	}
+
+	debug2_f("Identifying %s", kex->name);
+	oid = ssh_gssapi_id_kex(NULL, kex->name, kex->kex_type);
+	if (oid == GSS_C_NO_OID)
+	   fatal("Unknown gssapi mechanism");
+
+	debug2_f("Acquiring credentials");
+
+	if (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, oid))))
+		fatal("Unable to acquire credentials for the server");
+
+	do {
+		debug("Wait SSH2_MSG_KEXGSS_INIT");
+		type = ssh_packet_read(ssh);
+		switch(type) {
+		case SSH2_MSG_KEXGSS_INIT:
+			if (client_pubkey != NULL)
+				fatal("Received KEXGSS_INIT after initialising");
+			if ((r = ssh_gssapi_sshpkt_get_buffer_desc(ssh,
+			        &recv_tok)) != 0 ||
+			    (r = sshpkt_getb_froms(ssh, &client_pubkey)) != 0 ||
+			    (r = sshpkt_get_end(ssh)) != 0)
+				fatal("sshpkt failed: %s", ssh_err(r));
+
+			switch (kex->kex_type) {
+			case KEX_GSS_GRP1_SHA1:
+			case KEX_GSS_GRP14_SHA1:
+			case KEX_GSS_GRP14_SHA256:
+			case KEX_GSS_GRP16_SHA512:
+				r = kex_dh_enc(kex, client_pubkey, &server_pubkey,
+				    &shared_secret);
+				break;
+			case KEX_GSS_NISTP256_SHA256:
+				r = kex_ecdh_enc(kex, client_pubkey, &server_pubkey,
+				    &shared_secret);
+				break;
+			case KEX_GSS_C25519_SHA256:
+				r = kex_c25519_enc(kex, client_pubkey, &server_pubkey,
+				    &shared_secret);
+				break;
+			default:
+				fatal_f("Unexpected KEX type %d", kex->kex_type);
+			}
+			if (r != 0)
+				goto out;
+
+			/* Send SSH_MSG_KEXGSS_HOSTKEY here, if we want */
+			break;
+		case SSH2_MSG_KEXGSS_CONTINUE:
+			if ((r = ssh_gssapi_sshpkt_get_buffer_desc(ssh,
+			        &recv_tok)) != 0 ||
+			    (r = sshpkt_get_end(ssh)) != 0)
+				fatal("sshpkt failed: %s", ssh_err(r));
+			break;
+		default:
+			sshpkt_disconnect(ssh,
+			    "Protocol error: didn't expect packet type %d",
+			    type);
+		}
+
+		maj_status = PRIVSEP(ssh_gssapi_accept_ctx(ctxt, &recv_tok,
+		    &send_tok, &ret_flags));
+
+		gss_release_buffer(&min_status, &recv_tok);
+
+		if (maj_status != GSS_S_COMPLETE && send_tok.length == 0)
+			fatal("Zero length token output when incomplete");
+
+		if (client_pubkey == NULL)
+			fatal("No client public key");
+
+		if (maj_status & GSS_S_CONTINUE_NEEDED) {
+			debug("Sending GSSAPI_CONTINUE");
+			if ((r = sshpkt_start(ssh, SSH2_MSG_KEXGSS_CONTINUE)) != 0 ||
+			    (r = sshpkt_put_string(ssh, send_tok.value, send_tok.length)) != 0 ||
+			    (r = sshpkt_send(ssh)) != 0)
+				fatal("sshpkt failed: %s", ssh_err(r));
+			gss_release_buffer(&min_status, &send_tok);
+		}
+	} while (maj_status & GSS_S_CONTINUE_NEEDED);
+
+	if (GSS_ERROR(maj_status)) {
+		if (send_tok.length > 0) {
+			if ((r = sshpkt_start(ssh, SSH2_MSG_KEXGSS_CONTINUE)) != 0 ||
+			    (r = sshpkt_put_string(ssh, send_tok.value, send_tok.length)) != 0 ||
+			    (r = sshpkt_send(ssh)) != 0)
+				fatal("sshpkt failed: %s", ssh_err(r));
+		}
+		fatal("accept_ctx died");
+	}
+
+	if (!(ret_flags & GSS_C_MUTUAL_FLAG))
+		fatal("Mutual Authentication flag wasn't set");
+
+	if (!(ret_flags & GSS_C_INTEG_FLAG))
+		fatal("Integrity flag wasn't set");
+
+	hashlen = sizeof(hash);
+	if ((r = kex_gen_hash(
+	    kex->hash_alg,
+	    kex->client_version,
+	    kex->server_version,
+	    kex->peer,
+	    kex->my,
+	    empty,
+	    client_pubkey,
+	    server_pubkey,
+	    shared_secret,
+	    hash, &hashlen)) != 0)
+		goto out;
+
+	gssbuf.value = hash;
+	gssbuf.length = hashlen;
+
+	if (GSS_ERROR(PRIVSEP(ssh_gssapi_sign(ctxt, &gssbuf, &msg_tok))))
+		fatal("Couldn't get MIC");
+
+	if ((r = sshpkt_start(ssh, SSH2_MSG_KEXGSS_COMPLETE)) != 0 ||
+	    (r = sshpkt_put_stringb(ssh, server_pubkey)) != 0 ||
+	    (r = sshpkt_put_string(ssh, msg_tok.value, msg_tok.length)) != 0)
+		fatal("sshpkt failed: %s", ssh_err(r));
+
+	if (send_tok.length != 0) {
+		if ((r = sshpkt_put_u8(ssh, 1)) != 0 || /* true */
+		    (r = sshpkt_put_string(ssh, send_tok.value, send_tok.length)) != 0)
+			fatal("sshpkt failed: %s", ssh_err(r));
+	} else {
+		if ((r = sshpkt_put_u8(ssh, 0)) != 0) /* false */
+			fatal("sshpkt failed: %s", ssh_err(r));
+	}
+	if ((r = sshpkt_send(ssh)) != 0)
+		fatal("sshpkt_send failed: %s", ssh_err(r));
+
+	gss_release_buffer(&min_status, &send_tok);
+	gss_release_buffer(&min_status, &msg_tok);
+
+	if (gss_kex_context == NULL)
+		gss_kex_context = ctxt;
+	else
+		ssh_gssapi_delete_ctx(&ctxt);
+
+	if ((r = kex_derive_keys(ssh, hash, hashlen, shared_secret)) == 0)
+		r = kex_send_newkeys(ssh);
+
+	/* If this was a rekey, then save out any delegated credentials we
+	 * just exchanged.  */
+	if (options.gss_store_rekey)
+		ssh_gssapi_rekey_creds();
+out:
+	sshbuf_free(empty);
+	explicit_bzero(hash, sizeof(hash));
+	sshbuf_free(shared_secret);
+	sshbuf_free(client_pubkey);
+	sshbuf_free(server_pubkey);
+	return r;
+}
+
+int
+kexgssgex_server(struct ssh *ssh)
+{
+	struct kex *kex = ssh->kex;
+	OM_uint32 maj_status, min_status;
+
+	/*
+	 * Some GSSAPI implementations use the input value of ret_flags (an
+	 * output variable) as a means of triggering mechanism specific
+	 * features. Initializing it to zero avoids inadvertently
+	 * activating this non-standard behaviour.
+	 */
+
+	OM_uint32 ret_flags = 0;
+	gss_buffer_desc gssbuf, recv_tok, msg_tok;
+	gss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;
+	Gssctxt *ctxt = NULL;
+	struct sshbuf *shared_secret = NULL;
+	int type = 0;
+	gss_OID oid;
+	char *mechs;
+	u_char hash[SSH_DIGEST_MAX_LENGTH];
+	size_t hashlen;
+	BIGNUM *dh_client_pub = NULL;
+	const BIGNUM *pub_key, *dh_p, *dh_g;
+	int min = -1, max = -1, nbits = -1;
+	int cmin = -1, cmax = -1; /* client proposal */
+	struct sshbuf *empty = sshbuf_new();
+	int r;
+
+	/* Initialise GSSAPI */
+
+	/* If we're rekeying, privsep means that some of the private structures
+	 * in the GSSAPI code are no longer available. This kludges them back
+	 * into life
+	 */
+	if (!ssh_gssapi_oid_table_ok())
+		if ((mechs = ssh_gssapi_server_mechanisms()))
+			free(mechs);
+
+	debug2_f("Identifying %s", kex->name);
+	oid = ssh_gssapi_id_kex(NULL, kex->name, kex->kex_type);
+	if (oid == GSS_C_NO_OID)
+	   fatal("Unknown gssapi mechanism");
+
+	debug2_f("Acquiring credentials");
+
+	if (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, oid))))
+		fatal("Unable to acquire credentials for the server");
+
+	/* 5. S generates an ephemeral key pair (do the allocations early) */
+	debug("Doing group exchange");
+	type = ssh_packet_read(ssh);
+	if (type != SSH2_MSG_KEXGSS_GROUPREQ)
+		ssh_packet_disconnect(ssh,
+		    "Protocol error: expected packet type %d, got %d",
+		    SSH2_MSG_KEXGSS_GROUPREQ, type);
+	/* store client proposal to provide valid signature */
+	if ((r = sshpkt_get_u32(ssh, &cmin)) != 0 ||
+	    (r = sshpkt_get_u32(ssh, &nbits)) != 0 ||
+	    (r = sshpkt_get_u32(ssh, &cmax)) != 0 ||
+	    (r = sshpkt_get_end(ssh)) != 0)
+		fatal("sshpkt failed: %s", ssh_err(r));
+	kex->nbits = nbits;
+	kex->min = cmin;
+	kex->max = cmax;
+	min = MAX(DH_GRP_MIN, cmin);
+	max = MIN(DH_GRP_MAX, cmax);
+	nbits = MAXIMUM(DH_GRP_MIN, nbits);
+	nbits = MINIMUM(DH_GRP_MAX, nbits);
+	if (max < min || nbits < min || max < nbits)
+		fatal("GSS_GEX, bad parameters: %d !< %d !< %d",
+		    min, nbits, max);
+	kex->dh = PRIVSEP(choose_dh(min, nbits, max));
+	if (kex->dh == NULL) {
+		sshpkt_disconnect(ssh, "Protocol error: no matching group found");
+		fatal("Protocol error: no matching group found");
+	}
+
+	DH_get0_pqg(kex->dh, &dh_p, NULL, &dh_g);
+	if ((r = sshpkt_start(ssh, SSH2_MSG_KEXGSS_GROUP)) != 0 ||
+	    (r = sshpkt_put_bignum2(ssh, dh_p)) != 0 ||
+	    (r = sshpkt_put_bignum2(ssh, dh_g)) != 0 ||
+	    (r = sshpkt_send(ssh)) != 0)
+		fatal("sshpkt failed: %s", ssh_err(r));
+
+	if ((r = ssh_packet_write_wait(ssh)) != 0)
+		fatal("ssh_packet_write_wait: %s", ssh_err(r));
+
+	/* Compute our exchange value in parallel with the client */
+	if ((r = dh_gen_key(kex->dh, kex->we_need * 8)) != 0)
+		goto out;
+
+	do {
+		debug("Wait SSH2_MSG_GSSAPI_INIT");
+		type = ssh_packet_read(ssh);
+		switch(type) {
+		case SSH2_MSG_KEXGSS_INIT:
+			if (dh_client_pub != NULL)
+				fatal("Received KEXGSS_INIT after initialising");
+			if ((r = ssh_gssapi_sshpkt_get_buffer_desc(ssh,
+			        &recv_tok)) != 0 ||
+			    (r = sshpkt_get_bignum2(ssh, &dh_client_pub)) != 0 ||
+			    (r = sshpkt_get_end(ssh)) != 0)
+				fatal("sshpkt failed: %s", ssh_err(r));
+
+			/* Send SSH_MSG_KEXGSS_HOSTKEY here, if we want */
+			break;
+		case SSH2_MSG_KEXGSS_CONTINUE:
+			if ((r = ssh_gssapi_sshpkt_get_buffer_desc(ssh,
+			        &recv_tok)) != 0 ||
+			    (r = sshpkt_get_end(ssh)) != 0)
+				fatal("sshpkt failed: %s", ssh_err(r));
+			break;
+		default:
+			sshpkt_disconnect(ssh,
+			    "Protocol error: didn't expect packet type %d",
+			    type);
+		}
+
+		maj_status = PRIVSEP(ssh_gssapi_accept_ctx(ctxt, &recv_tok,
+		    &send_tok, &ret_flags));
+
+		gss_release_buffer(&min_status, &recv_tok);
+
+		if (maj_status != GSS_S_COMPLETE && send_tok.length == 0)
+			fatal("Zero length token output when incomplete");
+
+		if (dh_client_pub == NULL)
+			fatal("No client public key");
+
+		if (maj_status & GSS_S_CONTINUE_NEEDED) {
+			debug("Sending GSSAPI_CONTINUE");
+			if ((r = sshpkt_start(ssh, SSH2_MSG_KEXGSS_CONTINUE)) != 0 ||
+			    (r = sshpkt_put_string(ssh, send_tok.value, send_tok.length)) != 0 ||
+			    (r = sshpkt_send(ssh)) != 0)
+				fatal("sshpkt failed: %s", ssh_err(r));
+			gss_release_buffer(&min_status, &send_tok);
+		}
+	} while (maj_status & GSS_S_CONTINUE_NEEDED);
+
+	if (GSS_ERROR(maj_status)) {
+		if (send_tok.length > 0) {
+			if ((r = sshpkt_start(ssh, SSH2_MSG_KEXGSS_CONTINUE)) != 0 ||
+			    (r = sshpkt_put_string(ssh, send_tok.value, send_tok.length)) != 0 ||
+			    (r = sshpkt_send(ssh)) != 0)
+				fatal("sshpkt failed: %s", ssh_err(r));
+		}
+		fatal("accept_ctx died");
+	}
+
+	if (!(ret_flags & GSS_C_MUTUAL_FLAG))
+		fatal("Mutual Authentication flag wasn't set");
+
+	if (!(ret_flags & GSS_C_INTEG_FLAG))
+		fatal("Integrity flag wasn't set");
+
+	/* calculate shared secret */
+	if ((shared_secret = sshbuf_new()) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if ((r = kex_dh_compute_key(kex, dh_client_pub, shared_secret)) != 0)
+		goto out;
+
+	DH_get0_key(kex->dh, &pub_key, NULL);
+	DH_get0_pqg(kex->dh, &dh_p, NULL, &dh_g);
+	hashlen = sizeof(hash);
+	if ((r = kexgex_hash(
+	    kex->hash_alg,
+	    kex->client_version,
+	    kex->server_version,
+	    kex->peer,
+	    kex->my,
+	    empty,
+	    cmin, nbits, cmax,
+	    dh_p, dh_g,
+	    dh_client_pub,
+	    pub_key,
+	    sshbuf_ptr(shared_secret), sshbuf_len(shared_secret),
+	    hash, &hashlen)) != 0)
+		fatal("kexgex_hash failed: %s", ssh_err(r));
+
+	gssbuf.value = hash;
+	gssbuf.length = hashlen;
+
+	if (GSS_ERROR(PRIVSEP(ssh_gssapi_sign(ctxt, &gssbuf, &msg_tok))))
+		fatal("Couldn't get MIC");
+
+	if ((r = sshpkt_start(ssh, SSH2_MSG_KEXGSS_COMPLETE)) != 0 ||
+	    (r = sshpkt_put_bignum2(ssh, pub_key)) != 0 ||
+	    (r = sshpkt_put_string(ssh, msg_tok.value, msg_tok.length)) != 0)
+		fatal("sshpkt failed: %s", ssh_err(r));
+
+	if (send_tok.length != 0) {
+		if ((r = sshpkt_put_u8(ssh, 1)) != 0 || /* true */
+		    (r = sshpkt_put_string(ssh, send_tok.value, send_tok.length)) != 0)
+			fatal("sshpkt failed: %s", ssh_err(r));
+	} else {
+		if ((r = sshpkt_put_u8(ssh, 0)) != 0) /* false */
+			fatal("sshpkt failed: %s", ssh_err(r));
+	}
+	if ((r = sshpkt_send(ssh)) != 0)
+		fatal("sshpkt failed: %s", ssh_err(r));
+
+	gss_release_buffer(&min_status, &send_tok);
+	gss_release_buffer(&min_status, &msg_tok);
+
+	if (gss_kex_context == NULL)
+		gss_kex_context = ctxt;
+	else
+		ssh_gssapi_delete_ctx(&ctxt);
+
+	/* Finally derive the keys and send them */
+	if ((r = kex_derive_keys(ssh, hash, hashlen, shared_secret)) == 0)
+		r = kex_send_newkeys(ssh);
+
+	/* If this was a rekey, then save out any delegated credentials we
+	 * just exchanged.  */
+	if (options.gss_store_rekey)
+		ssh_gssapi_rekey_creds();
+out:
+	sshbuf_free(empty);
+	explicit_bzero(hash, sizeof(hash));
+	DH_free(kex->dh);
+	kex->dh = NULL;
+	BN_clear_free(dh_client_pub);
+	sshbuf_free(shared_secret);
+	return r;
+}
+#endif /* defined(GSSAPI) && defined(WITH_OPENSSL) */
diff --git a/monitor.c b/monitor.c
index b3ed515ed..2bc152468 100644
--- a/monitor.c
+++ b/monitor.c
@@ -142,6 +142,8 @@ int mm_answer_gss_setup_ctx(struct ssh *, int, struct sshbuf *);
 int mm_answer_gss_accept_ctx(struct ssh *, int, struct sshbuf *);
 int mm_answer_gss_userok(struct ssh *, int, struct sshbuf *);
 int mm_answer_gss_checkmic(struct ssh *, int, struct sshbuf *);
+int mm_answer_gss_sign(struct ssh *, int, struct sshbuf *);
+int mm_answer_gss_updatecreds(struct ssh *, int, struct sshbuf *);
 #endif
 
 #ifdef SSH_AUDIT_EVENTS
@@ -214,11 +216,18 @@ struct mon_table mon_dispatch_proto20[] = {
     {MONITOR_REQ_GSSSTEP, 0, mm_answer_gss_accept_ctx},
     {MONITOR_REQ_GSSUSEROK, MON_ONCE|MON_AUTHDECIDE, mm_answer_gss_userok},
     {MONITOR_REQ_GSSCHECKMIC, MON_ONCE, mm_answer_gss_checkmic},
+    {MONITOR_REQ_GSSSIGN, MON_ONCE, mm_answer_gss_sign},
 #endif
     {0, 0, NULL}
 };
 
 struct mon_table mon_dispatch_postauth20[] = {
+#ifdef GSSAPI
+    {MONITOR_REQ_GSSSETUP, 0, mm_answer_gss_setup_ctx},
+    {MONITOR_REQ_GSSSTEP, 0, mm_answer_gss_accept_ctx},
+    {MONITOR_REQ_GSSSIGN, 0, mm_answer_gss_sign},
+    {MONITOR_REQ_GSSUPCREDS, 0, mm_answer_gss_updatecreds},
+#endif
 #ifdef WITH_OPENSSL
     {MONITOR_REQ_MODULI, 0, mm_answer_moduli},
 #endif
@@ -287,6 +296,10 @@ monitor_child_preauth(struct ssh *ssh, struct monitor *pmonitor)
 	/* Permit requests for moduli and signatures */
 	monitor_permit(mon_dispatch, MONITOR_REQ_MODULI, 1);
 	monitor_permit(mon_dispatch, MONITOR_REQ_SIGN, 1);
+#ifdef GSSAPI
+	/* and for the GSSAPI key exchange */
+	monitor_permit(mon_dispatch, MONITOR_REQ_GSSSETUP, 1);
+#endif
 
 	/* The first few requests do not require asynchronous access */
 	while (!authenticated) {
@@ -403,6 +416,10 @@ monitor_child_postauth(struct ssh *ssh, struct monitor *pmonitor)
 	monitor_permit(mon_dispatch, MONITOR_REQ_MODULI, 1);
 	monitor_permit(mon_dispatch, MONITOR_REQ_SIGN, 1);
 	monitor_permit(mon_dispatch, MONITOR_REQ_TERM, 1);
+#ifdef GSSAPI
+	/* and for the GSSAPI key exchange */
+	monitor_permit(mon_dispatch, MONITOR_REQ_GSSSETUP, 1);
+#endif
 
 	if (auth_opts->permit_pty_flag) {
 		monitor_permit(mon_dispatch, MONITOR_REQ_PTY, 1);
@@ -1745,6 +1762,17 @@ monitor_apply_keystate(struct ssh *ssh, struct monitor *pmonitor)
 # ifdef OPENSSL_HAS_ECC
 	kex->kex[KEX_ECDH_SHA2] = kex_gen_server;
 # endif
+# ifdef GSSAPI
+	if (options.gss_keyex) {
+		kex->kex[KEX_GSS_GRP1_SHA1] = kexgss_server;
+		kex->kex[KEX_GSS_GRP14_SHA1] = kexgss_server;
+		kex->kex[KEX_GSS_GRP14_SHA256] = kexgss_server;
+		kex->kex[KEX_GSS_GRP16_SHA512] = kexgss_server;
+		kex->kex[KEX_GSS_GEX_SHA1] = kexgssgex_server;
+		kex->kex[KEX_GSS_NISTP256_SHA256] = kexgss_server;
+		kex->kex[KEX_GSS_C25519_SHA256] = kexgss_server;
+	}
+# endif
 #endif /* WITH_OPENSSL */
 	kex->kex[KEX_C25519_SHA256] = kex_gen_server;
 	kex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_server;
@@ -1837,8 +1865,8 @@ mm_answer_gss_setup_ctx(struct ssh *ssh, int sock, struct sshbuf *m)
 	u_char *p;
 	int r;
 
-	if (!options.gss_authentication)
-		fatal_f("GSSAPI authentication not enabled");
+	if (!options.gss_authentication && !options.gss_keyex)
+		fatal_f("GSSAPI not enabled");
 
 	if ((r = sshbuf_get_string(m, &p, &len)) != 0)
 		fatal_fr(r, "parse");
@@ -1870,8 +1898,8 @@ mm_answer_gss_accept_ctx(struct ssh *ssh, int sock, struct sshbuf *m)
 	OM_uint32 flags = 0; /* GSI needs this */
 	int r;
 
-	if (!options.gss_authentication)
-		fatal_f("GSSAPI authentication not enabled");
+	if (!options.gss_authentication && !options.gss_keyex)
+		fatal_f("GSSAPI not enabled");
 
 	if ((r = ssh_gssapi_get_buffer_desc(m, &in)) != 0)
 		fatal_fr(r, "ssh_gssapi_get_buffer_desc");
@@ -1891,6 +1919,7 @@ mm_answer_gss_accept_ctx(struct ssh *ssh, int sock, struct sshbuf *m)
 		monitor_permit(mon_dispatch, MONITOR_REQ_GSSSTEP, 0);
 		monitor_permit(mon_dispatch, MONITOR_REQ_GSSUSEROK, 1);
 		monitor_permit(mon_dispatch, MONITOR_REQ_GSSCHECKMIC, 1);
+		monitor_permit(mon_dispatch, MONITOR_REQ_GSSSIGN, 1);
 	}
 	return (0);
 }
@@ -1902,8 +1931,8 @@ mm_answer_gss_checkmic(struct ssh *ssh, int sock, struct sshbuf *m)
 	OM_uint32 ret;
 	int r;
 
-	if (!options.gss_authentication)
-		fatal_f("GSSAPI authentication not enabled");
+	if (!options.gss_authentication && !options.gss_keyex)
+		fatal_f("GSSAPI not enabled");
 
 	if ((r = ssh_gssapi_get_buffer_desc(m, &gssbuf)) != 0 ||
 	    (r = ssh_gssapi_get_buffer_desc(m, &mic)) != 0)
@@ -1929,13 +1958,17 @@ mm_answer_gss_checkmic(struct ssh *ssh, int sock, struct sshbuf *m)
 int
 mm_answer_gss_userok(struct ssh *ssh, int sock, struct sshbuf *m)
 {
-	int r, authenticated;
+	int r, authenticated, kex;
 	const char *displayname;
 
-	if (!options.gss_authentication)
-		fatal_f("GSSAPI authentication not enabled");
+	if (!options.gss_authentication && !options.gss_keyex)
+		fatal_f("GSSAPI not enabled");
 
-	authenticated = authctxt->valid && ssh_gssapi_userok(authctxt->user);
+	if ((r = sshbuf_get_u32(m, &kex)) != 0)
+		fatal_fr(r, "buffer error");
+
+	authenticated = authctxt->valid &&
+	    ssh_gssapi_userok(authctxt->user, authctxt->pw, kex);
 
 	sshbuf_reset(m);
 	if ((r = sshbuf_put_u32(m, authenticated)) != 0)
@@ -1944,7 +1977,11 @@ mm_answer_gss_userok(struct ssh *ssh, int sock, struct sshbuf *m)
 	debug3_f("sending result %d", authenticated);
 	mm_request_send(sock, MONITOR_ANS_GSSUSEROK, m);
 
-	auth_method = "gssapi-with-mic";
+	if (kex) {
+		auth_method = "gssapi-keyex";
+	} else {
+		auth_method = "gssapi-with-mic";
+	}
 
 	if ((displayname = ssh_gssapi_displayname()) != NULL)
 		auth2_record_info(authctxt, "%s", displayname);
@@ -1952,5 +1989,83 @@ mm_answer_gss_userok(struct ssh *ssh, int sock, struct sshbuf *m)
 	/* Monitor loop will terminate if authenticated */
 	return (authenticated);
 }
-#endif /* GSSAPI */
 
+int
+mm_answer_gss_sign(struct ssh *ssh, int socket, struct sshbuf *m)
+{
+	gss_buffer_desc data;
+	gss_buffer_desc hash = GSS_C_EMPTY_BUFFER;
+	OM_uint32 major, minor;
+	size_t len;
+	u_char *p = NULL;
+	int r;
+
+	if (!options.gss_authentication && !options.gss_keyex)
+		fatal_f("GSSAPI not enabled");
+
+	if ((r = sshbuf_get_string(m, &p, &len)) != 0)
+		fatal_fr(r, "buffer error");
+	data.value = p;
+	data.length = len;
+	/* Lengths of SHA-1, SHA-256 and SHA-512 hashes that are used */
+	if (data.length != 20 && data.length != 32 && data.length != 64)
+		fatal_f("data length incorrect: %d", (int) data.length);
+
+	/* Save the session ID on the first time around */
+	if (session_id2_len == 0) {
+		session_id2_len = data.length;
+		session_id2 = xmalloc(session_id2_len);
+		memcpy(session_id2, data.value, session_id2_len);
+	}
+	major = ssh_gssapi_sign(gsscontext, &data, &hash);
+
+	free(data.value);
+
+	sshbuf_reset(m);
+
+	if ((r = sshbuf_put_u32(m, major)) != 0 ||
+	    (r = sshbuf_put_string(m, hash.value, hash.length)) != 0)
+		fatal_fr(r, "buffer error");
+
+	mm_request_send(socket, MONITOR_ANS_GSSSIGN, m);
+
+	gss_release_buffer(&minor, &hash);
+
+	/* Turn on getpwnam permissions */
+	monitor_permit(mon_dispatch, MONITOR_REQ_PWNAM, 1);
+
+	/* And credential updating, for when rekeying */
+	monitor_permit(mon_dispatch, MONITOR_REQ_GSSUPCREDS, 1);
+
+	return (0);
+}
+
+int
+mm_answer_gss_updatecreds(struct ssh *ssh, int socket, struct sshbuf *m) {
+	ssh_gssapi_ccache store;
+	int r, ok;
+
+	if (!options.gss_authentication && !options.gss_keyex)
+		fatal_f("GSSAPI not enabled");
+
+	if ((r = sshbuf_get_string(m, (u_char **)&store.filename, NULL)) != 0 ||
+	    (r = sshbuf_get_string(m, (u_char **)&store.envvar, NULL)) != 0 ||
+	    (r = sshbuf_get_string(m, (u_char **)&store.envval, NULL)) != 0)
+		fatal_fr(r, "buffer error");
+
+	ok = ssh_gssapi_update_creds(&store);
+
+	free(store.filename);
+	free(store.envvar);
+	free(store.envval);
+
+	sshbuf_reset(m);
+	if ((r = sshbuf_put_u32(m, ok)) != 0)
+		fatal_fr(r, "buffer error");
+
+	mm_request_send(socket, MONITOR_ANS_GSSUPCREDS, m);
+
+	return(0);
+}
+
+#endif /* GSSAPI */
diff --git a/monitor.h b/monitor.h
index 683e5e071..2b1a2d590 100644
--- a/monitor.h
+++ b/monitor.h
@@ -63,6 +63,8 @@ enum monitor_reqtype {
 	MONITOR_REQ_PAM_FREE_CTX = 110, MONITOR_ANS_PAM_FREE_CTX = 111,
 	MONITOR_REQ_AUDIT_EVENT = 112, MONITOR_REQ_AUDIT_COMMAND = 113,
 
+	MONITOR_REQ_GSSSIGN = 150, MONITOR_ANS_GSSSIGN = 151,
+	MONITOR_REQ_GSSUPCREDS = 152, MONITOR_ANS_GSSUPCREDS = 153,
 };
 
 struct ssh;
diff --git a/monitor_wrap.c b/monitor_wrap.c
index 6270d1398..189467037 100644
--- a/monitor_wrap.c
+++ b/monitor_wrap.c
@@ -998,13 +998,15 @@ mm_ssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)
 }
 
 int
-mm_ssh_gssapi_userok(char *user)
+mm_ssh_gssapi_userok(char *user, struct passwd *pw, int kex)
 {
 	struct sshbuf *m;
 	int r, authenticated = 0;
 
 	if ((m = sshbuf_new()) == NULL)
 		fatal_f("sshbuf_new failed");
+	if ((r = sshbuf_put_u32(m, kex)) != 0)
+		fatal_fr(r, "buffer error");
 
 	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSUSEROK, m);
 	mm_request_receive_expect(pmonitor->m_recvfd,
@@ -1017,4 +1019,57 @@ mm_ssh_gssapi_userok(char *user)
 	debug3_f("user %sauthenticated", authenticated ? "" : "not ");
 	return (authenticated);
 }
+
+OM_uint32
+mm_ssh_gssapi_sign(Gssctxt *ctx, gss_buffer_desc *data, gss_buffer_desc *hash)
+{
+	struct sshbuf *m;
+	OM_uint32 major;
+	int r;
+
+	if ((m = sshbuf_new()) == NULL)
+		fatal_f("sshbuf_new failed");
+	if ((r = sshbuf_put_string(m, data->value, data->length)) != 0)
+		fatal_fr(r, "buffer error");
+
+	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSSIGN, m);
+	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSSIGN, m);
+
+	if ((r = sshbuf_get_u32(m, &major)) != 0 ||
+	    (r = ssh_gssapi_get_buffer_desc(m, hash)) != 0)
+		fatal_fr(r, "buffer error");
+
+	sshbuf_free(m);
+
+	return (major);
+}
+
+int
+mm_ssh_gssapi_update_creds(ssh_gssapi_ccache *store)
+{
+	struct sshbuf *m;
+	int r, ok;
+
+	if ((m = sshbuf_new()) == NULL)
+		fatal_f("sshbuf_new failed");
+
+	if ((r = sshbuf_put_cstring(m,
+	    store->filename ? store->filename : "")) != 0 ||
+	    (r = sshbuf_put_cstring(m,
+	    store->envvar ? store->envvar : "")) != 0 ||
+	    (r = sshbuf_put_cstring(m,
+	    store->envval ? store->envval : "")) != 0)
+		fatal_fr(r, "buffer error");
+
+	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSUPCREDS, m);
+	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSUPCREDS, m);
+
+	if ((r = sshbuf_get_u32(m, &ok)) != 0)
+		fatal_fr(r, "buffer error");
+
+	sshbuf_free(m);
+
+	return (ok);
+}
+
 #endif /* GSSAPI */
diff --git a/monitor_wrap.h b/monitor_wrap.h
index 0df49c25b..830fdb308 100644
--- a/monitor_wrap.h
+++ b/monitor_wrap.h
@@ -65,8 +65,10 @@ int mm_sshkey_verify(const struct sshkey *, const u_char *, size_t,
 OM_uint32 mm_ssh_gssapi_server_ctx(Gssctxt **, gss_OID);
 OM_uint32 mm_ssh_gssapi_accept_ctx(Gssctxt *,
    gss_buffer_desc *, gss_buffer_desc *, OM_uint32 *);
-int mm_ssh_gssapi_userok(char *user);
+int mm_ssh_gssapi_userok(char *user, struct passwd *, int kex);
 OM_uint32 mm_ssh_gssapi_checkmic(Gssctxt *, gss_buffer_t, gss_buffer_t);
+OM_uint32 mm_ssh_gssapi_sign(Gssctxt *, gss_buffer_t, gss_buffer_t);
+int mm_ssh_gssapi_update_creds(ssh_gssapi_ccache *);
 #endif
 
 #ifdef USE_PAM
diff --git a/readconf.c b/readconf.c
index a2282b562..ef67ab20f 100644
--- a/readconf.c
+++ b/readconf.c
@@ -70,6 +70,7 @@
 #include "uidswap.h"
 #include "myproposal.h"
 #include "digest.h"
+#include "ssh-gss.h"
 
 /* Format of the configuration file:
 
@@ -164,6 +165,8 @@ typedef enum {
 	oClearAllForwardings, oNoHostAuthenticationForLocalhost,
 	oEnableSSHKeysign, oRekeyLimit, oVerifyHostKeyDNS, oConnectTimeout,
 	oAddressFamily, oGssAuthentication, oGssDelegateCreds,
+	oGssTrustDns, oGssKeyEx, oGssClientIdentity, oGssRenewalRekey,
+	oGssServerIdentity, oGssKexAlgorithms,
 	oServerAliveInterval, oServerAliveCountMax, oIdentitiesOnly,
 	oSendEnv, oSetEnv, oControlPath, oControlMaster, oControlPersist,
 	oHashKnownHosts,
@@ -210,10 +213,22 @@ static struct {
 	/* Sometimes-unsupported options */
 #if defined(GSSAPI)
 	{ "gssapiauthentication", oGssAuthentication },
+	{ "gssapikeyexchange", oGssKeyEx },
 	{ "gssapidelegatecredentials", oGssDelegateCreds },
+	{ "gssapitrustdns", oGssTrustDns },
+	{ "gssapiclientidentity", oGssClientIdentity },
+	{ "gssapiserveridentity", oGssServerIdentity },
+	{ "gssapirenewalforcesrekey", oGssRenewalRekey },
+	{ "gssapikexalgorithms", oGssKexAlgorithms },
 # else
 	{ "gssapiauthentication", oUnsupported },
+	{ "gssapikeyexchange", oUnsupported },
 	{ "gssapidelegatecredentials", oUnsupported },
+	{ "gssapitrustdns", oUnsupported },
+	{ "gssapiclientidentity", oUnsupported },
+	{ "gssapiserveridentity", oUnsupported },
+	{ "gssapirenewalforcesrekey", oUnsupported },
+	{ "gssapikexalgorithms", oUnsupported },
 #endif
 #ifdef ENABLE_PKCS11
 	{ "pkcs11provider", oPKCS11Provider },
@@ -1210,10 +1225,46 @@ parse_time:
 		intptr = &options->gss_authentication;
 		goto parse_flag;
 
+	case oGssKeyEx:
+		intptr = &options->gss_keyex;
+		goto parse_flag;
+
 	case oGssDelegateCreds:
 		intptr = &options->gss_deleg_creds;
 		goto parse_flag;
 
+	case oGssTrustDns:
+		intptr = &options->gss_trust_dns;
+		goto parse_flag;
+
+	case oGssClientIdentity:
+		charptr = &options->gss_client_identity;
+		goto parse_string;
+
+	case oGssServerIdentity:
+		charptr = &options->gss_server_identity;
+		goto parse_string;
+
+	case oGssRenewalRekey:
+		intptr = &options->gss_renewal_rekey;
+		goto parse_flag;
+
+	case oGssKexAlgorithms:
+		arg = argv_next(&ac, &av);
+		if (!arg || *arg == '\0') {
+			error("%.200s line %d: Missing argument.",
+			    filename, linenum);
+			goto out;
+		}
+		if (!kex_gss_names_valid(arg)) {
+			error("%.200s line %d: Bad GSSAPI KexAlgorithms '%s'.",
+			    filename, linenum, arg ? arg : "<NONE>");
+			goto out;
+		}
+		if (*activep && options->gss_kex_algorithms == NULL)
+			options->gss_kex_algorithms = xstrdup(arg);
+		break;
+
 	case oBatchMode:
 		intptr = &options->batch_mode;
 		goto parse_flag;
@@ -2505,7 +2556,13 @@ initialize_options(Options * options)
 	options->fwd_opts.streamlocal_bind_unlink = -1;
 	options->pubkey_authentication = -1;
 	options->gss_authentication = -1;
+	options->gss_keyex = -1;
 	options->gss_deleg_creds = -1;
+	options->gss_trust_dns = -1;
+	options->gss_renewal_rekey = -1;
+	options->gss_client_identity = NULL;
+	options->gss_server_identity = NULL;
+	options->gss_kex_algorithms = NULL;
 	options->password_authentication = -1;
 	options->kbd_interactive_authentication = -1;
 	options->kbd_interactive_devices = NULL;
@@ -2668,8 +2725,18 @@ fill_default_options(Options * options)
 		options->pubkey_authentication = SSH_PUBKEY_AUTH_ALL;
 	if (options->gss_authentication == -1)
 		options->gss_authentication = 0;
+	if (options->gss_keyex == -1)
+		options->gss_keyex = 0;
 	if (options->gss_deleg_creds == -1)
 		options->gss_deleg_creds = 0;
+	if (options->gss_trust_dns == -1)
+		options->gss_trust_dns = 0;
+	if (options->gss_renewal_rekey == -1)
+		options->gss_renewal_rekey = 0;
+#ifdef GSSAPI
+	if (options->gss_kex_algorithms == NULL)
+		options->gss_kex_algorithms = strdup(GSS_KEX_DEFAULT_KEX);
+#endif
 	if (options->password_authentication == -1)
 		options->password_authentication = 1;
 	if (options->kbd_interactive_authentication == -1)
@@ -3494,7 +3561,14 @@ dump_client_config(Options *o, const char *host)
 	dump_cfg_fmtint(oGatewayPorts, o->fwd_opts.gateway_ports);
 #ifdef GSSAPI
 	dump_cfg_fmtint(oGssAuthentication, o->gss_authentication);
+	dump_cfg_fmtint(oGssKeyEx, o->gss_keyex);
 	dump_cfg_fmtint(oGssDelegateCreds, o->gss_deleg_creds);
+	dump_cfg_fmtint(oGssTrustDns, o->gss_trust_dns);
+	dump_cfg_fmtint(oGssRenewalRekey, o->gss_renewal_rekey);
+	dump_cfg_string(oGssClientIdentity, o->gss_client_identity);
+	dump_cfg_string(oGssServerIdentity, o->gss_server_identity);
+	dump_cfg_string(oGssKexAlgorithms, o->gss_kex_algorithms ?
+	    o->gss_kex_algorithms : GSS_KEX_DEFAULT_KEX);
 #endif /* GSSAPI */
 	dump_cfg_fmtint(oHashKnownHosts, o->hash_known_hosts);
 	dump_cfg_fmtint(oHostbasedAuthentication, o->hostbased_authentication);
diff --git a/readconf.h b/readconf.h
index ff7180cd0..0d2ad44f9 100644
--- a/readconf.h
+++ b/readconf.h
@@ -40,7 +40,13 @@ typedef struct {
 	int     pubkey_authentication;	/* Try ssh2 pubkey authentication. */
 	int     hostbased_authentication;	/* ssh2's rhosts_rsa */
 	int     gss_authentication;	/* Try GSS authentication */
+	int     gss_keyex;		/* Try GSS key exchange */
 	int     gss_deleg_creds;	/* Delegate GSS credentials */
+	int	gss_trust_dns;		/* Trust DNS for GSS canonicalization */
+	int	gss_renewal_rekey;	/* Credential renewal forces rekey */
+	char    *gss_client_identity;   /* Principal to initiate GSSAPI with */
+	char    *gss_server_identity;   /* GSSAPI target principal */
+	char    *gss_kex_algorithms;	/* GSSAPI kex methods to be offered by client. */
 	int     password_authentication;	/* Try password
 						 * authentication. */
 	int     kbd_interactive_authentication; /* Try keyboard-interactive auth. */
diff --git a/servconf.c b/servconf.c
index 86c297936..940e1d50a 100644
--- a/servconf.c
+++ b/servconf.c
@@ -68,6 +68,7 @@
 #include "auth.h"
 #include "myproposal.h"
 #include "digest.h"
+#include "ssh-gss.h"
 
 static void add_listen_addr(ServerOptions *, const char *,
     const char *, int);
@@ -134,8 +135,11 @@ initialize_server_options(ServerOptions *options)
 	options->kerberos_ticket_cleanup = -1;
 	options->kerberos_get_afs_token = -1;
 	options->gss_authentication=-1;
+	options->gss_keyex = -1;
 	options->gss_cleanup_creds = -1;
 	options->gss_strict_acceptor = -1;
+	options->gss_store_rekey = -1;
+	options->gss_kex_algorithms = NULL;
 	options->password_authentication = -1;
 	options->kbd_interactive_authentication = -1;
 	options->permit_empty_passwd = -1;
@@ -358,10 +362,18 @@ fill_default_server_options(ServerOptions *options)
 		options->kerberos_get_afs_token = 0;
 	if (options->gss_authentication == -1)
 		options->gss_authentication = 0;
+	if (options->gss_keyex == -1)
+		options->gss_keyex = 0;
 	if (options->gss_cleanup_creds == -1)
 		options->gss_cleanup_creds = 1;
 	if (options->gss_strict_acceptor == -1)
 		options->gss_strict_acceptor = 1;
+	if (options->gss_store_rekey == -1)
+		options->gss_store_rekey = 0;
+#ifdef GSSAPI
+	if (options->gss_kex_algorithms == NULL)
+		options->gss_kex_algorithms = strdup(GSS_KEX_DEFAULT_KEX);
+#endif
 	if (options->password_authentication == -1)
 		options->password_authentication = 1;
 	if (options->kbd_interactive_authentication == -1)
@@ -518,6 +530,7 @@ typedef enum {
 	sHostKeyAlgorithms, sPerSourceMaxStartups, sPerSourceNetBlockSize,
 	sClientAliveInterval, sClientAliveCountMax, sAuthorizedKeysFile,
 	sGssAuthentication, sGssCleanupCreds, sGssStrictAcceptor,
+	sGssKeyEx, sGssKexAlgorithms, sGssStoreRekey,
 	sAcceptEnv, sSetEnv, sPermitTunnel,
 	sMatch, sPermitOpen, sPermitListen, sForceCommand, sChrootDirectory,
 	sUsePrivilegeSeparation, sAllowAgentForwarding,
@@ -600,12 +613,22 @@ static struct {
 #ifdef GSSAPI
 	{ "gssapiauthentication", sGssAuthentication, SSHCFG_ALL },
 	{ "gssapicleanupcredentials", sGssCleanupCreds, SSHCFG_GLOBAL },
+	{ "gssapicleanupcreds", sGssCleanupCreds, SSHCFG_GLOBAL },
 	{ "gssapistrictacceptorcheck", sGssStrictAcceptor, SSHCFG_GLOBAL },
+	{ "gssapikeyexchange", sGssKeyEx, SSHCFG_GLOBAL },
+	{ "gssapistorecredentialsonrekey", sGssStoreRekey, SSHCFG_GLOBAL },
+	{ "gssapikexalgorithms", sGssKexAlgorithms, SSHCFG_GLOBAL },
 #else
 	{ "gssapiauthentication", sUnsupported, SSHCFG_ALL },
 	{ "gssapicleanupcredentials", sUnsupported, SSHCFG_GLOBAL },
+	{ "gssapicleanupcreds", sUnsupported, SSHCFG_GLOBAL },
 	{ "gssapistrictacceptorcheck", sUnsupported, SSHCFG_GLOBAL },
+	{ "gssapikeyexchange", sUnsupported, SSHCFG_GLOBAL },
+	{ "gssapistorecredentialsonrekey", sUnsupported, SSHCFG_GLOBAL },
+	{ "gssapikexalgorithms", sUnsupported, SSHCFG_GLOBAL },
 #endif
+	{ "gssusesessionccache", sUnsupported, SSHCFG_GLOBAL },
+	{ "gssapiusesessioncredcache", sUnsupported, SSHCFG_GLOBAL },
 	{ "passwordauthentication", sPasswordAuthentication, SSHCFG_ALL },
 	{ "kbdinteractiveauthentication", sKbdInteractiveAuthentication, SSHCFG_ALL },
 	{ "challengeresponseauthentication", sKbdInteractiveAuthentication, SSHCFG_ALL }, /* alias */
@@ -1616,6 +1639,10 @@ process_server_config_line_depth(ServerOptions *options, char *line,
 		intptr = &options->gss_authentication;
 		goto parse_flag;
 
+	case sGssKeyEx:
+		intptr = &options->gss_keyex;
+		goto parse_flag;
+
 	case sGssCleanupCreds:
 		intptr = &options->gss_cleanup_creds;
 		goto parse_flag;
@@ -1624,6 +1651,22 @@ process_server_config_line_depth(ServerOptions *options, char *line,
 		intptr = &options->gss_strict_acceptor;
 		goto parse_flag;
 
+	case sGssStoreRekey:
+		intptr = &options->gss_store_rekey;
+		goto parse_flag;
+
+	case sGssKexAlgorithms:
+		arg = argv_next(&ac, &av);
+		if (!arg || *arg == '\0')
+			fatal("%.200s line %d: Missing argument.",
+			    filename, linenum);
+		if (!kex_gss_names_valid(arg))
+			fatal("%.200s line %d: Bad GSSAPI KexAlgorithms '%s'.",
+			    filename, linenum, arg ? arg : "<NONE>");
+		if (*activep && options->gss_kex_algorithms == NULL)
+			options->gss_kex_algorithms = xstrdup(arg);
+		break;
+
 	case sPasswordAuthentication:
 		intptr = &options->password_authentication;
 		goto parse_flag;
@@ -3058,6 +3101,10 @@ dump_config(ServerOptions *o)
 #ifdef GSSAPI
 	dump_cfg_fmtint(sGssAuthentication, o->gss_authentication);
 	dump_cfg_fmtint(sGssCleanupCreds, o->gss_cleanup_creds);
+	dump_cfg_fmtint(sGssKeyEx, o->gss_keyex);
+	dump_cfg_fmtint(sGssStrictAcceptor, o->gss_strict_acceptor);
+	dump_cfg_fmtint(sGssStoreRekey, o->gss_store_rekey);
+	dump_cfg_string(sGssKexAlgorithms, o->gss_kex_algorithms);
 #endif
 	dump_cfg_fmtint(sPasswordAuthentication, o->password_authentication);
 	dump_cfg_fmtint(sKbdInteractiveAuthentication,
diff --git a/servconf.h b/servconf.h
index ed7b72e8e..2ce4ae0ad 100644
--- a/servconf.h
+++ b/servconf.h
@@ -139,8 +139,11 @@ typedef struct {
 	int     kerberos_get_afs_token;		/* If true, try to get AFS token if
 						 * authenticated with Kerberos. */
 	int     gss_authentication;	/* If true, permit GSSAPI authentication */
+	int     gss_keyex;		/* If true, permit GSSAPI key exchange */
 	int     gss_cleanup_creds;	/* If true, destroy cred cache on logout */
 	int     gss_strict_acceptor;	/* If true, restrict the GSSAPI acceptor name */
+	int 	gss_store_rekey;
+	char   *gss_kex_algorithms;	/* GSSAPI kex methods to be offered by client. */
 	int     password_authentication;	/* If true, permit password
 						 * authentication. */
 	int     kbd_interactive_authentication;	/* If true, permit */
diff --git a/session.c b/session.c
index aa342e84d..f985b8177 100644
--- a/session.c
+++ b/session.c
@@ -2687,13 +2687,19 @@ do_cleanup(struct ssh *ssh, Authctxt *authctxt)
 
 #ifdef KRB5
 	if (options.kerberos_ticket_cleanup &&
-	    authctxt->krb5_ctx)
+	    authctxt->krb5_ctx) {
+		temporarily_use_uid(authctxt->pw);
 		krb5_cleanup_proc(authctxt);
+		restore_uid();
+	}
 #endif
 
 #ifdef GSSAPI
-	if (options.gss_cleanup_creds)
+	if (options.gss_cleanup_creds) {
+		temporarily_use_uid(authctxt->pw);
 		ssh_gssapi_cleanup_creds();
+		restore_uid();
+	}
 #endif
 
 	/* remove agent socket */
diff --git a/ssh-gss.h b/ssh-gss.h
index a8af117d2..6303ce185 100644
--- a/ssh-gss.h
+++ b/ssh-gss.h
@@ -1,6 +1,6 @@
 /* $OpenBSD: ssh-gss.h,v 1.15 2021/01/27 10:05:28 djm Exp $ */
 /*
- * Copyright (c) 2001-2003 Simon Wilkinson. All rights reserved.
+ * Copyright (c) 2001-2009 Simon Wilkinson. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -61,10 +61,34 @@
 
 #define SSH_GSS_OIDTYPE 0x06
 
+#define SSH2_MSG_KEXGSS_INIT                            30
+#define SSH2_MSG_KEXGSS_CONTINUE                        31
+#define SSH2_MSG_KEXGSS_COMPLETE                        32
+#define SSH2_MSG_KEXGSS_HOSTKEY                         33
+#define SSH2_MSG_KEXGSS_ERROR                           34
+#define SSH2_MSG_KEXGSS_GROUPREQ			40
+#define SSH2_MSG_KEXGSS_GROUP				41
+#define KEX_GSS_GRP1_SHA1_ID				"gss-group1-sha1-"
+#define KEX_GSS_GRP14_SHA1_ID				"gss-group14-sha1-"
+#define KEX_GSS_GRP14_SHA256_ID			"gss-group14-sha256-"
+#define KEX_GSS_GRP16_SHA512_ID			"gss-group16-sha512-"
+#define KEX_GSS_GEX_SHA1_ID				"gss-gex-sha1-"
+#define KEX_GSS_NISTP256_SHA256_ID			"gss-nistp256-sha256-"
+#define KEX_GSS_C25519_SHA256_ID			"gss-curve25519-sha256-"
+
+#define        GSS_KEX_DEFAULT_KEX \
+	KEX_GSS_GRP14_SHA256_ID	"," \
+	KEX_GSS_GRP16_SHA512_ID	"," \
+	KEX_GSS_NISTP256_SHA256_ID "," \
+	KEX_GSS_C25519_SHA256_ID "," \
+	KEX_GSS_GRP14_SHA1_ID "," \
+	KEX_GSS_GEX_SHA1_ID
+
 typedef struct {
 	char *filename;
 	char *envvar;
 	char *envval;
+	struct passwd *owner;
 	void *data;
 } ssh_gssapi_ccache;
 
@@ -72,8 +96,11 @@ typedef struct {
 	gss_buffer_desc displayname;
 	gss_buffer_desc exportedname;
 	gss_cred_id_t creds;
+	gss_name_t name;
 	struct ssh_gssapi_mech_struct *mech;
 	ssh_gssapi_ccache store;
+	int used;
+	int updated;
 } ssh_gssapi_client;
 
 typedef struct ssh_gssapi_mech_struct {
@@ -84,6 +111,7 @@ typedef struct ssh_gssapi_mech_struct {
 	int (*userok) (ssh_gssapi_client *, char *);
 	int (*localname) (ssh_gssapi_client *, char **);
 	void (*storecreds) (ssh_gssapi_client *);
+	int (*updatecreds) (ssh_gssapi_ccache *, ssh_gssapi_client *);
 } ssh_gssapi_mech;
 
 typedef struct {
@@ -94,10 +122,11 @@ typedef struct {
 	gss_OID		oid; /* client */
 	gss_cred_id_t	creds; /* server */
 	gss_name_t	client; /* server */
-	gss_cred_id_t	client_creds; /* server */
+	gss_cred_id_t	client_creds; /* both */
 } Gssctxt;
 
 extern ssh_gssapi_mech *supported_mechs[];
+extern Gssctxt *gss_kex_context;
 
 int  ssh_gssapi_check_oid(Gssctxt *, void *, size_t);
 void ssh_gssapi_set_oid_data(Gssctxt *, void *, size_t);
@@ -109,6 +138,7 @@ OM_uint32 ssh_gssapi_test_oid_supported(OM_uint32 *, gss_OID, int *);
 
 struct sshbuf;
 int ssh_gssapi_get_buffer_desc(struct sshbuf *, gss_buffer_desc *);
+int ssh_gssapi_sshpkt_get_buffer_desc(struct ssh *, gss_buffer_desc *);
 
 OM_uint32 ssh_gssapi_import_name(Gssctxt *, const char *);
 OM_uint32 ssh_gssapi_init_ctx(Gssctxt *, int,
@@ -123,17 +153,33 @@ void ssh_gssapi_delete_ctx(Gssctxt **);
 OM_uint32 ssh_gssapi_sign(Gssctxt *, gss_buffer_t, gss_buffer_t);
 void ssh_gssapi_buildmic(struct sshbuf *, const char *,
     const char *, const char *, const struct sshbuf *);
-int ssh_gssapi_check_mechanism(Gssctxt **, gss_OID, const char *);
+int ssh_gssapi_check_mechanism(Gssctxt **, gss_OID, const char *, const char *);
+OM_uint32 ssh_gssapi_client_identity(Gssctxt *, const char *);
+int ssh_gssapi_credentials_updated(Gssctxt *);
 
 /* In the server */
+typedef int ssh_gssapi_check_fn(Gssctxt **, gss_OID, const char *,
+    const char *);
+char *ssh_gssapi_client_mechanisms(const char *, const char *, const char *);
+char *ssh_gssapi_kex_mechs(gss_OID_set, ssh_gssapi_check_fn *, const char *,
+    const char *, const char *);
+gss_OID ssh_gssapi_id_kex(Gssctxt *, char *, int);
+int ssh_gssapi_server_check_mech(Gssctxt **,gss_OID, const char *,
+    const char *);
 OM_uint32 ssh_gssapi_server_ctx(Gssctxt **, gss_OID);
-int ssh_gssapi_userok(char *name);
+int ssh_gssapi_userok(char *name, struct passwd *, int kex);
 OM_uint32 ssh_gssapi_checkmic(Gssctxt *, gss_buffer_t, gss_buffer_t);
 void ssh_gssapi_do_child(char ***, u_int *);
 void ssh_gssapi_cleanup_creds(void);
 void ssh_gssapi_storecreds(void);
 const char *ssh_gssapi_displayname(void);
 
+char *ssh_gssapi_server_mechanisms(void);
+int ssh_gssapi_oid_table_ok(void);
+
+int ssh_gssapi_update_creds(ssh_gssapi_ccache *store);
+void ssh_gssapi_rekey_creds(void);
+
 #endif /* GSSAPI */
 
 #endif /* _SSH_GSS_H */
diff --git a/ssh-null.c b/ssh-null.c
new file mode 100644
index 000000000..a934bda77
--- /dev/null
+++ b/ssh-null.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2023 Colin Watson.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "includes.h"
+
+#ifdef GSSAPI
+
+#include "sshbuf.h"
+#include "ssherr.h"
+#include "sshkey.h"
+
+static int
+ssh_null_equal(const struct sshkey *a, const struct sshkey *b)
+{
+	return 1;
+}
+
+static int
+ssh_null_serialize_public(const struct sshkey *key, struct sshbuf *b,
+    enum sshkey_serialize_rep opts)
+{
+	return SSH_ERR_KEY_TYPE_UNKNOWN;
+}
+
+static int
+ssh_null_deserialize_public(const char *ktype, struct sshbuf *b,
+    struct sshkey *key)
+{
+	return SSH_ERR_KEY_TYPE_UNKNOWN;
+}
+
+static int
+ssh_null_serialize_private(const struct sshkey *key, struct sshbuf *b,
+    enum sshkey_serialize_rep opts)
+{
+	return SSH_ERR_KEY_TYPE_UNKNOWN;
+}
+
+static int
+ssh_null_deserialize_private(const char *ktype, struct sshbuf *b,
+    struct sshkey *key)
+{
+	return SSH_ERR_KEY_TYPE_UNKNOWN;
+}
+
+static int
+ssh_null_copy_public(const struct sshkey *from, struct sshkey *to)
+{
+	return SSH_ERR_KEY_TYPE_UNKNOWN;
+}
+
+static int
+ssh_null_verify(const struct sshkey *key, const u_char *sig, size_t siglen,
+    const u_char *data, size_t dlen, const char *alg, u_int compat,
+    struct sshkey_sig_details **detailsp)
+{
+	return SSH_ERR_KEY_TYPE_UNKNOWN;
+}
+
+static const struct sshkey_impl_funcs sshkey_null_funcs = {
+	/* .size = */		NULL,
+	/* .alloc = */		NULL,
+	/* .cleanup = */	NULL,
+	/* .equal = */		ssh_null_equal,
+	/* .ssh_serialize_public = */ ssh_null_serialize_public,
+	/* .ssh_deserialize_public = */ ssh_null_deserialize_public,
+	/* .ssh_serialize_private = */ ssh_null_serialize_private,
+	/* .ssh_deserialize_private = */ ssh_null_deserialize_private,
+	/* .generate = */	NULL,
+	/* .copy_public = */	ssh_null_copy_public,
+	/* .sign = */		NULL,
+	/* .verify = */		ssh_null_verify,
+};
+
+const struct sshkey_impl sshkey_null_impl = {
+	/* .name = */		"null",
+	/* .shortname = */	"null",
+	/* .sigalg = */		NULL,
+	/* .type = */		KEY_NULL,
+	/* .nid = */		0,
+	/* .cert = */		0,
+	/* .sigonly = */	0,
+	/* .keybits = */	0,
+	/* .funcs = */		&sshkey_null_funcs,
+};
+
+#endif /* GSSAPI */
diff --git a/ssh.1 b/ssh.1
index 936c995ba..877c3bc64 100644
--- a/ssh.1
+++ b/ssh.1
@@ -536,7 +536,13 @@ For full details of the options listed below, and their possible values, see
 .It GatewayPorts
 .It GlobalKnownHostsFile
 .It GSSAPIAuthentication
+.It GSSAPIKeyExchange
+.It GSSAPIClientIdentity
 .It GSSAPIDelegateCredentials
+.It GSSAPIKexAlgorithms
+.It GSSAPIRenewalForcesRekey
+.It GSSAPIServerIdentity
+.It GSSAPITrustDns
 .It HashKnownHosts
 .It Host
 .It HostbasedAcceptedAlgorithms
@@ -624,6 +630,8 @@ flag),
 (supported message integrity codes),
 .Ar kex
 (key exchange algorithms),
+.Ar kex-gss
+(GSSAPI key exchange algorithms),
 .Ar key
 (key types),
 .Ar key-ca-sign
diff --git a/ssh.c b/ssh.c
index 48d93ddf2..f50cecdbb 100644
--- a/ssh.c
+++ b/ssh.c
@@ -827,6 +827,8 @@ main(int ac, char **av)
 			else if (strcmp(optarg, "kex") == 0 ||
 			    strcasecmp(optarg, "KexAlgorithms") == 0)
 				cp = kex_alg_list('\n');
+			else if (strcmp(optarg, "kex-gss") == 0)
+				cp = kex_gss_alg_list('\n');
 			else if (strcmp(optarg, "key") == 0)
 				cp = sshkey_alg_list(0, 0, 0, '\n');
 			else if (strcmp(optarg, "key-cert") == 0)
@@ -857,8 +859,8 @@ main(int ac, char **av)
 			} else if (strcmp(optarg, "help") == 0) {
 				cp = xstrdup(
 				    "cipher\ncipher-auth\ncompression\nkex\n"
-				    "key\nkey-cert\nkey-plain\nkey-sig\nmac\n"
-				    "protocol-version\nsig");
+				    "kex-gss\nkey\nkey-cert\nkey-plain\n"
+				    "key-sig\nmac\nprotocol-version\nsig");
 			}
 			if (cp == NULL)
 				fatal("Unsupported query \"%s\"", optarg);
diff --git a/ssh_config b/ssh_config
index cc5663562..16197d15d 100644
--- a/ssh_config
+++ b/ssh_config
@@ -24,6 +24,8 @@
 #   HostbasedAuthentication no
 #   GSSAPIAuthentication no
 #   GSSAPIDelegateCredentials no
+#   GSSAPIKeyExchange no
+#   GSSAPITrustDNS no
 #   BatchMode no
 #   CheckHostIP no
 #   AddressFamily any
diff --git a/ssh_config.5 b/ssh_config.5
index 4bbdfefd1..7ca72aedf 100644
--- a/ssh_config.5
+++ b/ssh_config.5
@@ -928,10 +928,67 @@ The default is
 Specifies whether user authentication based on GSSAPI is allowed.
 The default is
 .Cm no .
+.It Cm GSSAPIClientIdentity
+If set, specifies the GSSAPI client identity that ssh should use when
+connecting to the server. The default is unset, which means that the default
+identity will be used.
 .It Cm GSSAPIDelegateCredentials
 Forward (delegate) credentials to the server.
 The default is
 .Cm no .
+.It Cm GSSAPIKeyExchange
+Specifies whether key exchange based on GSSAPI may be used. When using
+GSSAPI key exchange the server need not have a host key.
+The default is
+.Dq no .
+.It Cm GSSAPIRenewalForcesRekey
+If set to
+.Dq yes
+then renewal of the client's GSSAPI credentials will force the rekeying of the
+ssh connection. With a compatible server, this will delegate the renewed
+credentials to a session on the server.
+.Pp
+Checks are made to ensure that credentials are only propagated when the new
+credentials match the old ones on the originating client and where the
+receiving server still has the old set in its cache.
+.Pp
+The default is
+.Dq no .
+.Pp
+For this to work
+.Cm GSSAPIKeyExchange
+needs to be enabled in the server and also used by the client.
+.It Cm GSSAPIServerIdentity
+If set, specifies the GSSAPI server identity that ssh should expect when
+connecting to the server. The default is unset, which means that the
+expected GSSAPI server identity will be determined from the target
+hostname.
+.It Cm GSSAPITrustDns
+Set to
+.Dq yes
+to indicate that the DNS is trusted to securely canonicalize
+the name of the host being connected to. If
+.Dq no ,
+the hostname entered on the
+command line will be passed untouched to the GSSAPI library.
+The default is
+.Dq no .
+.It Cm GSSAPIKexAlgorithms
+The list of key exchange algorithms that are offered for GSSAPI
+key exchange. Possible values are
+.Bd -literal -offset 3n
+gss-gex-sha1-,
+gss-group1-sha1-,
+gss-group14-sha1-,
+gss-group14-sha256-,
+gss-group16-sha512-,
+gss-nistp256-sha256-,
+gss-curve25519-sha256-
+.Ed
+.Pp
+The default is
+.Dq gss-group14-sha256-,gss-group16-sha512-,gss-nistp256-sha256-,gss-curve25519-sha256-,gss-gex-sha1-,gss-group14-sha1- .
+This option only applies to connections using GSSAPI.
 .It Cm HashKnownHosts
 Indicates that
 .Xr ssh 1
diff --git a/sshconnect2.c b/sshconnect2.c
index fab1e36be..cb584ad27 100644
--- a/sshconnect2.c
+++ b/sshconnect2.c
@@ -80,8 +80,6 @@
 #endif
 
 /* import */
-extern char *client_version_string;
-extern char *server_version_string;
 extern Options options;
 
 /*
@@ -224,6 +222,11 @@ ssh_kex2(struct ssh *ssh, char *host, struct sockaddr *hostaddr, u_short port,
 	char *s, *all_key, *hkalgs = NULL;
 	int r, use_known_hosts_order = 0;
 
+#if defined(GSSAPI) && defined(WITH_OPENSSL)
+	char *orig = NULL, *gss = NULL;
+	char *gss_host = NULL;
+#endif
+
 	xxx_host = host;
 	xxx_hostaddr = hostaddr;
 	xxx_conn_info = cinfo;
@@ -261,6 +264,42 @@ ssh_kex2(struct ssh *ssh, char *host, struct sockaddr *hostaddr, u_short port,
 
 	free(hkalgs);
 
+#if defined(GSSAPI) && defined(WITH_OPENSSL)
+	if (options.gss_keyex) {
+		/* Add the GSSAPI mechanisms currently supported on this
+		 * client to the key exchange algorithm proposal */
+		orig = myproposal[PROPOSAL_KEX_ALGS];
+
+		if (options.gss_server_identity) {
+			gss_host = xstrdup(options.gss_server_identity);
+		} else if (options.gss_trust_dns) {
+			gss_host = remote_hostname(ssh);
+			/* Fall back to specified host if we are using proxy command
+			 * and can not use DNS on that socket */
+			if (strcmp(gss_host, "UNKNOWN") == 0) {
+				free(gss_host);
+				gss_host = xstrdup(host);
+			}
+		} else {
+			gss_host = xstrdup(host);
+		}
+
+		gss = ssh_gssapi_client_mechanisms(gss_host,
+		    options.gss_client_identity, options.gss_kex_algorithms);
+		if (gss) {
+			debug("Offering GSSAPI proposal: %s", gss);
+			xasprintf(&myproposal[PROPOSAL_KEX_ALGS],
+			    "%s,%s", gss, orig);
+
+			/* If we've got GSSAPI algorithms, then we also support the
+			 * 'null' hostkey, as a last resort */
+			orig = myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS];
+			xasprintf(&myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS],
+			    "%s,null", orig);
+		}
+	}
+#endif
+
 	/* start key exchange */
 	if ((r = kex_setup(ssh, myproposal)) != 0)
 		fatal_r(r, "kex_setup");
@@ -275,17 +314,47 @@ ssh_kex2(struct ssh *ssh, char *host, struct sockaddr *hostaddr, u_short port,
 # ifdef OPENSSL_HAS_ECC
 	ssh->kex->kex[KEX_ECDH_SHA2] = kex_gen_client;
 # endif
-#endif
+# ifdef GSSAPI
+	if (options.gss_keyex) {
+		ssh->kex->kex[KEX_GSS_GRP1_SHA1] = kexgss_client;
+		ssh->kex->kex[KEX_GSS_GRP14_SHA1] = kexgss_client;
+		ssh->kex->kex[KEX_GSS_GRP14_SHA256] = kexgss_client;
+		ssh->kex->kex[KEX_GSS_GRP16_SHA512] = kexgss_client;
+		ssh->kex->kex[KEX_GSS_GEX_SHA1] = kexgssgex_client;
+		ssh->kex->kex[KEX_GSS_NISTP256_SHA256] = kexgss_client;
+		ssh->kex->kex[KEX_GSS_C25519_SHA256] = kexgss_client;
+	}
+# endif
+#endif /* WITH_OPENSSL */
 	ssh->kex->kex[KEX_C25519_SHA256] = kex_gen_client;
 	ssh->kex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_client;
 	ssh->kex->verify_host_key=&verify_host_key_callback;
 
+#if defined(GSSAPI) && defined(WITH_OPENSSL)
+	if (options.gss_keyex) {
+		ssh->kex->gss_deleg_creds = options.gss_deleg_creds;
+		ssh->kex->gss_trust_dns = options.gss_trust_dns;
+		ssh->kex->gss_client = options.gss_client_identity;
+		ssh->kex->gss_host = gss_host;
+	}
+#endif
+
 	ssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &ssh->kex->done);
 
 	/* remove ext-info from the KEX proposals for rekeying */
 	free(myproposal[PROPOSAL_KEX_ALGS]);
 	myproposal[PROPOSAL_KEX_ALGS] =
 	    compat_kex_proposal(ssh, options.kex_algorithms);
+#if defined(GSSAPI) && defined(WITH_OPENSSL)
+	/* repair myproposal after it was crumpled by the */
+	/* ext-info removal above */
+	if (gss) {
+		orig = myproposal[PROPOSAL_KEX_ALGS];
+		xasprintf(&myproposal[PROPOSAL_KEX_ALGS],
+		    "%s,%s", gss, orig);
+		free(gss);
+	}
+#endif
 	if ((r = kex_prop2buf(ssh->kex->my, myproposal)) != 0)
 		fatal_r(r, "kex_prop2buf");
 
@@ -379,6 +448,7 @@ static int input_gssapi_response(int type, u_int32_t, struct ssh *);
 static int input_gssapi_token(int type, u_int32_t, struct ssh *);
 static int input_gssapi_error(int, u_int32_t, struct ssh *);
 static int input_gssapi_errtok(int, u_int32_t, struct ssh *);
+static int userauth_gsskeyex(struct ssh *);
 #endif
 
 void	userauth(struct ssh *, char *);
@@ -395,6 +465,11 @@ static char *authmethods_get(void);
 
 Authmethod authmethods[] = {
 #ifdef GSSAPI
+	{"gssapi-keyex",
+		userauth_gsskeyex,
+		NULL,
+		&options.gss_keyex,
+		NULL},
 	{"gssapi-with-mic",
 		userauth_gssapi,
 		userauth_gssapi_cleanup,
@@ -766,12 +841,32 @@ userauth_gssapi(struct ssh *ssh)
 	OM_uint32 min;
 	int r, ok = 0;
 	gss_OID mech = NULL;
+	char *gss_host = NULL;
+
+	if (options.gss_server_identity) {
+		gss_host = xstrdup(options.gss_server_identity);
+	} else if (options.gss_trust_dns) {
+		gss_host = remote_hostname(ssh);
+		/* Fall back to specified host if we are using proxy command
+		 * and can not use DNS on that socket */
+		if (strcmp(gss_host, "UNKNOWN") == 0) {
+			free(gss_host);
+			gss_host = xstrdup(authctxt->host);
+		}
+	} else {
+		gss_host = xstrdup(authctxt->host);
+	}
 
 	/* Try one GSSAPI method at a time, rather than sending them all at
 	 * once. */
 
 	if (authctxt->gss_supported_mechs == NULL)
-		gss_indicate_mechs(&min, &authctxt->gss_supported_mechs);
+		if (GSS_ERROR(gss_indicate_mechs(&min,
+		    &authctxt->gss_supported_mechs))) {
+			authctxt->gss_supported_mechs = NULL;
+			free(gss_host);
+			return 0;
+		}
 
 	/* Check to see whether the mechanism is usable before we offer it */
 	while (authctxt->mech_tried < authctxt->gss_supported_mechs->count &&
@@ -780,13 +875,15 @@ userauth_gssapi(struct ssh *ssh)
 		    elements[authctxt->mech_tried];
 		/* My DER encoding requires length<128 */
 		if (mech->length < 128 && ssh_gssapi_check_mechanism(&gssctxt,
-		    mech, authctxt->host)) {
+		    mech, gss_host, options.gss_client_identity)) {
 			ok = 1; /* Mechanism works */
 		} else {
 			authctxt->mech_tried++;
 		}
 	}
 
+	free(gss_host);
+
 	if (!ok || mech == NULL)
 		return 0;
 
@@ -1020,6 +1117,55 @@ input_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)
 	free(lang);
 	return r;
 }
+
+int
+userauth_gsskeyex(struct ssh *ssh)
+{
+	struct sshbuf *b = NULL;
+	Authctxt *authctxt = ssh->authctxt;
+	gss_buffer_desc gssbuf;
+	gss_buffer_desc mic = GSS_C_EMPTY_BUFFER;
+	OM_uint32 ms;
+	int r;
+
+	static int attempt = 0;
+	if (attempt++ >= 1)
+		return (0);
+
+	if (gss_kex_context == NULL) {
+		debug("No valid Key exchange context");
+		return (0);
+	}
+
+	if ((b = sshbuf_new()) == NULL)
+		fatal_f("sshbuf_new failed");
+
+	ssh_gssapi_buildmic(b, authctxt->server_user, authctxt->service,
+	    "gssapi-keyex", ssh->kex->session_id);
+
+	if ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)
+		fatal_f("sshbuf_mutable_ptr failed");
+	gssbuf.length = sshbuf_len(b);
+
+	if (GSS_ERROR(ssh_gssapi_sign(gss_kex_context, &gssbuf, &mic))) {
+		sshbuf_free(b);
+		return (0);
+	}
+
+	if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
+	    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||
+	    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||
+	    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||
+	    (r = sshpkt_put_string(ssh, mic.value, mic.length)) != 0 ||
+	    (r = sshpkt_send(ssh)) != 0)
+		fatal_fr(r, "parsing");
+
+	sshbuf_free(b);
+	gss_release_buffer(&ms, &mic);
+
+	return (1);
+}
+
 #endif /* GSSAPI */
 
 static int
diff --git a/sshd.c b/sshd.c
index 9cbe92293..fee5cac64 100644
--- a/sshd.c
+++ b/sshd.c
@@ -798,8 +798,8 @@ notify_hostkeys(struct ssh *ssh)
 	}
 	debug3_f("sent %u hostkeys", nkeys);
 	if (nkeys == 0)
-		fatal_f("no hostkeys");
-	if ((r = sshpkt_send(ssh)) != 0)
+		debug3_f("no hostkeys");
+	else if ((r = sshpkt_send(ssh)) != 0)
 		sshpkt_fatal(ssh, r, "%s: send", __func__);
 	sshbuf_free(buf);
 }
@@ -1930,7 +1930,8 @@ main(int ac, char **av)
 		free(fp);
 	}
 	accumulate_host_timing_secret(cfg, NULL);
-	if (!sensitive_data.have_ssh2_key) {
+	/* The GSSAPI key exchange can run without a host key */
+	if (!sensitive_data.have_ssh2_key && !options.gss_keyex) {
 		logit("sshd: no hostkeys available -- exiting.");
 		exit(1);
 	}
@@ -2402,6 +2403,48 @@ do_ssh2_kex(struct ssh *ssh)
 
 	free(hkalgs);
 
+#if defined(GSSAPI) && defined(WITH_OPENSSL)
+	{
+	char *orig;
+	char *gss = NULL;
+	char *newstr = NULL;
+	orig = myproposal[PROPOSAL_KEX_ALGS];
+
+	/*
+	 * If we don't have a host key, then there's no point advertising
+	 * the other key exchange algorithms
+	 */
+
+	if (strlen(myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS]) == 0)
+		orig = NULL;
+
+	if (options.gss_keyex)
+		gss = ssh_gssapi_server_mechanisms();
+	else
+		gss = NULL;
+
+	if (gss && orig)
+		xasprintf(&newstr, "%s,%s", gss, orig);
+	else if (gss)
+		newstr = gss;
+	else if (orig)
+		newstr = orig;
+
+	/*
+	 * If we've got GSSAPI mechanisms, then we've got the 'null' host
+	 * key alg, but we can't tell people about it unless its the only
+	 * host key algorithm we support
+	 */
+	if (gss && (strlen(myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS])) == 0)
+		myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = "null";
+
+	if (newstr)
+		myproposal[PROPOSAL_KEX_ALGS] = newstr;
+	else
+		fatal("No supported key exchange algorithms");
+	}
+#endif
+
 	/* start key exchange */
 	if ((r = kex_setup(ssh, myproposal)) != 0)
 		fatal_r(r, "kex_setup");
@@ -2419,7 +2462,18 @@ do_ssh2_kex(struct ssh *ssh)
 # ifdef OPENSSL_HAS_ECC
 	kex->kex[KEX_ECDH_SHA2] = kex_gen_server;
 # endif
-#endif
+# ifdef GSSAPI
+	if (options.gss_keyex) {
+		kex->kex[KEX_GSS_GRP1_SHA1] = kexgss_server;
+		kex->kex[KEX_GSS_GRP14_SHA1] = kexgss_server;
+		kex->kex[KEX_GSS_GRP14_SHA256] = kexgss_server;
+		kex->kex[KEX_GSS_GRP16_SHA512] = kexgss_server;
+		kex->kex[KEX_GSS_GEX_SHA1] = kexgssgex_server;
+		kex->kex[KEX_GSS_NISTP256_SHA256] = kexgss_server;
+		kex->kex[KEX_GSS_C25519_SHA256] = kexgss_server;
+	}
+# endif
+#endif /* WITH_OPENSSL */
 	kex->kex[KEX_C25519_SHA256] = kex_gen_server;
 	kex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_server;
 	kex->load_host_public_key=&get_hostkey_public_by_type;
diff --git a/sshd_config b/sshd_config
index 36894ace5..ecfe8d026 100644
--- a/sshd_config
+++ b/sshd_config
@@ -69,6 +69,8 @@ AuthorizedKeysFile	.ssh/authorized_keys
 # GSSAPI options
 #GSSAPIAuthentication no
 #GSSAPICleanupCredentials yes
+#GSSAPIStrictAcceptorCheck yes
+#GSSAPIKeyExchange no
 
 # Set this to 'yes' to enable PAM authentication, account processing,
 # and session processing. If this is enabled, PAM authentication will
diff --git a/sshd_config.5 b/sshd_config.5
index 7e1a56cd0..d2f09de9b 100644
--- a/sshd_config.5
+++ b/sshd_config.5
@@ -731,6 +731,11 @@ Specifies whether to automatically destroy the user's credentials cache
 on logout.
 The default is
 .Cm yes .
+.It Cm GSSAPIKeyExchange
+Specifies whether key exchange based on GSSAPI is allowed. GSSAPI key exchange
+doesn't rely on ssh keys to verify host identity.
+The default is
+.Cm no .
 .It Cm GSSAPIStrictAcceptorCheck
 Determines whether to be strict about the identity of the GSSAPI acceptor
 a client authenticates against.
@@ -745,6 +750,31 @@ machine's default store.
 This facility is provided to assist with operation on multi homed machines.
 The default is
 .Cm yes .
+.It Cm GSSAPIStoreCredentialsOnRekey
+Controls whether the user's GSSAPI credentials should be updated following a
+successful connection rekeying. This option can be used to accepted renewed
+or updated credentials from a compatible client. The default is
+.Dq no .
+.Pp
+For this to work
+.Cm GSSAPIKeyExchange
+needs to be enabled in the server and also used by the client.
+.It Cm GSSAPIKexAlgorithms
+The list of key exchange algorithms that are accepted by GSSAPI
+key exchange. Possible values are
+.Bd -literal -offset 3n
+gss-gex-sha1-,
+gss-group1-sha1-,
+gss-group14-sha1-,
+gss-group14-sha256-,
+gss-group16-sha512-,
+gss-nistp256-sha256-,
+gss-curve25519-sha256-
+.Ed
+.Pp
+The default is
+.Dq gss-group14-sha256-,gss-group16-sha512-,gss-nistp256-sha256-,gss-curve25519-sha256-,gss-gex-sha1-,gss-group14-sha1- .
+This option only applies to connections using GSSAPI.
 .It Cm HostbasedAcceptedAlgorithms
 Specifies the signature algorithms that will be accepted for hostbased
 authentication as a list of comma-separated patterns.
diff --git a/sshkey.c b/sshkey.c
index 06db9b5da..1e7810337 100644
--- a/sshkey.c
+++ b/sshkey.c
@@ -128,6 +128,9 @@ extern const struct sshkey_impl sshkey_dsa_cert_impl;
 extern const struct sshkey_impl sshkey_xmss_impl;
 extern const struct sshkey_impl sshkey_xmss_cert_impl;
 #endif
+#ifdef GSSAPI
+extern const struct sshkey_impl sshkey_null_impl;
+#endif /* GSSAPI */
 
 const struct sshkey_impl * const keyimpls[] = {
 	&sshkey_ed25519_impl,
@@ -165,6 +168,9 @@ const struct sshkey_impl * const keyimpls[] = {
 	&sshkey_xmss_impl,
 	&sshkey_xmss_cert_impl,
 #endif
+#ifdef GSSAPI
+	&sshkey_null_impl,
+#endif /* GSSAPI */
 	NULL
 };
 
@@ -320,7 +326,7 @@ sshkey_alg_list(int certs_only, int plain_only, int include_sigonly, char sep)
 
 	for (i = 0; keyimpls[i] != NULL; i++) {
 		impl = keyimpls[i];
-		if (impl->name == NULL)
+		if (impl->name == NULL || impl->type == KEY_NULL)
 			continue;
 		if (!include_sigonly && impl->sigonly)
 			continue;
diff --git a/sshkey.h b/sshkey.h
index 708f2da86..dddb40fe2 100644
--- a/sshkey.h
+++ b/sshkey.h
@@ -71,6 +71,7 @@ enum sshkey_types {
 	KEY_ECDSA_SK_CERT,
 	KEY_ED25519_SK,
 	KEY_ED25519_SK_CERT,
+	KEY_NULL,
 	KEY_UNSPEC
 };
 
