diff --git a/mscore/importmidi/importmidi_lyrics.cpp b/mscore/importmidi/importmidi_lyrics.cpp
index f6f95471d2071a75c209493b9e11b29f66f82d2e..b4704e1b7a692cc64aaae5fdb74182125b11907d 100644
--- a/mscore/importmidi/importmidi_lyrics.cpp
+++ b/mscore/importmidi/importmidi_lyrics.cpp
@@ -103,8 +103,10 @@ BestTrack findBestTrack(
       BestTrack bestTrack;
       int maxMatches = 0;
 
+#ifdef QT_DEBUG
       Q_ASSERT_X(areEqualIndexesSuccessive(tracks),
                  "MidiLyrics::findBestTrack", "Equal indexes of operations are not successive");
+#endif
 
       for (int i = 0; i != tracks.size(); ++i) {
             if (tracks[i].mtrack->drumTrack() || usedTracks.find(i) != usedTracks.end())
diff --git a/mscore/importmidi/importmidi_drum.cpp b/mscore/importmidi/importmidi_drum.cpp
index 0f404516cc7c7930076c5569aec7b6e5d087acd6..32ff5fec3532c33bda6437df02e830916d283c35 100644
--- a/mscore/importmidi/importmidi_drum.cpp
+++ b/mscore/importmidi/importmidi_drum.cpp
@@ -74,6 +74,7 @@ void splitDrumVoices(std::multimap<int, MTrack> &tracks)
             const Drumset* const drumset = mtrack.mtrack->drumTrack() ? smDrumset : 0;
             if (!drumset)
                   continue;
+#ifdef QT_DEBUG
                               // all chords of drum track should have voice == 0
                               // because allowedVoices == V_1 (see MidiImportOperations)
                               // also, all chords should have different onTime values
@@ -83,6 +84,7 @@ void splitDrumVoices(std::multimap<int, MTrack> &tracks)
             Q_ASSERT_X(haveNonZeroVoices(chords),
                        "MidiDrum::splitDrumVoices",
                        "All voices of drum track should be zero here");
+#endif
 
             for (auto chordIt = chords.begin(); chordIt != chords.end(); ++chordIt) {
                   auto &notes = chordIt->second.notes;
diff --git a/mscore/importmidi/importmidi.cpp b/mscore/importmidi/importmidi.cpp
index a5d8894686c32f633dffd65a9b9109d1164c0b81..889a36dbbe16b4410353e08c1c3c5910b9866afc 100644
--- a/mscore/importmidi/importmidi.cpp
+++ b/mscore/importmidi/importmidi.cpp
@@ -137,6 +137,9 @@ bool noTooShortNotes(const std::multimap<int, MTrack> &tracks)
       return true;
       }
 
+#define Q_ASSERT_Y(cond,where,what) Q_ASSERT_X(cond,where,what)
+#else
+#define Q_ASSERT_Y(cond,where,what) /**/
 #endif
 
 std::vector<std::multimap<ReducedFraction, MidiChord> >
@@ -229,7 +232,7 @@ void quantizeAllTracks(std::multimap<int, MTrack> &tracks,
             const auto basicQuant = Quantize::quantValueToFraction(
                         opers.data()->trackOpers.quantValue.value(mtrack.indexOfOperation));
 
-            Q_ASSERT_X(MChord::isLastTickValid(lastTick, mtrack.chords),
+            Q_ASSERT_Y(MChord::isLastTickValid(lastTick, mtrack.chords),
                        "quantizeAllTracks", "Last tick is less than max note off time");
 
             MChord::setBarIndexes(mtrack.chords, basicQuant, lastTick, sigmap);
@@ -239,7 +242,7 @@ void quantizeAllTracks(std::multimap<int, MTrack> &tracks,
             else
                   MidiTuplet::findAllTuplets(mtrack.tuplets, mtrack.chords, sigmap, basicQuant);
 
-            Q_ASSERT_X(!doNotesOverlap(track.second),
+            Q_ASSERT_Y(!doNotesOverlap(track.second),
                        "quantizeAllTracks",
                        "There are overlapping notes of the same voice that is incorrect");
 
@@ -249,7 +252,7 @@ void quantizeAllTracks(std::multimap<int, MTrack> &tracks,
             Quantize::quantizeChords(mtrack.chords, sigmap, basicQuant);
             MidiTuplet::removeEmptyTuplets(mtrack);
 
-            Q_ASSERT_X(MidiTuplet::areTupletRangesOk(mtrack.chords, mtrack.tuplets),
+            Q_ASSERT_Y(MidiTuplet::areTupletRangesOk(mtrack.chords, mtrack.tuplets),
                        "quantizeAllTracks", "Tuplet chord/note is outside tuplet "
                         "or non-tuplet chord/note is inside tuplet");
             }
@@ -1000,10 +1003,10 @@ void applySwing(QList<MTrack> &tracks)
             const auto swingType = opers.swing.value(mt.indexOfOperation);
             Swing::detectSwing(mt.staff, swingType);
 
-            Q_ASSERT_X(MidiTie::areTiesConsistent(mt.staff),
+            Q_ASSERT_Y(MidiTie::areTiesConsistent(mt.staff),
                        "applySwing", "Ties are inconsistent");
 
-            Q_ASSERT_X(MidiTuplet::haveTupletsEnoughElements(mt.staff),
+            Q_ASSERT_Y(MidiTuplet::haveTupletsEnoughElements(mt.staff),
                        "MTrack::convertTrack",
                        "Tuplet has less than 2 elements or all elements are rests");
             }
@@ -1115,7 +1118,7 @@ QList<MTrack> convertMidi(Score *score, const MidiFile *mf)
 
       MChord::removeOverlappingNotes(tracks);
 
-      Q_ASSERT_X(!doNotesOverlap(tracks),
+      Q_ASSERT_Y(!doNotesOverlap(tracks),
                  "convertMidi", "There are overlapping notes of the same voice that is incorrect");
 
       LRHand::splitIntoLeftRightHands(tracks);
@@ -1125,9 +1128,9 @@ QList<MTrack> convertMidi(Score *score, const MidiFile *mf)
       quantizeAllTracks(tracks, sigmap, lastTick);
       MChord::removeOverlappingNotes(tracks);
 
-      Q_ASSERT_X(!doNotesOverlap(tracks),
+      Q_ASSERT_Y(!doNotesOverlap(tracks),
                  "convertMidi", "There are overlapping notes of the same voice that is incorrect");
-      Q_ASSERT_X(noTooShortNotes(tracks),
+      Q_ASSERT_Y(noTooShortNotes(tracks),
                  "convertMidi", "There are notes of length < min allowed duration");
 
       MChord::mergeChordsWithEqualOnTimeAndVoice(tracks);
diff --git a/mscore/importmidi/importmidi_clef.cpp b/mscore/importmidi/importmidi_clef.cpp
index 2552386496e437192681ae611c14d39844f3791e..a03338b02b40c3a294d9a7669cd826e83648dfad 100644
--- a/mscore/importmidi/importmidi_clef.cpp
+++ b/mscore/importmidi/importmidi_clef.cpp
@@ -480,7 +480,9 @@ void createClefs(Staff *staff, int indexOfOperation, bool isDrumTrack)
       if (!mainClefWasSet && canChangeClef)
             createMainClefFromAveragePitch(staff, strack);
 
+#ifdef QT_DEBUG
       Q_ASSERT_X(!doesClefBreakTie(staff), "MidiClef::createClefs", "Clef breaks the tie");
+#endif
       }
 
 } // namespace MidiClef
